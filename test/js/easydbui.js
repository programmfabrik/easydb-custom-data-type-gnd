/*
 * easydb-custom-data-type-gnd - easydb 5 plugin
 * Copyright (c) 2016 Programmfabrik GmbH
 * MIT Licence
 * https://github.com/programmfabrik/easydb-custom-data-type-gnd
*/

// Generated by CoffeeScript 1.9.3
var $elementIsInDOM, addToArray, alert_dump, assert, assertImplements, assertInstanceOf, compareIndex, copyObject, dump, elementGetPosition, escapeAttribute, escapeRegExp, findInArray, getCoordinatesFromEvent, getFloat, getInt, getIntOrString, getMs, getObjectClass, idxInArray, isBoolean, isContent, isDeferred, isElement, isEmpty, isFalse, isFloat, isInteger, isNull, isNumber, isPromise, isString, isTrue, isUndef, moveInArray, pushOntoArray, removeFromArray, toCamel, toClass, toDash, toDot, toHtml, xor;

assert = function(condition, caller, message, debug_output) {
  var args, e, key, msg, parms, stack, value;
  if (!CUI.defaults.asserts) {
    return;
  }
  if (condition) {
    return;
  }
  try {
    e = new Error('dummy');
    stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@').replace().split('\n');
  } catch (_error) {
    e = _error;
    stack = "Can't get callstack in this browser. Try using Stacktrace.js";
  }
  parms = [];
  if (debug_output) {
    args = [caller + ":"];
    for (key in debug_output) {
      value = debug_output[key];
      args.push(key + ":");
      parms.push(key);
      args.push(value);
    }
    CUI.debug.apply(console, args);
  }
  if (parms.length) {
    msg = caller + "(" + (parms.join(",")) + ")";
  } else {
    msg = caller;
  }
  if (message) {
    msg += ": " + message;
  }
  if (false && CUI.problem) {
    CUI.problem({
      title: "ASSERT",
      text: msg
    });
  } else {
    alert(msg);
  }
  throw new Error(msg);
};

assertImplements = function(inst, methods) {
  var j, len, method, needs;
  if (!CUI.defaults.asserts) {
    return;
  }
  needs = [];
  for (j = 0, len = methods.length; j < len; j++) {
    method = methods[j];
    if (!CUI.isFunction(inst[method])) {
      needs.push(method);
    }
  }
  assert(needs.length === 0, "" + (getObjectClass(inst)), "Needs implementations for " + (needs.join(', ')) + ".", {
    instance: inst
  });
};

assertInstanceOf = function(variableName, classClass, opts, value) {
  var cn, cond, fn;
  if (value == null) {
    value = void 0;
  }
  if (!CUI.defaults.asserts) {
    return;
  }
  if (!CUI.isFunction(classClass) && !classClass === "PlainObject") {
    throw "assertInstanceOf: class is not a Function";
  }
  if (value === void 0) {
    value = opts[variableName];
    assert(CUI.isPlainObject(opts), "new " + arguments.callee.caller.name, "opts needs to be PlainObject but it is " + (getObjectClass(opts)) + ".", {
      opts: opts
    });
  }
  if (classClass === "Array") {
    cn = "Array";
    cond = value instanceof Array;
  } else if (classClass === "Integer") {
    cn = "Integer";
    cond = isInteger(value);
  } else if (classClass === "PlainObject") {
    cn = "PlainObject";
    cond = CUI.isPlainObject(value);
  } else if ((new String) instanceof classClass) {
    cn = "String";
    cond = isString(value);
  } else if ((new Boolean) instanceof classClass) {
    cn = "Boolean";
    cond = value === true || value === false;
  } else {
    cond = value instanceof classClass;
    cn = classClass.name;
  }
  if (cond) {
    return;
  }
  fn = arguments.callee.caller.name;
  if (!fn) {
    fn = getObjectClass(this);
  }
  assert(false, "new " + fn, "opts." + variableName + " needs to be instance of " + cn + " but it is " + (getObjectClass(value)) + ".", {
    opts: opts,
    value: value,
    classClass: classClass
  });
};

$elementIsInDOM = function($el) {
  return $el.parents().last().is("html");
};

getCoordinatesFromEvent = function(ev) {
  var coord;
  coord = {
    pageX: ev.pageX(),
    pageY: ev.pageY()
  };
  if (ev.scrollPageY) {
    coord.pageY += ev.scrollPageY;
  }
  if (ev.scrollPageX) {
    coord.pageX += ev.scrollPageX;
  }
  return coord;
};

elementGetPosition = function(coordinates, el) {
  var position, rect;
  rect = DOM.getRect(el);
  position = {
    left: coordinates.pageX - rect.left,
    top: coordinates.pageY - rect.top
  };
  if (el !== document.body) {
    position.left += el.scrollLeft;
    position.top += el.scrollTop;
  }
  return position;
};

getObjectClass = function(obj) {
  var arr;
  if (obj && obj.constructor && obj.constructor.toString) {
    arr = obj.constructor.toString().match(/function\s*(\w+)/);
    if (arr && arr.length === 2) {
      return arr[1];
    }
  }
  return void 0;
};

isUndef = function(obj) {
  return typeof obj === "undefined";
};

isNull = function(obj) {
  return isUndef(obj) || obj === null;
};

isString = function(obj) {
  return typeof obj === "string";
};

isEmpty = function(obj) {
  return isNull(obj) || obj === "";
};

isTrue = function(obj) {
  return !isNull(obj) && (obj === 1 || obj === true || obj === "1" || obj === "true");
};

isFalse = function(obj) {
  return isNull(obj) || obj === 0 || obj === false || obj === "0" || obj === "false";
};

isBoolean = function(obj) {
  return obj === true || obj === false;
};

isElement = function(obj) {
  return obj instanceof HTMLElement;
};

isContent = function(obj) {
  return isElement(obj) || obj instanceof HTMLCollection || obj instanceof NodeList || CUI.isArray(obj) || CUI.isFunction(obj) || isElement(obj != null ? obj.DOM : void 0);
};

isNumber = function(n) {
  return isInteger(n) || isFloat(n);
};

isFloat = function(n) {
  return n===+n && n!==(n|0);
};

isInteger = function(n) {
  return n===+n && n===(n|0);
};

isPromise = function(n) {
  if (n instanceof CUI.Promise || n instanceof CUI.Deferred) {
    return true;
  } else {
    return false;
  }
};

isDeferred = function(n) {
  if (n instanceof CUI.Deferred) {
    return true;
  } else {
    return false;
  }
};

escapeRegExp = function(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

getIntOrString = function(s) {
  return getInt(s, true);
};

getInt = function(s, ret_as_is) {
  var i;
  if (ret_as_is == null) {
    ret_as_is = false;
  }
  if (isNull(s)) {
    return null;
  }
  i = parseInt(s);
  if (isNaN(i) || (i + "").length !== (s + "").trim().length) {
    if (ret_as_is) {
      return s;
    } else {
      return null;
    }
  }
  return i;
};

getFloat = function(s) {
  var f;
  if (isNull(s)) {
    return null;
  }
  f = parseFloat(s);
  if (isNaN(f)) {
    return null;
  } else {
    return f;
  }
};

xor = function(a, b) {
  return !!((a && !b) || (!a && b));
};

escapeAttribute = function(data) {
  if (isNull(data) || !isString(data)) {
    return "";
  }
  data = data.replace(/"/g, "&quot;").replace(/\'/g, "&#39;");
  return data;
};

toHtml = function(data, space2nbsp) {
  if (isNull(data) || !isString(data)) {
    return "";
  }
  data = data.replace(/&/g, "&amp;").replace(/\'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;");
  if (space2nbsp) {
    return data.replace(/\s/g, "&nbsp;");
  } else {
    return data;
  }
};

copyObject = function(obj, deep, level) {
  var e, j, k, len, new_arr, new_obj, o, ref, v;
  if (deep == null) {
    deep = false;
  }
  if (level == null) {
    level = 0;
  }
  if ((ref = typeof obj) === "string" || ref === "number" || ref === "boolean" || ref === "function") {
    return obj;
  }
  if (isNull(obj)) {
    return obj;
  }
  if (obj instanceof CUI.Element) {
    if (level === 0 || deep) {
      return obj.copy();
    } else {
      return obj;
    }
  }
  if (obj instanceof HTMLElement) {
    return obj;
  }
  if (obj instanceof CUI.Dummy) {
    return obj;
  }
  if (CUI.isPlainObject(obj)) {
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      if (deep) {
        try {
          new_obj[k] = copyObject(v, true, level + 1);
        } catch (_error) {
          e = _error;
          console.error("Error during Object copy:", e.toString(), "Key:", k, "Object:", obj);
          throw e;
        }
      } else {
        new_obj[k] = v;
      }
    }
    return new_obj;
  }
  if (CUI.isArray(obj)) {
    if (!deep) {
      return obj.slice(0);
    }
    new_arr = [];
    for (j = 0, len = obj.length; j < len; j++) {
      o = obj[j];
      new_arr.push(copyObject(o, true, level + 1));
    }
    return new_arr;
  }
  return assert(false, "copyObject", "Only {},[],string, boolean, and number can be copied. Object is: " + (getObjectClass(obj)), {
    obj: obj,
    deep: deep
  });
};

dump = function(obj, space) {
  var clean_obj, e;
  if (space == null) {
    space = "\t";
  }
  clean_obj = function(obj) {
    var item, j, k, len, ref, result, v;
    if (CUI.isArray(obj)) {
      result = [];
      for (j = 0, len = obj.length; j < len; j++) {
        item = obj[j];
        result.push(clean_obj(item));
      }
      return result;
    } else if (CUI.isPlainObject(obj)) {
      result = {};
      for (k in obj) {
        v = obj[k];
        result[k] = clean_obj(v);
      }
      return result;
    } else if ((ref = typeof obj) === "string" || ref === "number" || ref === "boolean") {
      return obj;
    } else if (isUndef(obj)) {
      return "<undefined>";
    } else if (isNull(obj)) {
      return "<null>";
    } else {
      return getObjectClass(obj);
    }
  };
  try {
    return JSON.stringify(clean_obj(obj), null, space);
  } catch (_error) {
    e = _error;
    CUI.error(e);
    return "Unable to dump object";
  }
};

alert_dump = function(v) {
  return alert(dump(v, "    "));
};

toDash = function(s) {
  var s1;
  s = s + "U";
  s1 = s.substring(0, 1) + s.substring(1).replace(/([A-Z](?![A-Z]))/g, function($1) {
    return "-" + ($1.toLowerCase());
  });
  s1 = s1.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  s1 = s1.substring(0, s1.length - 2);
  return s1.replace(/\./g, "-");
};

toClass = function(s) {
  return toDash(s).replace(/_/g, "-").replace(/\s+/g, "-");
};

toDot = function(s) {
  return toDash(s).replace(/-/g, ".");
};

toCamel = function(s, includeFirst) {
  if (includeFirst == null) {
    includeFirst = false;
  }
  if (includeFirst) {
    return s.replace(/((\-|^)[a-z])/g, function($1) {
      return $1.toUpperCase().replace('-', '');
    });
  } else {
    return s.replace(/(\-[a-z])/g, function($1) {
      return $1.toUpperCase().replace('-', '');
    });
  }
};

removeFromArray = function(value, arr, compFunc) {
  var idx, removed;
  assert(CUI.isArray(arr), "removeFromArray", "Second parameter needs to be an Array", {
    value: value,
    array: arr,
    compFunc: compFunc
  });
  removed = 0;
  while (true) {
    idx = idxInArray(value, arr, compFunc);
    if (idx > -1) {
      arr.splice(idx, 1);
      removed++;
    } else {
      break;
    }
  }
  return removed;
};

moveInArray = function(from, to, arr, after) {
  var move;
  if (after == null) {
    after = false;
  }
  if (from === to) {
    return to;
  }
  if (from > to) {
    if (after) {
      to++;
    }
  } else {
    if (!after) {
      to--;
    }
  }
  move = arr.splice(from, 1)[0];
  arr.splice(to, 0, move);
  return to;
};

compareIndex = function(a_idx, b_idx) {
  if (a_idx < b_idx) {
    return -1;
  } else if (a_idx > b_idx) {
    return 1;
  } else {
    return 0;
  }
};

pushOntoArray = function(value, arr, compFunc) {
  var idx;
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    arr.push(value);
    return arr.length - 1;
  } else {
    return idx;
  }
};

idxInArray = function(value, arr, compFunc) {
  var a, i, idx, j, len;
  if (!compFunc) {
    return arr.indexOf(value);
  }
  idx = -1;
  for (i = j = 0, len = arr.length; j < len; i = ++j) {
    a = arr[i];
    if (CUI.isFunction(compFunc)) {
      if (compFunc(a, value)) {
        idx = i;
        break;
      }
    } else if (a[compFunc](value)) {
      idx = i;
      break;
    }
  }
  return idx;
};

findInArray = function(value, arr, compFunc) {
  var idx;
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    return void 0;
  } else {
    return arr[idx];
  }
};

addToArray = function(value, arr, compFunc) {
  var idx;
  assert(CUI.isArray(arr), "addToArray", "Second parameter needs to be an Array", {
    value: value,
    array: arr,
    compFunc: compFunc
  });
  idx = idxInArray(value, arr, compFunc);
  if (idx === -1) {
    arr.push(value);
    return arr.length - 1;
  } else {
    return idx;
  }
};

String.prototype.startsWith = function(s) {
  return this.substr(0, s.length) === s;
};

String.prototype.endsWith = function(s) {
  return this.substr(this.length - s.length) === s;
};

Date.prototype.getWeek = function(us) {
  var current_ms, d, day_offset, days_week_in_next_year, first_day, first_day_of_week_ms, next_year_jan_1st, start_day, start_on_jan_1st, week_no, week_offset;
  if (us == null) {
    us = false;
  }
  if (us) {
    start_day = 0;
    start_on_jan_1st = true;
    days_week_in_next_year = 6;
  } else {
    start_day = 1;
    start_on_jan_1st = false;
    days_week_in_next_year = 3;
  }
  day_offset = 24 * 60 * 60 * 1000;
  week_offset = day_offset * 7;
  d = new Date(this);
  d.setUTCHours(0, 0, 0, 0);
  current_ms = d.getTime();
  next_year_jan_1st = new Date(d);
  next_year_jan_1st.setUTCFullYear(d.getUTCFullYear() + 1, 0, 1);
  d.setUTCMonth(0, 1);
  first_day = d.getUTCDay();
  first_day_of_week_ms = d.getTime() - ((first_day - start_day + 7) % 7) * day_offset;
  if ((first_day === 5 || first_day === 6 || first_day === 0) && !start_on_jan_1st) {
    first_day_of_week_ms += week_offset;
  }
  d.setTime(first_day_of_week_ms);
  if ((next_year_jan_1st.getTime() - current_ms) / day_offset <= days_week_in_next_year) {
    week_no = 1;
  } else {
    week_no = Math.floor((current_ms - first_day_of_week_ms) / week_offset) + 1;
  }
  return week_no;
};

getMs = function() {
  return (new Date()).getTime();
};

RegExp.escape = function(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
};
// Generated by CoffeeScript 1.9.3
var CUI;

CUI = (function() {
  function CUI() {}

  CUI.__readyFuncs = [];

  CUI.__themes = [];

  CUI.start = function() {
    var trigger_viewport_resize;
    this.CSS = new CUI.CSSLoader();
    this.getPathToScript();
    trigger_viewport_resize = (function(_this) {
      return function() {
        CUI.info("CUI: trigger viewport resize.");
        return Events.trigger({
          type: "viewport-resize"
        });
      };
    })(this);
    Events.listen({
      type: "resize",
      node: window,
      call: (function(_this) {
        return function(ev, info) {
          CUI.info("CUI: caught window resize event.");
          CUI.scheduleCallback({
            ms: 500,
            call: trigger_viewport_resize
          });
        };
      })(this)
    });
    Events.listen({
      type: "drop",
      node: document.documentElement,
      call: function(ev) {
        return ev.preventDefault();
      }
    });
    Events.listen({
      type: "keyup",
      node: window,
      capture: true,
      call: function(ev) {
        if (ev.getKeyboard() === "C+U+I") {
          return CUI.toaster({
            text: "CUI!"
          });
        }
      }
    });
    Events.listen({
      type: "keydown",
      node: window,
      call: function(ev) {
        var ref;
        if (ev.getKeyboard() === "c+") {
          CUI.toaster({
            text: "CUI!"
          });
        }
        if (ev.keyCode() === 8) {
          if ((ref = ev.getTarget().tagName) === "INPUT" || ref === "TEXTAREA") {
            return;
          } else {
            ev.preventDefault();
          }
        }
      }
    });
    document.body.scrollTop = 0;
    Template.load();
    if (!Template.nodeByName["cui-base"]) {
      CUI.Template.loadFile("easydbui.html").done((function(_this) {
        return function() {
          return _this.ready();
        };
      })(this));
    } else {
      this.ready();
    }
    return this;
  };

  CUI.getPathToScript = function() {
    var idx, j, len1, m, ref, s;
    if (!this.pathToScript) {
      ref = DOM.matchSelector(document.documentElement, "script");
      for (idx = j = 0, len1 = ref.length; j < len1; idx = ++j) {
        s = ref[idx];
        if (m = s.src.match("(.*)/easydbui.js")) {
          this.pathToScript = m[1];
          this.script = s;
          break;
        }
      }
      assert(this.pathToScript, "easydbui", "Could not determine script path.");
    }
    return this.pathToScript;
  };

  CUI.ready = function(func) {
    var j, len1, ref, results1;
    if (func instanceof Function) {
      if (this.__ready) {
        return func.call(this);
      } else {
        return this.__readyFuncs.push(func);
      }
    } else {
      this.__ready = true;
      ref = this.__readyFuncs;
      results1 = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        func = ref[j];
        results1.push(func.call(this));
      }
      return results1;
    }
  };

  CUI.defaults = {
    FileUpload: {
      name: "files[]"
    },
    debug: true,
    asserts: true,
    "class": {}
  };

  CUI.resolvedPromise = function() {
    var dfr;
    dfr = new CUI.Deferred();
    dfr.resolve.apply(dfr, arguments);
    return dfr.promise();
  };

  CUI.rejectedPromise = function() {
    var dfr;
    dfr = new CUI.Deferred();
    dfr.reject.apply(dfr, arguments);
    return dfr.promise();
  };

  CUI.chainedCall = function() {
    var __this, args, dfr, get_args, get_return_value, idx, init_next, return_values;
    idx = 0;
    __this = this;
    get_args = function(_arguments) {
      var _args, arg, j, len1;
      _args = [];
      for (j = 0, len1 = _arguments.length; j < len1; j++) {
        arg = _arguments[j];
        _args.push(arg);
      }
      return _args;
    };
    get_return_value = function(_arguments) {
      var _args;
      _args = get_args(_arguments);
      if (_args.length === 0) {
        return void 0;
      } else if (_args.length === 1) {
        return _args[0];
      } else {
        return _args;
      }
    };
    args = get_args(arguments);
    return_values = [];
    init_next = (function(_this) {
      return function() {
        var ret;
        if (idx === args.length) {
          dfr.resolve.apply(dfr, return_values);
          return;
        }
        if (CUI.isFunction(args[idx])) {
          if (__this !== CUI) {
            ret = args[idx].call(__this);
          } else {
            ret = args[idx]();
          }
        } else {
          ret = args[idx];
        }
        idx++;
        if (isPromise(ret)) {
          ret.done(function() {
            return_values.push(get_return_value(arguments));
            return init_next();
          }).fail(function() {
            return_values.push(get_return_value(arguments));
            return dfr.reject.apply(dfr, return_values);
          });
        } else {
          return_values.push(ret);
          init_next();
        }
      };
    })(this);
    dfr = new CUI.Deferred();
    init_next();
    return dfr.promise();
  };

  CUI.chunkWork = function(objects, chunkSize, timeout) {
    var dfr, do_next_chunk, idx;
    if (chunkSize == null) {
      chunkSize = 10;
    }
    if (timeout == null) {
      timeout = 0;
    }
    dfr = new CUI.Deferred();
    idx = 0;
    do_next_chunk = (function(_this) {
      return function() {
        var chunk;
        chunk = 0;
        while (idx < objects.length && (chunk < chunkSize || chunkSize === 0)) {
          if (dfr.state() === "rejected") {
            return;
          }
          dfr.notify(objects[idx], idx);
          if (idx === objects.length - 1) {
            dfr.resolve();
            return;
          }
          idx++;
          chunk++;
        }
        if (idx < objects.length) {
          return CUI.setTimeout(do_next_chunk, timeout);
        }
      };
    })(this);
    if (objects.length === 0) {
      CUI.setTimeout((function(_this) {
        return function() {
          if (dfr.state() === "rejected") {
            return;
          }
          return dfr.resolve();
        };
      })(this));
    } else {
      CUI.setTimeout(do_next_chunk);
    }
    return dfr;
  };

  CUI.proxyMethods = function(target, source, methods) {
    var j, k, len1, results1;
    results1 = [];
    for (j = 0, len1 = methods.length; j < len1; j++) {
      k = methods[j];
      results1.push(target.prototype[k] = source.prototype[k]);
    }
    return results1;
  };

  CUI.__timeouts = [];

  CUI.__timeoutCallbacks = [];

  CUI.__callTimeoutChangeCallbacks = function() {
    var cb, j, len1, ref, tracked;
    tracked = this.countTimeouts();
    ref = this.__timeoutCallbacks;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      cb = ref[j];
      cb(tracked);
    }
  };

  CUI.__removeTimeout = function(timeout) {
    if (removeFromArray(timeout, this.__timeouts)) {
      if (timeout.track) {
        this.__callTimeoutChangeCallbacks();
      }
    }
  };

  CUI.__getTimeoutById = function(timeoutID, ignoreNotFound) {
    var j, len1, ref, timeout;
    if (ignoreNotFound == null) {
      ignoreNotFound = false;
    }
    ref = this.__timeouts;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      timeout = ref[j];
      if (timeout.id === timeoutID) {
        return timeout;
      }
    }
    assert(ignoreNotFound, "CUI.__getTimeoutById", "Timeout #" + timeoutID + " not found.");
    return null;
  };

  CUI.resetTimeout = function(timeoutID) {
    var old_real_id, tid, timeout;
    timeout = this.__getTimeoutById(timeoutID);
    assert(!timeout.__isRunning, "CUI.resetTimeout", "Timeout " + timeoutID + " cannot be resetted while running.", {
      timeout: timeout
    });
    if (typeof timeout.onReset === "function") {
      timeout.onReset(timeout);
    }
    window.clearTimeout(timeout.real_id);
    old_real_id = timeout.real_id;
    tid = this.__startTimeout(timeout);
    return tid;
  };

  CUI.registerTimeoutChangeCallback = function(cb) {
    return this.__timeoutCallbacks.push(cb);
  };

  CUI.setTimeout = function(_func, ms, track) {
    var func, onDone, onReset, timeout;
    if (ms == null) {
      ms = 0;
    }
    if (CUI.isPlainObject(_func)) {
      ms = _func.ms || 0;
      track = _func.track;
      func = _func.call;
      onDone = _func.onDone;
      onReset = _func.onReset;
    } else {
      func = _func;
    }
    if (isNull(track)) {
      if (ms === 0) {
        track = false;
      } else {
        track = true;
      }
    }
    assert(CUI.isFunction(func), "CUI.setTimeout", "Function needs to be a Function (opts.call)", {
      parameter: _func
    });
    timeout = {
      call: (function(_this) {
        return function() {
          timeout.__isRunning = true;
          func();
          _this.__removeTimeout(timeout);
          return typeof timeout.onDone === "function" ? timeout.onDone(timeout) : void 0;
        };
      })(this),
      ms: ms,
      func: func,
      track: track,
      onDone: onDone,
      onReset: onReset
    };
    this.__timeouts.push(timeout);
    if (track && ms > 0) {
      this.__callTimeoutChangeCallbacks();
    }
    return this.__startTimeout(timeout);
  };

  CUI.__scheduledCallbacks = [];

  CUI.scheduleCallback = function(_opts) {
    var cb, dfr, idx, opts, timeoutID;
    opts = CUI.Element.readOpts(_opts, "CUI.scheduleCallback", {
      call: {
        mandatory: true,
        check: Function
      },
      ms: {
        "default": 0,
        check: function(v) {
          return isInteger(v) && v >= 0;
        }
      },
      track: {
        "default": false,
        check: Boolean
      }
    });
    idx = idxInArray(opts.call, this.__scheduledCallbacks, function(v) {
      return v.call === opts.call;
    });
    if (idx > -1 && CUI.isTimeoutRunning(this.__scheduledCallbacks[idx].timeoutID)) {
      idx = -1;
    }
    if (idx === -1) {
      idx = this.__scheduledCallbacks.length;
    } else {
      CUI.resetTimeout(this.__scheduledCallbacks[idx].timeoutID);
      return this.__scheduledCallbacks[idx].promise;
    }
    dfr = new CUI.Deferred();
    timeoutID = CUI.setTimeout({
      ms: opts.ms,
      track: opts.track,
      call: (function(_this) {
        return function() {
          opts.call();
          return dfr.resolve();
        };
      })(this)
    });
    cb = this.__scheduledCallbacks[idx] = {
      call: opts.call,
      timeoutID: timeoutID,
      promise: dfr.promise()
    };
    dfr.done((function(_this) {
      return function() {
        return removeFromArray(opts.call, _this.__scheduledCallbacks, function(v) {
          return v.call === opts.call;
        });
      };
    })(this));
    return cb.promise;
  };

  CUI.scheduleCallbackCancel = function(_opts) {
    var idx, opts;
    opts = CUI.Element.readOpts(_opts, "CUI.scheduleCallbackCancel", {
      call: {
        mandatory: true,
        check: Function
      }
    });
    idx = idxInArray(opts.call, this.__scheduledCallbacks, function(v) {
      return v.call === opts.call;
    });
    if (idx > -1 && !CUI.isTimeoutRunning(this.__scheduledCallbacks[idx].timeoutID)) {
      console.error("cancel timeout...", this.__scheduledCallbacks[idx].timeoutID);
      CUI.clearTimeout(this.__scheduledCallbacks[idx].timeoutID);
      this.__scheduledCallbacks.splice(idx, 1);
      return true;
    } else {
      return false;
    }
  };

  CUI.utf8ArrayBufferToString = function(arrayBuffer) {
    var array, c, char2, char3, i, len, out;
    out = [];
    array = new Uint8Array(arrayBuffer);
    len = array.length;
    i = 0;
    while (i < len) {
      c = array[i++];
      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out.push(String.fromCharCode(c));
          break;
        case 12:
        case 13:
          char2 = array[i++];
          out.push(String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F)));
          break;
        case 14:
          char2 = array[i++];
          char3 = array[i++];
          out.push(String.fromCharCode(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
      }
    }
    return out.join("");
  };

  CUI.__startTimeout = function(timeout) {
    var real_id;
    real_id = window.setTimeout(timeout.call, timeout.ms);
    if (!timeout.id) {
      timeout.id = real_id;
    }
    timeout.real_id = real_id;
    return timeout.id;
  };

  CUI.countTimeouts = function() {
    var j, len1, ref, timeout, tracked;
    tracked = 0;
    ref = this.__timeouts;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      timeout = ref[j];
      if (timeout.track) {
        tracked++;
      }
    }
    return tracked;
  };

  CUI.clearTimeout = function(timeoutID) {
    var timeout;
    timeout = this.__getTimeoutById(timeoutID, true);
    if (!timeout) {
      return;
    }
    window.clearTimeout(timeout.real_id);
    this.__removeTimeout(timeout);
    return timeout.id;
  };

  CUI.isTimeoutRunning = function(timeoutID) {
    var timeout;
    timeout = this.__getTimeoutById(timeoutID, true);
    if (!(timeout != null ? timeout.__isRunning : void 0)) {
      return false;
    } else {
      return true;
    }
  };

  CUI.setInterval = function(func, ms) {
    return window.setInterval(func, ms);
  };

  CUI.clearInterval = function(interval) {
    return window.clearInterval(interval);
  };

  CUI.startWebdriverTest = function() {
    var a;
    a = $("body");
    return a.addClass("cui-webdriver-test");
  };

  CUI.mergeMap = function(targetMap, mergeMap) {
    var k, v;
    for (k in mergeMap) {
      v = mergeMap[k];
      if (!targetMap.hasOwnProperty(k)) {
        targetMap[k] = v;
      } else if (CUI.isPlainObject(targetMap[k]) && CUI.isPlainObject(v)) {
        CUI.mergeMap(targetMap[k], v);
      }
    }
    return targetMap;
  };

  CUI.getParameterByName = function(name, search) {
    var regex, results;
    if (search == null) {
      search = document.location.search;
    }
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
    results = regex.exec(search);
    if (results === null) {
      return "";
    } else {
      return decodeURIComponent(results[1].replace(/\+/g, " "));
    }
  };

  CUI.encodeUrlData = function(params, replacer, connect, connect_pair) {
    var _v, encode_func, j, k, len1, url, v;
    if (replacer == null) {
      replacer = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    url = [];
    if (replacer) {
      if (CUI.isFunction(replacer)) {
        encode_func = replacer;
      } else {
        encode_func = function(v) {
          return CUI.stringMapReplace(v + "", replace_map);
        };
      }
    } else {
      encode_func = function(v) {
        return encodeURIComponent(v);
      };
    }
    for (k in params) {
      v = params[k];
      if (CUI.isArray(v)) {
        for (j = 0, len1 = v.length; j < len1; j++) {
          _v = v[j];
          url.push(encode_func(k) + connect_pair + encode_func(_v));
        }
      } else {
        url.push(encode_func(k) + connect_pair + encode_func(v));
      }
    }
    return url.join(connect);
  };

  CUI.encodeURIComponentNicely = function(str) {
    var j, len1, ref, s, v;
    if (str == null) {
      str = "";
    }
    s = [];
    ref = (str + "").split("");
    for (j = 0, len1 = ref.length; j < len1; j++) {
      v = ref[j];
      if (v === "," || v === ":") {
        s.push(v);
      } else {
        s.push(encodeURIComponent(v));
      }
    }
    return s.join("");
  };

  CUI.decodeURIComponentNicely = function(v) {
    return decodeURIComponent(v);
  };

  CUI.decodeUrlData = function(url, replacer, connect, connect_pair, use_array) {
    var decode_func, j, key, len1, pair, params, part, ref, value;
    if (replacer == null) {
      replacer = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    if (use_array == null) {
      use_array = false;
    }
    params = {};
    if (replacer) {
      if (CUI.isFunction(replacer)) {
        decode_func = replacer;
      } else {
        decode_func = function(v) {
          return CUI.stringMapReplace(v + "", replacer);
        };
      }
    } else {
      decode_func = function(v) {
        return decodeURIComponent(v);
      };
    }
    ref = url.split(connect);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      part = ref[j];
      pair = part.split(connect_pair);
      key = decode_func(pair[0]);
      value = decode_func(pair[1]);
      if (use_array) {
        if (!params[key]) {
          params[key] = [];
        }
        params[key].push(value);
      } else {
        params[key] = value;
      }
    }
    return params;
  };

  CUI.decodeUrlDataArray = function(url, replace_map, connect, connect_pair) {
    if (replace_map == null) {
      replace_map = null;
    }
    if (connect == null) {
      connect = "&";
    }
    if (connect_pair == null) {
      connect_pair = "=";
    }
    return this.decodeUrlData(url, replace_map, connect, connect_pair, true);
  };

  CUI.revertMap = function(map) {
    var k, map_reverted, v;
    map_reverted = {};
    for (k in map) {
      v = map[k];
      map_reverted[v] = k;
    }
    return map_reverted;
  };

  CUI.stringMapReplace = function(s, map) {
    var key, regex;
    regex = [];
    for (key in map) {
      if (isEmpty(key)) {
        continue;
      }
      regex.push(key.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"));
    }
    return s.replace(new RegExp(regex.join('|'), "g"), function(word) {
      return map[word];
    });
  };

  CUI.isFunction = function(v) {
    return v && typeof v === "function";
  };

  CUI.isPlainObject = function(v) {
    var ref;
    return v && typeof v === "object" && ((ref = v.constructor) != null ? ref.prototype.hasOwnProperty("isPrototypeOf") : void 0);
  };

  CUI.isEmptyObject = function(v) {
    var k;
    for (k in v) {
      return false;
    }
    return true;
  };

  CUI.isMap = function(v) {
    return this.isPlainObject(v);
  };

  CUI.isArray = function(v) {
    return Array.isArray(v);
  };

  CUI.isString = function(s) {
    return typeof s === "string";
  };

  CUI.downloadData = function(data, fileName) {
    var blob, json, url;
    json = JSON.stringify(data);
    blob = new Blob([json], {
      type: "octet/stream"
    });
    url = window.URL.createObjectURL(blob);
    this.__downloadDataElement.href = url;
    this.__downloadDataElement.download = fileName;
    this.__downloadDataElement.click();
    return window.URL.revokeObjectURL(url);
  };

  CUI.urlRegex = new RegExp("^" + "(?:(?:(https?))://|)" + "(?:(\\S+?)(?::(\\S*))?@)?" + "((?:(?:" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(?:[a-z\\u00a1-\\uffff0-9-*][a-z\\u00a1-\\uffff0-9-]*\\.)*" + "(?:[a-z\\u00a1-\\uffff]{2,})" + "))|)" + "(?::(\\d{2,5}))?" + "(?:([/?#]\\S*))?" + "$", "i");

  CUI.evalCode = function(code) {
    var script;
    script = document.createElement("script");
    script.text = code;
    return document.head.appendChild(script).parentNode.removeChild(script);
  };

  CUI.appendToUrl = function(url, data) {
    var key, value;
    for (key in data) {
      value = data[key];
      if (value === void 0) {
        continue;
      }
      if (url.match(/\?/)) {
        url += "&";
      } else {
        url += "?";
      }
      url += encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }
    return url;
  };

  CUI.parseLocation = function(url) {
    var _match, match, p;
    if (!CUI.isFunction(url != null ? url.match : void 0) || url.length === 0) {
      return null;
    }
    match = url.match(this.urlRegex);
    if (!match) {
      return null;
    }
    p = {
      protocol: match[1] || "",
      user: match[2] || "",
      password: match[3] || "",
      hostname: match[4] || "",
      port: match[5] || "",
      path: match[6] || "",
      origin: ""
    };
    if (p.hostname) {
      if (!p.protocol) {
        p.protocol = "http";
      }
      p.origin = p.protocol + "://" + p.hostname;
      if (p.port) {
        p.origin += ":" + p.port;
      }
      p.url = p.protocol + "://";
      if (p.user) {
        p.url = p.url + p.user + ":" + p.password + "@";
      }
      p.url = p.url + p.hostname;
      if (p.port) {
        p.url = p.url + ":" + p.port;
      }
    } else {
      p.url = "";
    }
    if (p.path.length > 0) {
      _match = p.path.match(/(.*?)(|\?.*?)(|\#.*)$/);
      p.pathname = _match[1];
      p.search = _match[2];
      if (p.search === "?") {
        p.search = "";
      }
      p.fragment = _match[3];
    } else {
      p.search = "";
      p.pathname = "";
      p.fragment = "";
    }
    p.href = p.origin + p.path;
    p.hash = p.fragment;
    if (p.login) {
      p.auth = btoa(p.user + ":" + p.password);
    }
    p.url = p.url + p.path;
    return p;
  };

  CUI.initNodeDebugCopy = function() {
    return Events.listen({
      type: "keyup",
      capture: true,
      call: (function(_this) {
        return function(ev) {
          var el, i, j, l, len1, len2, node, node_copy, ref, ref1;
          if (ev.getKeyboard() !== "Alt+C") {
            return;
          }
          if (ev.shiftKey()) {
            i = 0;
            ref = DOM.matchSelector(document.documentElement, ".cui-debug-node-copy");
            for (j = 0, len1 = ref.length; j < len1; j++) {
              el = ref[j];
              el.remove();
              i++;
            }
            CUI.toaster({
              text: i + " Node(s) removed."
            });
            return;
          }
          i = 0;
          ref1 = CUI.DOM.matchSelector(document.documentElement, ".cui-debug-node-copyable");
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            node = ref1[l];
            node_copy = node.cloneNode(true);
            node.parentNode.appendChild(node_copy);
            CUI.DOM.insertAfter(node, node_copy);
            node_copy.classList.add("cui-demo-node-copy");
            console.debug("Node copied. Original:", node.parentNode, node, "Copy:", node_copy);
            i++;
          }
          CUI.toaster({
            text: i + " Node(s) copied."
          });
        };
      })(this)
    });
  };

  CUI.setDebug = function() {
    return document.body.classList.add("cui-debug");
  };

  CUI.error = function() {
    return console.error.apply(console, arguments);
  };

  CUI.debug = function() {
    return console.debug.apply(console, arguments);
  };

  CUI.info = function() {
    return console.info.apply(console, arguments);
  };

  CUI.warn = function() {
    return console.warn.apply(console, arguments);
  };

  return CUI;

})();

CUI.browser = {
  opera: (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0,
  firefox: typeof InstallTrigger !== 'undefined',
  safari: Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
  ie: /*@cc_on!@*/false || !!document.documentMode,
  chrome: !!window.chrome && !!window.chrome.webstore
};

CUI.browser.edge = !CUI.browser.isIE && !!window.StyleMedia;

CUI.browser.blink = (CUI.browser.chrome || CUI.browser.opera) && !!window.CSS;

CUI.ready((function(_this) {
  return function() {
    var fn, i, j, nodes;
    fn = function(i) {
      CUI["$" + i] = function() {
        var arg, idx, l, len1, results1;
        if (arguments.length === 1) {
          window["$" + i] = arguments[0];
          console.debug("$" + i + " = ", arguments[0]);
          return;
        }
        results1 = [];
        for (idx = l = 0, len1 = arguments.length; l < len1; idx = ++l) {
          arg = arguments[idx];
          window["$" + i + idx] = arg;
          results1.push(console.debug("$" + i + idx + " = ", arg));
        }
        return results1;
      };
    };
    for (i = j = 1; j <= 9; i = ++j) {
      fn(i);
    }
    if (typeof marked !== "undefined" && marked !== null) {
      marked.setOptions({
        renderer: new marked.Renderer(),
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: true,
        smartLists: true,
        smartypants: false
      });
    }
    nodes = CUI.DOM.htmlToNodes("<!-- CUI.CUI --><a style='display: none;'></a><!-- /CUI.CUI -->");
    CUI.__downloadDataElement = nodes[1];
    return CUI.DOM.append(document.body, nodes);
  };
})(this));

window.addEventListener("load", (function(_this) {
  return function() {
    return CUI.start();
  };
})(this));
// Generated by CoffeeScript 1.9.3
var $, $a, $audio, $b, $div, $element, $h1, $h2, $h3, $h4, $h5, $h6, $i, $img, $label, $li, $p, $pre, $source, $span, $table, $table_one_row, $td, $text, $textEmpty, $th, $tr, $tr_one_row, $ul, $video, jQuery,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.defaults.jQueryCompat = 1;

CUI.jQueryCompat = (function() {
  function jQueryCompat(input) {
    var fn, item, j, k, key, len, len1, nodes, ref;
    if (!input) {
      return CUI.jQueryCompat.__noopNode();
    }
    if (input instanceof Array || input instanceof NodeList || input instanceof HTMLCollection) {
      nodes = [];
      for (j = 0, len = input.length; j < len; j++) {
        item = input[j];
        assert(item instanceof HTMLElement, "jQueryCompat", "Wenn called with Array, only HTMLElements are supported.", {
          item: item,
          input: input
        });
        nodes.push(CUI.jQueryCompat(item));
      }
      nodes.last = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("last", nodes);
          if (nodes.length === 0) {
            return CUI.jQueryCompat.__noopNode();
          }
          return nodes[nodes.length - 1];
        };
      })(this);
      nodes.first = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("first", nodes);
          if (nodes.length === 0) {
            return CUI.jQueryCompat.__noopNode();
          }
          return nodes[0];
        };
      })(this);
      ref = CUI.jQueryCompat.__noopKeys;
      fn = (function(_this) {
        return function(key) {
          if (key === "css" || key === "hide" || key === "show" || key === "remove" || key === "pf_hide" || key === "pf_show" || key === "scrollIntoView" || key === "addClass" || key === "removeClass" || key === "removeAttr" || key === "detach") {
            nodes[key] = function() {
              var l, len2, node;
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                node[key].apply(node, arguments);
              }
              return nodes;
            };
            return;
          }
          if (key === "attr") {
            nodes[key] = function(prop, value) {
              var l, len2, node, ref1;
              if (value !== void 0) {
                for (l = 0, len2 = nodes.length; l < len2; l++) {
                  node = nodes[l];
                  node[key].apply(node, arguments);
                }
                return nodes;
              } else {
                return (ref1 = nodes[0]) != null ? ref1.attr.apply(nodes[0], arguments) : void 0;
              }
            };
            return;
          }
          if (key === "hasClass") {
            nodes[key] = function() {
              var has_class, l, len2, node;
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                has_class = node[key].apply(node, arguments);
                if (has_class) {
                  return true;
                }
              }
              return false;
            };
            return;
          }
          if (key === "find") {
            nodes[key] = function() {
              var found_nodes, l, len2, node;
              if (nodes.length === 0) {
                return nodes;
              }
              found_nodes = [];
              for (l = 0, len2 = nodes.length; l < len2; l++) {
                node = nodes[l];
                found_nodes.push.apply(found_nodes, node.find.apply(node, arguments));
              }
              return found_nodes;
            };
            return;
          }
          return nodes[key] = function() {
            return console.error("Unsupported Function on jQuery Compat Array:", key);
          };
        };
      })(this);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        key = ref[k];
        if (key === "0" || key === "last" || key === "first") {
          continue;
        }
        fn(key);
      }
      return nodes;
    }
    if (isString(input)) {
      nodes = CUI.DOM.matchSelector(document.documentElement, input);
      if (nodes.length === 0) {
        return CUI.jQueryCompat.__noopNode();
      } else if (nodes.length === 1) {
        return CUI.jQueryCompat(nodes[0]);
      } else {
        return CUI.jQueryCompat(nodes);
      }
    }
    return CUI.jQueryCompat.__wrapNode(input);
  }

  jQueryCompat.__warn = function() {
    var args, error_args, prop;
    prop = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!CUI.defaults.jQueryCompat || CUI.defaults.jQueryCompat === 1) {
      return;
    }
    error_args = ["jQueryCompat: " + prop];
    if (CUI.defaults.jQueryCompat >= 4) {
      error_args.push.apply(error_args, args);
    }
    if (CUI.defaults.jQueryCompat === 2) {
      return console.warn.apply(console.warn, error_args);
    } else {
      return console.error.apply(console.error, error_args);
    }
  };

  jQueryCompat.__funcWraps = {};

  jQueryCompat.__noopKeys = ["css", "text", "textContent", "closest", "outerHeight", "outerWidth", "rect", "offset", "cssInt", "cssFloat", "cssEdgeSpace", "hide", "show", "html", "val", "replaceWidth", "scrollIntoView", "empty", "append", "prepend", "appendTo", "remove", "parents", "removeAttr", "removeClass", "addClass", "hasClass", "is", "find", "before", "after", "attr", "last", "first", "relativePosition", "prop", "detach"];

  jQueryCompat.__noopNode = function() {
    var j, key, len, node, ref;
    node = CUI.DOM.element("DIV");
    Object.defineProperty(node, "0", {
      enumerable: true,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("[0]", node);
          return node;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[0] unable to set value.");
        };
      })(this)
    });
    node.length = 0;
    ref = this.__noopKeys;
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      if (key === "find") {
        node[key] = (function(_this) {
          return function() {
            _this.__warn(key, "Noop node.");
            return [];
          };
        })(this);
      }
      node[key] = (function(_this) {
        return function() {
          _this.__warn(key, "Noop node.");
        };
      })(this);
    }
    return node;
  };

  jQueryCompat.__wrapNode = function(node) {
    var ref, ref1, ref2;
    assert(node instanceof HTMLElement, "jQueryCompat", "Node needs to be instance of HTMLElement.", {
      node: node
    });
    if (!CUI.defaults.jQueryCompat) {
      return;
    }
    if (node.__jQueryCompatNode__) {
      return node;
    }
    node.__jQueryCompatNode__ = true;
    Object.defineProperty(node, "length", {
      enumerable: false,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn(".length", node);
          if (CUI.defaults.jQueryCompat > 1) {
            console.error("jQueryCompat: .length accessed on node. Returning 1.", node);
          }
          return 1;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[length] unable to set value.");
        };
      })(this)
    });
    Object.defineProperty(node, "0", {
      enumerable: true,
      get: (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("[0]", node);
          return node;
        };
      })(this),
      set: (function(_this) {
        return function() {
          throw new TypeError("jQueryCompat[0] unable to set value.");
        };
      })(this)
    });
    node.css = (function(_this) {
      return function(style, value) {
        CUI.jQueryCompat.__warn("css", node, style);
        if (CUI.isPlainObject(style)) {
          return CUI.DOM.setStyle(node, style);
        } else if (value === void 0) {
          return CUI.DOM.getComputedStyle(node)[style];
        } else {
          return CUI.DOM.setStyleOne(node, style, value);
        }
      };
    })(this);
    if ((ref = node.nodeName) !== "BODY" && ref !== "A") {
      node.text = (function(_this) {
        return function(value) {
          CUI.jQueryCompat.__warn("text", node);
          if (isEmpty(value)) {
            return node.textContent;
          }
          node.textContent = value;
          return node;
        };
      })(this);
    }
    if (!node.remove) {
      node.remove = (function(_this) {
        return function() {
          CUI.jQueryCompat.__warn("remove", node);
          return CUI.DOM.remove(node);
        };
      })(this);
    }
    node.parent = (function(_this) {
      return function() {
        var parent;
        CUI.jQueryCompat.__warn("parent", node);
        parent = node.parentNode;
        if (!parent) {
          return CUI.jQueryCompat.__noopNode();
        }
        return CUI.jQueryCompat(parent);
      };
    })(this);
    node.last = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("last", node);
        return node;
      };
    })(this);
    node.first = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("first", node);
        return node;
      };
    })(this);
    node.closest = (function(_this) {
      return function(selector) {
        return CUI.jQueryCompat(CUI.DOM.closest(node, selector));
      };
    })(this);
    node.outerHeight = (function(_this) {
      return function(includeMargin) {
        if (includeMargin == null) {
          includeMargin = false;
        }
        if (includeMargin) {
          return CUI.DOM.getDimensions(node).marginBoxHeight;
        } else {
          return CUI.DOM.getDimensions(node).borderBoxHeight;
        }
      };
    })(this);
    node.outerWidth = (function(_this) {
      return function(includeMargin) {
        if (includeMargin == null) {
          includeMargin = false;
        }
        if (includeMargin) {
          return CUI.DOM.getDimensions(node).marginBoxWidth;
        } else {
          return CUI.DOM.getDimensions(node).borderBoxWidth;
        }
      };
    })(this);
    node.rect = (function(_this) {
      return function() {
        CUI.jQueryCompat.__warn("rect", node);
        return CUI.DOM.getRect(node);
      };
    })(this);
    node.offset = (function(_this) {
      return function() {
        var rect;
        CUI.jQueryCompat.__warn("offset", node);
        rect = CUI.DOM.getRect(node);
        return {
          top: rect.top,
          left: rect.left
        };
      };
    })(this);
    node.cssInt = (function(_this) {
      return function(prop, check) {
        var i, s;
        if (check == null) {
          check = true;
        }
        CUI.jQueryCompat.__warn("cssInt", node);
        s = CUI.DOM.getComputedStyle(node)[prop];
        if (s === void 0 || s === "") {
          return 0;
        }
        assert(!check || s.match(/px$/), "cssInt", "css(\"" + prop + "\") did not return \"px\" but \"" + s + "\".");
        i = parseInt(s);
        if (isNaN(i)) {
          return 0;
        } else {
          return i;
        }
      };
    })(this);
    node.cssFloat = (function(_this) {
      return function(prop, check) {
        var i, s;
        if (check == null) {
          check = true;
        }
        CUI.jQueryCompat.__warn("cssFloat", node);
        s = CUI.DOM.getComputedStyle(node)[prop];
        if (s === void 0 || s === "") {
          return 0;
        }
        assert(!check || s.match(/px$/), "cssFloat", "css(\"" + prop + "\") did not return \"px\" but \"" + s + "\".");
        i = parseFloat(s);
        if (isNaN(i)) {
          return 0;
        } else {
          return i;
        }
      };
    })(this);
    node.cssEdgeSpace = function(dir, includeMargin) {
      var access, dim, j, key, keys, len, value;
      if (includeMargin == null) {
        includeMargin = false;
      }
      CUI.jQueryCompat.__warn("cssEdgeSpace", node);
      dim = CUI.DOM.getDimensions(node);
      keys = ["border", "padding"];
      if (includeMargin) {
        keys.push("margin");
      }
      value = 0;
      access = toCamel(dir, true);
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        value = value + dim[key + access];
      }
      return value;
    };
    node.hide = function() {
      return CUI.DOM.hideElement(node);
    };
    node.show = function() {
      return CUI.DOM.showElement(node);
    };
    node.html = function(value) {
      CUI.jQueryCompat.__warn("html", node, value);
      if (value === void 0) {
        node.innerHTML;
      } else {
        node.innerHTML = value;
      }
      return node;
    };
    if ((ref1 = node.nodeName) === "INPUT") {
      node.val = function(value) {
        CUI.jQueryCompat.__warn("val", node);
        if (value === void 0) {
          return node.value;
        } else {
          return node.value = value;
        }
      };
    }
    node.replaceWith = function(new_node) {
      CUI.jQueryCompat.__warn("replaceWith", node, new_node);
      return CUI.DOM.replaceWith(node, new_node);
    };
    node.empty = function() {
      CUI.jQueryCompat.__warn("empty", node);
      return CUI.DOM.empty(node);
    };
    node.append = function() {
      var content, more_content;
      content = arguments[0], more_content = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      CUI.jQueryCompat.__warn("append", node, content);
      if (isString(content) && content.trim().startsWith("<") && content.indexOf(">") > -1) {
        console.error("jQueryCompat.append: Unable to append HTML. Use CUI.DOM.htmlToNodes(...). Possible HTML: ", content);
      }
      CUI.DOM.append(node, content);
      if (more_content.length > 0) {
        console.warn("jQueryCompat.append: Multiple parameters are deprecated.", {
          more_content: more_content
        });
        CUI.DOM.append(node, more_content);
      }
      return node;
    };
    node.prepend = function(content) {
      CUI.jQueryCompat.__warn("prepend", node, content);
      return CUI.DOM.prepend(node, content);
    };
    node.appendTo = function(node_appendTo) {
      CUI.jQueryCompat.__warn("appendTo", node, node_appendTo);
      CUI.DOM.append(node_appendTo, node);
      return node;
    };
    node.prependTo = function(node_prependTo) {
      CUI.jQueryCompat.__warn("prependTo", node, node_prependTo);
      CUI.DOM.prepend(node_prependTo, node);
      return node;
    };
    node.parents = function(selector) {
      CUI.jQueryCompat.__warn("parents", node, selector);
      return CUI.jQueryCompat(CUI.DOM.parents(node, selector));
    };
    node.removeAttr = function(attr) {
      return CUI.DOM.removeAttribute(node, attr);
    };
    if ((ref2 = node.nodeName) === "DIV") {
      node.width = function(value) {
        CUI.jQueryCompat.__warn("width", node, value);
        return DOM.width(node, value);
      };
      node.height = function(value) {
        CUI.jQueryCompat.__warn("height", node, value);
        return DOM.height(node, value);
      };
    }
    node.removeClass = function(cls) {
      CUI.jQueryCompat.__warn("removeClass", node);
      return CUI.DOM.removeClass(node, cls);
    };
    node.addClass = function(cls) {
      CUI.jQueryCompat.__warn("addClass", node, cls);
      return CUI.DOM.addClass(node, cls);
    };
    node.hasClass = function(cls) {
      CUI.jQueryCompat.__warn("hasClass", node, cls);
      return CUI.DOM.hasClass(node, cls);
    };
    node.is = function(selector) {
      CUI.jQueryCompat.__warn("is", node, selector);
      return CUI.DOM.is(node, selector);
    };
    node.find = function(selector) {
      CUI.jQueryCompat.__warn("find", node);
      return CUI.jQueryCompat(CUI.DOM.matchSelector(node, selector));
    };
    node.before = function(node_before) {
      return CUI.DOM.insertBefore(node, node_before);
    };
    node.after = function(node_after) {
      return CUI.DOM.insertAfter(node, node_after);
    };
    node.attr = function(prop, value) {
      CUI.jQueryCompat.__warn("attr|prop", node, prop, value);
      if (CUI.isPlainObject(prop)) {
        return CUI.DOM.setAttributeMap(node, prop);
      } else if (value === void 0) {
        return CUI.DOM.getAttribute(node, prop);
      } else {
        return CUI.DOM.setAttribute(node, prop, value);
      }
    };
    node.relativePosition = function() {
      return CUI.DOM.getRelativePosition(node);
    };
    node.prop = node.attr;
    node.pf_hide = function() {
      CUI.jQueryCompat.__warn("pf_hide", node);
      return CUI.DOM.hideElement(node);
    };
    node.pf_show = function() {
      CUI.jQueryCompat.__warn("pf_show", node);
      return CUI.DOM.showElement(node);
    };
    node.detach = function() {
      CUI.jQueryCompat.__warn("detach", node);
      return node.remove();
    };
    return node;
  };

  jQueryCompat.isPlainObject = function(obj) {
    CUI.jQueryCompat.__warn("isPlainObject");
    return CUI.isPlainObject(obj);
  };

  jQueryCompat.isEmptyObject = function(obj) {
    CUI.jQueryCompat.__warn("isEmptyObject");
    return CUI.isEmptyObject(obj);
  };

  jQueryCompat.isFunction = function(obj) {
    CUI.jQueryCompat.__warn("isFunction");
    return CUI.isFunction(obj);
  };

  jQueryCompat.isArray = function(obj) {
    CUI.jQueryCompat.__warn("isArray");
    return CUI.isArray(obj);
  };

  jQueryCompat.inArray = function(value, arr) {
    return arr.indexOf(value);
  };

  jQueryCompat.each = function(obj, callback) {
    var idx, item, j, key, len, value;
    if (CUI.isArray(obj)) {
      for (idx = j = 0, len = obj.length; j < len; idx = ++j) {
        item = obj[idx];
        callback(idx, item);
      }
      return;
    }
    if (CUI.isPlainObject(obj)) {
      for (key in obj) {
        value = obj[key];
        callback(key, value);
      }
      return;
    }
    return assert(false, "jQueryCompat.each: obj needs to be Array or Map.", {
      obj: obj
    });
  };

  return jQueryCompat;

})();

jQuery = (function(superClass) {
  extend(jQuery, superClass);

  function jQuery(input) {
    CUI.jQueryCompat.__warn("jQuery|$", input);
    return jQuery.__super__.constructor.call(this, input);
  }

  return jQuery;

})(CUI.jQueryCompat);

$ = jQuery;

$element = function(tagName, cls, attrs, no_tables) {
  var node;
  if (attrs == null) {
    attrs = {};
  }
  if (no_tables == null) {
    no_tables = false;
  }
  if (!CUI.__ng__) {
    no_tables = false;
  }
  if (!isEmpty(cls)) {
    attrs["class"] = cls;
  }
  if (no_tables) {
    if (isEmpty(cls)) {
      attrs["class"] = "cui-" + tagName;
    } else {
      attrs["class"] = "cui-" + tagName + " " + attrs["class"];
    }
    tagName = "div";
  }
  node = CUI.DOM.element(tagName, attrs);
  return CUI.jQueryCompat.__wrapNode(node);
};

$div = function(cls, attrs) {
  return $element("div", cls, attrs);
};

$video = function(cls, attrs) {
  return $element("video", cls, attrs);
};

$audio = function(cls, attrs) {
  return $element("audio", cls, attrs);
};

$source = function(cls, attrs) {
  return $element("source", cls, attrs);
};

$span = function(cls, attrs) {
  return $element("span", cls, attrs);
};

$table = function(cls, attrs) {
  return $element("table", cls, attrs, true);
};

$img = function(cls, attrs) {
  return $element("img", cls, attrs);
};

$tr = function(cls, attrs) {
  return $element("tr", cls, attrs, true);
};

$th = function(cls, attrs) {
  return $element("th", cls, attrs, true);
};

$td = function(cls, attrs) {
  return $element("td", cls, attrs, true);
};

$i = function(cls, attrs) {
  return $element("i", cls, attrs);
};

$p = function(cls, attrs) {
  return $element("p", cls, attrs);
};

$pre = function(cls, attrs) {
  return $element("pre", cls, attrs);
};

$ul = function(cls, attrs) {
  return $element("ul", cls, attrs);
};

$a = function(cls, attrs) {
  return $element("a", cls, attrs);
};

$b = function(cls, attrs) {
  return $element("b", cls, attrs);
};

$li = function(cls, attrs) {
  return $element("li", cls, attrs);
};

$label = function(cls, attrs) {
  return $element("label", cls, attrs);
};

$h1 = function(cls, attrs) {
  return $element("h1", cls, attrs);
};

$h2 = function(cls, attrs) {
  return $element("h2", cls, attrs);
};

$h3 = function(cls, attrs) {
  return $element("h3", cls, attrs);
};

$h4 = function(cls, attrs) {
  return $element("h4", cls, attrs);
};

$h5 = function(cls, attrs) {
  return $element("h5", cls, attrs);
};

$h6 = function(cls, attrs) {
  return $element("h6", cls, attrs);
};

$text = function(text, cls, attrs) {
  var s;
  s = $span(cls, attrs);
  s.textContent = text;
  return s;
};

$textEmpty = function(text) {
  var s;
  s = $span("italic");
  s.textContent = text;
  return s;
};

$table_one_row = function() {
  return $table().append($tr_one_row.apply(this, arguments));
};

$tr_one_row = function() {
  var _a, a, append, j, k, len, len1, tr;
  tr = $tr();
  append = function(__a) {
    var add_content, td;
    td = $td().appendTo(tr);
    add_content = (function(_this) {
      return function(___a) {
        var a, j, len;
        if (CUI.isArray(___a)) {
          for (j = 0, len = ___a.length; j < len; j++) {
            a = ___a[j];
            add_content(a);
          }
        } else if (___a != null ? ___a.DOM : void 0) {
          td.append(___a.DOM);
        } else if (!isNull(___a)) {
          td.append(___a);
        }
      };
    })(this);
    add_content(__a);
  };
  for (j = 0, len = arguments.length; j < len; j++) {
    a = arguments[j];
    if (CUI.isArray(a)) {
      for (k = 0, len1 = a.length; k < len1; k++) {
        _a = a[k];
        append(_a);
      }
    } else {
      append(a);
    }
  }
  return tr;
};
// Generated by CoffeeScript 1.9.3
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Deferred = (function() {
  function Deferred() {
    this.__state = "pending";
    this.__callbacks = [];
    this.notify = (function(_this) {
      return function() {
        return _this.__notify.apply(_this, arguments);
      };
    })(this);
    this.resolve = (function(_this) {
      return function() {
        return _this.__resolve.apply(_this, arguments);
      };
    })(this);
    this.reject = (function(_this) {
      return function() {
        return _this.__reject.apply(_this, arguments);
      };
    })(this);
    this.__uniqueId = CUI.Deferred.uniqueId++;
    this.__runningCallbacks = null;
    this.__finished_args = null;
  }

  Deferred.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Deferred.prototype.__callback = function(types, args) {
    var cb, idx, ref, ref1;
    this.__runningCallbacks = true;
    idx = 0;
    while (idx < this.__callbacks.length) {
      cb = this.__callbacks[idx];
      if (ref = cb.type, indexOf.call(types, ref) >= 0) {
        cb.func.apply(this, args);
        if ((ref1 = cb.type) === "done" || ref1 === "always" || ref1 === "fail") {
          this.__callbacks.splice(idx, 1);
          continue;
        }
      }
      idx++;
    }
    this.__runningCallbacks = false;
    return this;
  };

  Deferred.prototype.__register = function(type, func) {
    if (this.__state === "rejected" && type === "done") {
      return;
    }
    if (this.__state === "resolved" && type === "fail") {
      return;
    }
    this.__callbacks.push({
      type: type,
      func: func
    });
    if (this.__state !== "pending" && !this.__runningCallbacks) {
      switch (this.__state) {
        case "resolved":
          this.__callback(["done", "always"], this.__finished_args);
          break;
        case "rejected":
          this.__callback(["fail", "always"], this.__finished_args);
      }
    }
    return this;
  };

  Deferred.prototype.done = function(func) {
    this.__register("done", func);
    return this;
  };

  Deferred.prototype.fail = function(func) {
    this.__register("fail", func);
    return this;
  };

  Deferred.prototype.always = function(func) {
    this.__register("always", func);
    return this;
  };

  Deferred.prototype.progress = function(func) {
    this.__register("progress", func);
    return this;
  };

  Deferred.prototype.__notify = function() {
    assert(this.__state === "pending", "CUI.Deferred.notify", "Cannot notify state " + this.__state + ".");
    this.__callback(["progress"], arguments);
    return this;
  };

  Deferred.prototype.__resolve = function() {
    assert(this.__state === "pending", "CUI.Deferred.resolve", "Cannot resolve state " + this.__state + ".");
    this.__finished_args = arguments;
    this.__state = "resolved";
    this.__callback(["done", "always"], arguments);
    return this;
  };

  Deferred.prototype.__reject = function() {
    assert(this.__state === "pending", "CUI.Deferred.reject", "Cannot reject state " + this.__state + ".");
    this.__finished_args = arguments;
    this.__state = "rejected";
    this.__callback(["fail", "always"], arguments);
    return this;
  };

  Deferred.prototype.state = function() {
    return this.__state;
  };

  Deferred.prototype.promise = function() {
    return new CUI.Promise(this);
  };

  Deferred.uniqueId = 0;

  return Deferred;

})();
// Generated by CoffeeScript 1.9.3
CUI.Promise = (function() {
  function Promise(__deferred) {
    this.__deferred = __deferred;
    assert(this.__deferred instanceof CUI.Deferred, "new Promise", "parameter needs to be instanceof CUI.Deferred", {
      parameter: this.__deferred
    });
  }

  Promise.prototype.done = function() {
    this.__deferred.done.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.fail = function() {
    this.__deferred.fail.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.always = function() {
    this.__deferred.always.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.progress = function() {
    this.__deferred.progress.apply(this.__deferred, arguments);
    return this;
  };

  Promise.prototype.state = function() {
    return this.__deferred.state.apply(this.__deferred, arguments);
  };

  Promise.prototype.getUniqueId = function() {
    return this.__deferred.getUniqueId();
  };

  return Promise;

})();
// Generated by CoffeeScript 1.9.3
CUI.when = (function(_this) {
  return function() {
    var _arg, _idx, add_promise, arg, dfr, done_count, done_values, fn, i, idx, j, k, len, len1, len2, promise, promises;
    promises = [];
    add_promise = function(promise, idx) {
      assert(isPromise(promise) || isDeferred(promise), "CUI.when", "arg[" + idx + "] needs to be instanceof CUI.Promise or CUI.Deferred.", {
        arg: promise
      });
      promises.push(promise);
    };
    for (idx = i = 0, len = arguments.length; i < len; idx = ++i) {
      arg = arguments[idx];
      if (arg instanceof Array) {
        for (_idx = j = 0, len1 = arg.length; j < len1; _idx = ++j) {
          _arg = arg[_idx];
          add_promise(_arg, idx + "[" + _idx + "]");
        }
      } else {
        add_promise(arg, idx);
      }
    }
    if (promises.length === 0) {
      return CUI.resolvedPromise();
    }
    dfr = new CUI.Deferred();
    done_values = [];
    done_count = 0;
    fn = function(idx) {
      promise.done(function() {
        var l, len3;
        done_count++;
        switch (arguments.length) {
          case 0:
            done_values[idx] = void 0;
            break;
          case 1:
            done_values[idx] = arguments[0];
            break;
          default:
            done_values[idx] = [];
            for (l = 0, len3 = arguments.length; l < len3; l++) {
              arg = arguments[l];
              done_values[idx].push(arg);
            }
        }
        if (done_count === promises.length) {
          dfr.resolve.apply(dfr, done_values);
        }
      });
      promise.fail(function() {
        if (dfr.state() !== "rejected") {
          dfr.reject.apply(dfr, arguments);
        }
      });
      return promise.progress(function() {
        dfr.notify.apply(dfr, arguments);
      });
    };
    for (idx = k = 0, len2 = promises.length; k < len2; idx = ++k) {
      promise = promises[idx];
      fn(idx);
    }
    return dfr.promise();
  };
})(this);
// Generated by CoffeeScript 1.9.3
CUI.decide = (function(_this) {
  return function(decision) {
    var dfr;
    dfr = new CUI.Deferred();
    if (isPromise(decision)) {
      decision.done(dfr.resolve);
      decision.fail(dfr.reject);
    } else if (decision === false) {
      dfr.reject(false);
    } else {
      dfr.resolve(decision);
    }
    return dfr.promise();
  };
})(this);
// Generated by CoffeeScript 1.9.3
CUI.Dummy = (function() {
  function Dummy() {
    this.__uniqueId = CUI.Dummy.uniqueId++;
    this.__cls = getObjectClass(this);
  }

  Dummy.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Dummy.uniqueId = 0;

  return Dummy;

})();

CUI.Dummy;
// Generated by CoffeeScript 1.9.3
CUI.Element = (function() {
  function Element(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    this.__uniqueId = CUI.Element.uniqueId++;
    this.__cls = getObjectClass(this);
    this.__destroyed = false;
    this.__check_map = {};
    this.__mapped_keys = [];
    this.initOpts();
    if (CUI.Element.__dont_read_opts) {
      return;
    }
    this.readOpts();
    if (!this.__initOptsCalled) {
      CUI.warn("new " + this.__cls + ": CUI.Element::initOpts not called.", {
        opts: this.opts
      });
    }
    if (typeof this._onConstruct === "function") {
      this._onConstruct(this);
    }
    return;
  }

  Element.prototype.getElementClass = function() {
    return this.__cls;
  };

  Element.prototype.debugConstruction = function() {
    return CUI.error("CONSTRUCTION DEBUG STACK " + this.__uniqueId);
  };

  Element.prototype.getUniqueId = function() {
    return this.__uniqueId;
  };

  Element.prototype.getOpts = function() {
    return this.opts;
  };

  Element.prototype.getOpt = function(key) {
    return this.opts[key];
  };

  Element.prototype.hasOpt = function(key) {
    return this.opts.hasOwnProperty(key);
  };

  Element.prototype.getSetOpt = function(key) {
    return this["_" + key];
  };

  Element.prototype.hasSetOpt = function(key) {
    return this.hasOwnProperty("_" + key);
  };

  Element.getOptKeys = function() {
    var element;
    CUI.Element.__dont_read_opt = true;
    element = new this;
    delete CUI.Element.__dont_read_opts;
    return Object.keys(element.getCheckMap());
  };

  Element.prototype.initOpts = function() {
    this.__initOptsCalled = true;
    return this.addOpts({
      debug: {},
      onConstruct: {
        check: Function
      },
      onDestroy: {
        check: Function
      }
    });
  };

  Element.prototype.copy = function() {
    return new window[this.__cls](this.opts);
  };

  Element.prototype.mergeOpt = function(key, check_map) {
    var k, opt, v;
    if (check_map == null) {
      check_map = {};
    }
    opt = this.__check_map[key] || {};
    for (k in check_map) {
      v = check_map[k];
      opt[k] = v;
    }
    return this.addOpt(key, opt, "mergeOpt");
  };

  Element.prototype.removeOpt = function(key) {
    return delete this.__check_map[key];
  };

  Element.prototype.addOpt = function(key, check_map, fn) {
    if (fn == null) {
      fn = "addOpt";
    }
    assert(isString(key), this.__cls + "." + fn, "key needs to be String", {
      key: key,
      check_map: check_map
    });
    if (isNull(check_map)) {
      return;
    }
    assert(CUI.isPlainObject(check_map), this.__cls + "." + fn, "check_map needs to be Map", {
      key: key,
      check_map: check_map
    });
    this.__check_map[key] = check_map;
    return this;
  };

  Element.prototype.addOpts = function(map) {
    var k, v;
    assert(CUI.isPlainObject(map), this.__cls + ".addOpts", "Parameter needs to be Map", {
      map: map
    });
    for (k in map) {
      v = map[k];
      this.addOpt(k, v);
    }
    return this;
  };

  Element.prototype.mergeOpts = function(map) {
    var k, v;
    assert(CUI.isPlainObject(map), this.__cls + ".mergeOpts", "Parameter needs to be Map", {
      map: map
    });
    for (k in map) {
      v = map[k];
      this.mergeOpt(k, v);
    }
    return this;
  };

  Element.prototype.getCheckMap = function() {
    return this.__check_map;
  };

  Element.prototype.readOpts = function(opts, cls, check_map) {
    if (opts == null) {
      opts = this.opts;
    }
    if (cls == null) {
      cls = this.__cls;
    }
    if (check_map == null) {
      check_map = this.__check_map;
    }
    return CUI.Element.readOpts.call(this, opts, cls, check_map, true);
  };

  Element.readOpts = function(opts, cls, check_map, map_values) {
    var _check, check, err, exists, k, mandatory, post, set_opts, v, value;
    if (map_values !== true && map_values !== false) {
      if (this !== Element) {
        assert(this !== window, "CUI.Element.readOpts", "this cannot be window.");
        map_values = true;
      }
    }
    if (!CUI.defaults.asserts) {
      set_opts = {};
      for (k in check_map) {
        v = check_map[k];
        if (opts.hasOwnProperty(k) && opts[k] !== void 0) {
          set_opts[k] = this["_" + k] = opts[k];
          if (map_values) {
            this.__mapped_keys.push(k);
          }
        } else if (v.hasOwnProperty("default")) {
          set_opts[k] = this["_" + k] = v["default"];
          if (map_values) {
            this.__mapped_keys.push(k);
          }
        }
      }
      return set_opts;
    }
    assert(CUI.isPlainObject(opts), cls, "opts needs to be PlainObject.", {
      opts: opts,
      check_map: check_map
    });
    assert(CUI.isPlainObject(check_map), cls, "check_map needs to be PlainObject.", {
      opts: opts,
      check_map: check_map
    });
    set_opts = {};
    for (k in check_map) {
      v = check_map[k];
      if (opts.hasOwnProperty(k) && opts[k] !== void 0) {
        value = opts[k];
        exists = true;
      } else if (v.hasOwnProperty("default")) {
        value = v["default"];
        exists = true;
      } else {
        exists = false;
      }
      if (CUI.isFunction(v.mandatory)) {
        mandatory = v.mandatory.call(this, value);
      } else {
        mandatory = v.mandatory;
      }
      if (!exists) {
        if (mandatory) {
          assert(false, cls, "opts." + k + " needs to be set.", {
            opts: opts,
            check_map: check_map
          });
        } else {
          continue;
        }
      } else if (v.deprecated) {
        if (v.deprecated.length > 0) {
          post = v.deprecated;
        } else {
          post = "";
        }
        CUI.error(cls + ": opts." + k + " is deprecated.", value);
      }
      if (v.check && (!isNull(value) || mandatory)) {
        if (CUI.isArray(v.check)) {
          assert(v.check.indexOf(value) > -1, cls, "opts." + k + " needs to be one of [\"" + (v.check.join('\",\"')) + "\"].", {
            opts: opts
          });
        } else if (v.check === Boolean || v.check === String || v.check === Function || v.check === Array) {
          assertInstanceOf.call(this, k, v.check, void 0, value);
        } else if (CUI.isFunction(v.check) && !v.check.__super__) {
          assert(isEmpty(v.check.name) || v.check.name === "check", cls, k + ".check is \"" + v.check.name + "\" but has no \"__super__\" method. Use \"extends CUI.Element\" or \"extends CUI.Dummy\" to fix that.", {
            opts: opts,
            key: k,
            value: v
          });
          check = v.check.call(this, value);
          if (!(isNull(check) || isBoolean(check) || isString(check))) {
            _check = check;
            CUI.error("CUI.Element.readOpts: check needs to return Boolean, null, undefined or String.", "opts:", opts, "opt:", v, "return:", _check);
            if (_check) {
              check = true;
            } else {
              check = false;
            }
          }
          if (check !== true) {
            if (isString(check)) {
              err = check;
            } else {
              err = "needs to match\n\n" + v.check.toString();
            }
            assert(false, cls, "opts." + k + ": " + err + ".", {
              opts: opts
            });
          }
        } else if (CUI.isPlainObject(v.check)) {
          value = CUI.Element.readOpts(value, cls + " [opts." + k + "]", v.check);
        } else if (isNull(value) && mandatory) {
          assert(false, cls, "opts." + k + " is mandatory, but is " + value + ".", {
            opts: opts
          });
        } else {
          assertInstanceOf.call(this, k, v.check, void 0, value);
        }
      }
      if (map_values) {
        this["_" + k] = value;
        if (this instanceof CUI.Element) {
          this.__mapped_keys.push(k);
        }
      }
      set_opts[k] = value;
    }
    for (k in opts) {
      v = opts[k];
      if (v !== void 0 && !set_opts.hasOwnProperty(k) && !k.startsWith("_")) {
        CUI.error(cls + ": opts." + k + ", not supported. check_map: ", check_map, "opts:", opts);
      }
    }
    return set_opts;
  };

  Element.prototype.addOptsFromAttr = function(str) {
    var k, ref, results, v;
    ref = this.readOptsFromAttr(str);
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(this.opts[k] = v);
    }
    return results;
  };

  Element.prototype.readOptsFromAttr = function(str) {
    var i, key, key_value, len, opts, ref, ref1, value;
    opts = {};
    if (!(str != null ? str.split : void 0)) {
      return opts;
    }
    ref = str.split(";");
    for (i = 0, len = ref.length; i < len; i++) {
      key_value = ref[i];
      if (isEmpty(key_value.trim())) {
        continue;
      }
      ref1 = key_value.split(":"), key = ref1[0], value = ref1[1];
      key = key.trim();
      value = value != null ? value.trim() : void 0;
      assert(!isEmpty(key) && !isEmpty(value), this.__cls + ".readOptsFromAttr", "Parsing error in \"" + str + "\".");
      if (value === "true") {
        value = true;
      } else if (value === "false") {
        value = false;
      } else if (!isNaN(parseInt(value))) {
        value = parseInt(value);
      }
      opts[key] = value;
    }
    return opts;
  };

  Element.prototype.proxy = function(element, methods) {
    var fn1, i, len, method;
    assert(element instanceof CUI.Element, "CUI.Element.proxy", "element given must be instance of CUI.Element.", {
      element: element,
      methods: methods
    });
    assert(CUI.isArray(methods), "Element.proxy", "methods given must be Array.", {
      element: element,
      methods: methods
    });
    fn1 = (function(_this) {
      return function(method) {
        return _this[method] = function() {
          return element[method].apply(element, arguments);
        };
      };
    })(this);
    for (i = 0, len = methods.length; i < len; i++) {
      method = methods[i];
      fn1(method);
    }
    return this;
  };

  Element.prototype.destroy = function() {
    var i, k, len, ref;
    assert(this.__mapped_keys, getObjectClass(this) + ".destroy", "__mapped_keys not found, that means the top level constructor was not called.", {
      element: this
    });
    ref = this.__mapped_keys;
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      delete ("@_" + k);
    }
    this.__mapped_keys = [];
    if (typeof this._onDestroy === "function") {
      this._onDestroy(this);
    }
    return this.__destroyed = true;
  };

  Element.prototype.isDestroyed = function() {
    return this.__destroyed;
  };

  Element.uniqueId = 0;

  return Element;

})();
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.XHR = (function(superClass) {
  extend(XHR, superClass);

  function XHR() {
    return XHR.__super__.constructor.apply(this, arguments);
  }

  XHR.prototype.getGroup = function() {
    return "Core";
  };

  XHR.prototype.initOpts = function() {
    XHR.__super__.initOpts.call(this);
    this.addOpts({
      method: {
        mandatory: true,
        "default": "GET",
        check: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
      },
      url: {
        mandatory: true,
        check: String,
        check: function(v) {
          return v.trim().length > 0;
        }
      },
      user: {
        check: String
      },
      password: {
        check: String
      },
      responseType: {
        mandatory: true,
        "default": "json",
        check: ["", "text", "json"]
      },
      timeout: {
        check: function(v) {
          return v >= 0;
        }
      },
      form: {
        check: "PlainObject"
      },
      url_data: {
        check: "PlainObject"
      },
      json_data: {},
      json_pretty: {
        "default": false,
        check: function(v) {
          return v === false || v === true || isString(v);
        }
      },
      headers: {
        mandatory: true,
        "default": {},
        check: "PlainObject"
      }
    });
    return this;
  };

  XHR.readyStates = {
    0: "UNSENT",
    1: "OPENED",
    2: "HEADERS_RECEIVED",
    3: "LOADING",
    4: "DONE"
  };

  XHR.statusText = {
    "-1": "abort",
    "-2": "timeout",
    "-3": "network_failure"
  };

  XHR.prototype.readOpts = function() {
    var k, ref, v;
    XHR.__super__.readOpts.call(this);
    this.__xhr = new XMLHttpRequest();
    this.__readyStatesSeen = [this.readyState()];
    this.__registerEvents("download");
    this.__registerEvents("upload");
    this.__headers = {};
    ref = this._headers;
    for (k in ref) {
      v = ref[k];
      this.__headers[k.toLowerCase()] = v;
    }
    if (this._form) {
      if (!this.opts.method) {
        this._method = "POST";
      }
    }
    if (this._url_data) {
      this.__url = CUI.appendToUrl(this._url, this._url_data);
    } else {
      this.__url = this._url;
    }
    assert(!(this._form && this._json_data), "new CUI.XHR", "opts.form and opts.json_data cannot be set at the same time.");
    return this;
  };

  XHR.prototype.__registerEvents = function(type) {
    var fn, fn1, i, k, keys, len, xhr;
    keys = ["loadStart", "progress", "abort", "error", "load", "loadend", "timeout"];
    if (type === "upload") {
      xhr = this.__xhr.upload;
    } else {
      keys.push("readyStateChange");
      xhr = this.__xhr;
    }
    fn1 = (function(_this) {
      return function(fn, k) {
        return xhr.addEventListener(k.toLowerCase(), function(ev) {
          return _this[fn](ev);
        });
      };
    })(this);
    for (i = 0, len = keys.length; i < len; i++) {
      k = keys[i];
      fn = "__" + type + "_" + k;
      if (!this[fn]) {
        continue;
      }
      fn1(fn, k);
    }
    return this;
  };

  XHR.prototype.__setStatus = function(__status) {
    this.__status = __status;
    this.__xhr.CUI_status = this.__status;
    return this.__xhr.CUI_statusText = this.statusText();
  };

  XHR.prototype.__download_abort = function() {
    this.__setStatus(-1);
    return CUI.warn("Aborted:", this.__readyStatesSeen, this);
  };

  XHR.prototype.__download_timeout = function() {
    this.__setStatus(-2);
    return CUI.warn("Timeout:", this.__readyStatesSeen, this);
  };

  XHR.prototype.__download_loadend = function() {
    if (this.isSuccess()) {
      this.__dfr.resolve(this.response(), this.status(), this.statusText());
    } else {
      if (!this.status() && !this.__status) {
        this.__setStatus(-3);
        CUI.debug("status", this.__status);
      }
      this.__dfr.reject(this.response(), this.status(), this.statusText());
    }
    return this;
  };

  XHR.prototype.__download_readyStateChange = function() {
    return pushOntoArray(this.readyState(), this.__readyStatesSeen);
  };

  XHR.prototype.__progress = function(ev, type) {
    var loaded, percent, total;
    if (this.readyState() === "DONE") {
      return;
    }
    loaded = ev.loaded;
    total = ev.total;
    if (ev.lengthComputable) {
      percent = Math.floor(loaded / total * 100);
    } else {
      percent = -1;
    }
    this.__dfr.notify(type, loaded, total, percent);
    return this;
  };

  XHR.prototype.__upload_progress = function(ev) {
    return this.__progress(ev, "upload");
  };

  XHR.prototype.__download_progress = function(ev) {
    return this.__progress(ev, "download");
  };

  XHR.prototype.abort = function() {
    return this.__xhr.abort();
  };

  XHR.prototype.isSuccess = function() {
    if (this.__url.startsWith("file:///") && this.__readyStatesSeen.join(",") === "UNSENT,OPENED,HEADERS_RECEIVED,LOADING,DONE") {
      return true;
    } else {
      return this.__xhr.status >= 200 && this.__xhr.status < 300 || this.__xhr.status === 304;
    }
  };

  XHR.prototype.status = function() {
    if (this.__status < 0) {
      return this.__status;
    } else {
      return this.__xhr.status;
    }
  };

  XHR.prototype.statusText = function() {
    if (this.__status < 0) {
      return CUI.XHR.statusText[this.__status + ""];
    } else {
      return this.__xhr.statusText;
    }
  };

  XHR.prototype.response = function() {
    var e, res, rest;
    if (this._responseType === "json" && this.__xhr.responseType === "") {
      try {
        res = JSON.parse(this.__xhr.response);
      } catch (_error) {
        e = _error;
        rest = this.__xhr.response;
      }
    } else {
      res = this.__xhr.response;
    }
    if (this._responseType === "json") {
      this.__xhr.responseJSON = res;
    }
    return res;
  };

  XHR.prototype.start = function() {
    var data, k, ref, ref1, send_data, v;
    this.__xhr.open(this._method, this.__url, true, this._user, this._password);
    ref = this.__headers;
    for (k in ref) {
      v = ref[k];
      this.__xhr.setRequestHeader(k, v);
    }
    this.__xhr.responseType = this._responseType;
    this.__xhr.timeout = this._timeout;
    if (this._form) {
      data = new FormData();
      ref1 = this._form;
      for (k in ref1) {
        v = ref1[k];
        data.append(k, v);
      }
      send_data = data;
    } else if (this._json_data) {
      if (this._json_pretty) {
        if (this._json_pretty === true) {
          send_data = JSON.stringify(this._json_data, null, "\t");
        } else {
          send_data = JSON.stringify(this._json_data, null, this._json_pretty);
        }
      } else {
        send_data = JSON.stringify(this._json_data);
      }
    } else {
      send_data = void 0;
    }
    this.__dfr = new CUI.Deferred();
    this.__xhr.send(send_data);
    return this.__dfr.promise();
  };

  XHR.prototype.getXHR = function() {
    return this.__xhr;
  };

  XHR.prototype.getAllResponseHeaders = function() {
    var header, headers, i, len, ref;
    headers = [];
    ref = this.__xhr.getAllResponseHeaders().split("\r\n");
    for (i = 0, len = ref.length; i < len; i++) {
      header = ref[i];
      if (header.trim().length === 0) {
        continue;
      }
      headers.push(header);
    }
    return headers;
  };

  XHR.prototype.getResponseHeaders = function() {
    var header, i, key, len, map, match, ref;
    map = {};
    ref = this.getAllResponseHeaders();
    for (i = 0, len = ref.length; i < len; i++) {
      header = ref[i];
      match = header.match(/^(.*?): (.*)$/);
      key = match[1].toLowerCase();
      if (!map[key]) {
        map[key] = [];
      }
      map[key].push(match[2]);
    }
    return map;
  };

  XHR.prototype.getResponseHeader = function(key) {
    var ref;
    return (ref = this.getResponseHeaders()[key.toLowerCase()]) != null ? ref[0] : void 0;
  };

  XHR.prototype.readyState = function() {
    return CUI.XHR.readyStates[this.__xhr.readyState];
  };

  return XHR;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.DragDropSelect = (function(superClass) {
  extend(DragDropSelect, superClass);

  function DragDropSelect(opts) {
    this.opts = opts != null ? opts : {};
    DragDropSelect.__super__.constructor.call(this, this.opts);
    this.init();
  }

  DragDropSelect.prototype.initOpts = function() {
    DragDropSelect.__super__.initOpts.call(this);
    this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return CUI.DOM.isNode(v);
        }
      }
    });
    return this;
  };

  DragDropSelect.prototype.readOpts = function() {
    var ref;
    DragDropSelect.__super__.readOpts.call(this);
    this.cls = window[this.__cls].cls;
    assert(this.cls, "new " + this.__cls, this.__cls + ".cls is not set.", {
      opts: this.opts
    });
    this.element = this._element;
    if ((ref = DragDropSelect.getInstance(this.element, this.cls)) != null) {
      ref.destroy();
    }
    DOM.data(this.element, "drag-drop-select-" + this.cls, this);
    return DOM.addClass(this.element, this.__getClass());
  };

  DragDropSelect.prototype.__getClass = function() {
    return "cui-drag-drop-select cui-drag-drop-select-" + this.cls;
  };

  DragDropSelect.prototype.destroy = function() {
    DOM.removeClass(this.element, this.__getClass());
    DOM.removeData(this.element, "drag-drop-select-" + this.cls);
    Events.ignore({
      instance: this
    });
    return DragDropSelect.__super__.destroy.call(this);
  };

  DragDropSelect.prototype.init = function() {
    throw "overwrite Drag.init";
  };

  DragDropSelect.destroy = function(node, cls) {
    var inst;
    if (cls == null) {
      cls = this.cls;
    }
    inst = this.getInstance(node, cls);
    return inst != null ? inst.destroy() : void 0;
  };

  DragDropSelect.getInstance = function(node, cls) {
    if (cls == null) {
      cls = this.cls;
    }
    assert(cls !== "DragDropSelect", "DragDropSelect.getInstance", "cls cannot be DragDropSelect");
    return DOM.data(node, "drag-drop-select-" + cls);
  };

  return DragDropSelect;

})(CUI.Element);

CUI.ready((function(_this) {
  return function() {
    Events.registerEvent({
      type: "cui-drop",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragenter",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragend",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragleave",
      bubble: true
    });
    Events.registerEvent({
      type: "cui-dragover",
      bubble: true
    });
    Events.registerEvent({
      type: "dragover-scroll",
      bubble: true
    });
    return Events.listen({
      type: "dragover-scroll",
      node: document,
      selector: ".auto-drag-scroll,.cui-drag-drop-select",
      call: function(ev, info) {
        var $el, clientX, clientY, d, oe, oldScrollLeft, oldScrollTop, rect, ref, ref1, ref2, ref3, scrollLeft, scrollSpeed, scrollTop, scrollX, scrollY, scrollbarHorizontal, scrollbarVertical, threshold;
        scrollSpeed = info.mousemoveEvent._counter * 0.1 + 0.9;
        threshold = 30;
        $el = $(ev.getCurrentTarget());
        if ($el.is("body,html")) {
          rect = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0,
            height: window.innerHeight,
            width: window.innerWidth
          };
        } else {
          rect = CUI.DOM.getRect($el);
        }
        scrollTop = 0;
        scrollLeft = 0;
        if ($el[0].scrollWidth > rect.width) {
          scrollbarVertical = $el.width() - $el[0].clientWidth;
          scrollX = $el[0].scrollLeft;
          clientX = info.mousemoveEvent.clientX();
          if ((0 < (ref = (d = clientX - rect.left)) && ref < threshold)) {
            scrollLeft = -(threshold - d) * scrollSpeed;
          } else if ((0 < (ref1 = (d = rect.right - clientX - scrollbarVertical)) && ref1 < threshold)) {
            scrollLeft = (threshold - d) * scrollSpeed;
          }
          ev.stopPropagation();
        }
        if ($el[0].scrollHeight > rect.height) {
          scrollbarHorizontal = $el.height() - $el[0].clientHeight;
          scrollY = $el[0].scrollTop;
          clientY = info.mousemoveEvent.clientY();
          if ((0 < (ref2 = (d = clientY - rect.top)) && ref2 < threshold)) {
            scrollTop = -(threshold - d) * scrollSpeed;
          } else if ((0 < (ref3 = (d = rect.bottom - clientY - scrollbarHorizontal)) && ref3 < threshold)) {
            scrollTop = (threshold - d) * scrollSpeed;
          }
        }
        if (scrollTop || scrollLeft) {
          oldScrollTop = $el[0].scrollTop;
          oldScrollLeft = $el[0].scrollLeft;
          if (scrollTop) {
            $el[0].scrollTop += scrollTop;
          }
          if (scrollLeft) {
            $el[0].scrollLeft += scrollLeft;
          }
          if ($el.is("body,html")) {
            oe = info.mousemoveEvent;
            if (!oe.scrollPageY) {
              oe.scrollPageY = 0;
            }
            oe.scrollPageY += $el[0].scrollTop - oldScrollTop;
            if (!oe.scrollPageX) {
              oe.scrollPageX = 0;
            }
            oe.scrollPageX += $el[0].scrollLeft - oldScrollLeft;
          }
          return ev.stopPropagation();
        }
      }
    });
  };
})(this));
// Generated by CoffeeScript 1.9.3
var Draggable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

globalDrag = null;

CUI.Draggable = (function(superClass) {
  extend(Draggable, superClass);

  function Draggable() {
    return Draggable.__super__.constructor.apply(this, arguments);
  }

  Draggable.cls = "draggable";

  Draggable.prototype.initOpts = function() {
    Draggable.__super__.initOpts.call(this);
    return this.addOpts({
      dragClass: {
        "default": "cui-dragging",
        check: String
      },
      helper: {
        "default": "clone",
        check: function(v) {
          return v === "clone" || isElement(v) || CUI.isFunction(v);
        }
      },
      helper_contain_element: {
        check: function(v) {
          return isElement(v);
        }
      },
      helper_set_pos: {
        check: Function
      },
      dragend: {
        check: Function
      },
      dragstart: {
        check: Function
      },
      dragging: {
        check: Function
      },
      create: {
        "default": function() {
          return true;
        },
        check: Function
      },
      axis: {
        check: ["x", "y"]
      },
      threshold: {
        "default": 2,
        check: function(v) {
          return v >= 0;
        }
      },
      ms: {
        "default": 0,
        check: function(v) {
          return v % CUI.MouseIsDownListener.interval_ms === 0;
        }
      },
      selector: {
        check: (function(_this) {
          return function(v) {
            return isString(v) || CUI.isFunction(v);
          };
        })(this)
      }
    });
  };

  Draggable.prototype.__killTimeout = function() {
    if (globalDrag != null ? globalDrag.autoRepeatTimeout : void 0) {
      CUI.clearTimeout(globalDrag.autoRepeatTimeout);
      globalDrag.autoRepeatTimeout = null;
    }
    return this;
  };

  Draggable.prototype.__cleanup = function() {
    this.__killTimeout();
    if (this.__ref) {
      Events.ignore({
        instance: this.__ref
      });
      this.__ref = null;
    }
    return globalDrag = null;
  };

  Draggable.prototype.destroy = function() {
    Draggable.__super__.destroy.call(this);
    CUI.DOM.remove(globalDrag != null ? globalDrag.helperNode : void 0);
    this.__cleanup();
    return this;
  };

  Draggable.prototype.init = function() {
    assert(!this._helper_contain_element || CUI.DOM.closest(this._element, this._helper_contain_element), "new Draggable", "opts.helper_contain_element needs to be parent of opts.element", {
      opts: this.opts
    });
    DOM.addClass(this.element, "no-user-select");
    return Events.listen({
      type: "mouseisdown",
      node: this.element,
      capture: true,
      instance: this,
      selector: this._selector,
      call: (function(_this) {
        return function(ev) {
          var $target, dim, position, target, target_dim;
          if (ev.getButton() > 0) {
            return;
          }
          if (window.globalDrag) {
            return;
          }
          switch (ev.getMilliseconds()) {
            case _this._ms:
              position = elementGetPosition(getCoordinatesFromEvent(ev), $(ev.getTarget()));
              dim = DOM.getDimensions(ev.getTarget());
              if (dim.clientWidthScaled > 0 && position.left - dim.scrollLeftScaled > dim.clientWidthScaled) {
                CUI.warn("Mouseisdown on a vertical scrollbar, not starting drag.");
                return;
              }
              if (dim.clientHeightScaled > 0 && position.top - dim.scrollTopScaled > dim.clientHeightScaled) {
                CUI.warn("Mouseisdown on a horizontal scrollbar, not starting drag.");
                return;
              }
              target = ev.getCurrentTarget();
              target_dim = DOM.getDimensions(target);
              if (!DOM.isInDOM(target) || target_dim.clientWidth === 0 || target_dim.clientHeight === 0) {
                return;
              }
              if (CUI.DOM.closest(ev.getTarget(), "input,textarea,select")) {
                return;
              }
              $target = $(target);
              _this.init_drag(ev, $target);
              break;
            default:
              return;
          }
        };
      })(this)
    });
  };

  Draggable.prototype.init_drag = function(ev, $target) {
    var dragover_scroll, init, k, overwrite_options, point, position, v;
    overwrite_options = {};
    globalDrag = typeof this._create === "function" ? this._create(ev, overwrite_options, $target) : void 0;
    if (typeof ev.getMousedownEvent === "function") {
      ev.getMousedownEvent().preventDefault();
    }
    if (globalDrag === false) {
      return;
    }
    for (k in overwrite_options) {
      v = overwrite_options[k];
      this["_" + k] = v;
    }
    if (isNull(globalDrag) || globalDrag === true) {
      globalDrag = {};
    }
    assert(CUI.isPlainObject(globalDrag), "CUI.Draggable.init_drag", "returned data must be a plain object", {
      data: globalDrag
    });
    point = getCoordinatesFromEvent(ev);
    position = elementGetPosition(point, $target);
    init = {
      $source: $target,
      startEvent: ev,
      startCoordinates: point,
      startScroll: {
        top: $target[0].scrollTop,
        left: $target[0].scrollLeft
      },
      start: position,
      threshold: this._threshold
    };
    for (k in init) {
      v = init[k];
      globalDrag[k] = v;
    }
    ev.stopImmediatePropagation();
    this.before_drag(ev, $target);
    this.__ref = new CUI.Dummy();
    $target = null;
    dragover_scroll = (function(_this) {
      return function(mousemoveEvent) {
        if (!mousemoveEvent.hasOwnProperty("_counter")) {
          mousemoveEvent._counter = 0;
        } else {
          mousemoveEvent._counter++;
        }
        Events.trigger({
          type: "dragover-scroll",
          node: $target,
          info: {
            mousemoveEvent: mousemoveEvent
          }
        });
        return globalDrag.autoRepeatTimeout = CUI.setTimeout({
          ms: 100,
          track: false,
          call: function() {
            return dragover_scroll(mousemoveEvent);
          }
        });
      };
    })(this);
    Events.listen({
      node: document,
      type: "mousemove",
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          var coordinates, diff, pointTarget;
          if (!globalDrag) {
            return;
          }
          ev.preventDefault();
          if (document.selection) {
            document.selection.empty();
          } else {
            window.getSelection().removeAllRanges();
          }
          pointTarget = ev.getPointTarget();
          _this.__killTimeout();
          if (!pointTarget) {
            return;
          }
          $target = $(pointTarget);
          dragover_scroll(ev);
          if (globalDrag.dragend) {
            return;
          }
          coordinates = getCoordinatesFromEvent(ev);
          diff = {
            x: coordinates.pageX - globalDrag.startCoordinates.pageX,
            y: coordinates.pageY - globalDrag.startCoordinates.pageY,
            eventPoint: coordinates
          };
          switch (_this._axis) {
            case "x":
              diff.y = 0;
              break;
            case "y":
              diff.x = 0;
          }
          diff.x += globalDrag.$source.scrollLeft - globalDrag.startScroll.left;
          diff.y += globalDrag.$source.scrollTop - globalDrag.startScroll.top;
          if (Math.abs(diff.x) >= globalDrag.threshold || Math.abs(diff.y) >= globalDrag.threshold || globalDrag.dragStarted) {
            if (!globalDrag.dragStarted) {
              _this.__startDrag(ev, $target, diff);
            }
            globalDrag.dragDiff = diff;
            _this.do_drag(ev, $target, diff);
            if (typeof _this._dragging === "function") {
              _this._dragging(ev, $target, diff);
            }
          }
        };
      })(this)
    });
    Events.listen({
      node: document,
      type: ["keyup"],
      capture: true,
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          switch (ev.keyCode()) {
            case 83:
              if (ev.altKey()) {
                CUI.warn("Stopping Drag and Drop");
                _this.__cleanup();
                return;
              }
              break;
            case 27:
              globalDrag.stopped = true;
              return ev.stop();
          }
        };
      })(this)
    });
    Events.listen({
      node: document,
      type: ["mouseup"],
      capture: true,
      instance: this.__ref,
      call: (function(_this) {
        return function(ev) {
          if (!globalDrag.dragStarted) {
            _this.__cleanup();
            return;
          }
          globalDrag.dragend = true;
          _this.end_drag(ev);
          if (typeof _this._dragend === "function") {
            _this._dragend(ev, globalDrag, _this);
          }
          if (ev.getTarget() === globalDrag.startEvent.getTarget() && !globalDrag.noClickHandlerKill) {
            console.warn("install klick handler...");
            Events.listen({
              type: "click",
              capture: true,
              only_once: true,
              node: window,
              call: function(ev) {
                console.error("Killing click after drag");
                return ev.stop();
              }
            });
          }
          _this.__cleanup();
          return ev.stop();
        };
      })(this)
    });
  };

  Draggable.prototype.__startDrag = function(ev, $target, diff) {
    if (typeof this._dragstart === "function") {
      this._dragstart(ev, window.globalDrag);
    }
    this.init_helper(ev, $target, diff);
    globalDrag.$source.addClass(this._dragClass);
    this.start_drag(ev, $target, diff);
    return globalDrag.dragStarted = true;
  };

  Draggable.prototype.before_drag = function() {};

  Draggable.prototype.start_drag = function(ev, $target, diff) {};

  Draggable.prototype.do_drag = function(ev, $target, diff) {
    this.position_helper(ev, $target, diff);
    if (globalDrag.dragoverTarget && globalDrag.dragoverTarget[0] !== $target[0]) {
      Events.trigger({
        type: "cui-dragleave",
        node: globalDrag.dragoverTarget,
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
      globalDrag.dragoverTarget = null;
    }
    if (!globalDrag.dragoverTarget) {
      globalDrag.dragoverTarget = $target;
      Events.trigger({
        type: "cui-dragenter",
        node: globalDrag.dragoverTarget,
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
    }
    Events.trigger({
      node: globalDrag.dragoverTarget,
      type: "cui-dragover",
      info: {
        globalDrag: globalDrag,
        originalEvent: ev
      }
    });
  };

  Draggable.prototype.end_drag = function(ev) {
    if (this.isDestroyed()) {
      return;
    }
    if (globalDrag.dragoverTarget) {
      CUI.Events.trigger({
        node: globalDrag.dragoverTarget,
        type: "cui-dragleave",
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
      CUI.Events.trigger({
        node: globalDrag.dragoverTarget,
        type: "cui-dragend",
        info: {
          globalDrag: globalDrag,
          originalEvent: ev
        }
      });
      if (!globalDrag.stopped) {
        CUI.Events.trigger({
          type: "cui-drop",
          node: globalDrag.dragoverTarget,
          info: {
            globalDrag: globalDrag,
            originalEvent: ev
          }
        });
      }
      globalDrag.dragoverTarget = null;
    }
    globalDrag.$source.removeClass(this._dragClass);
    CUI.DOM.remove(globalDrag.helperNode);
    return this;
  };

  Draggable.prototype.position_helper = function(ev, $target, diff) {
    var dim_contain, helper_pos, left, pos, top;
    if (!globalDrag.helperNode) {
      return;
    }
    top = globalDrag.helperNodeStart.top + diff.y;
    left = globalDrag.helperNodeStart.left + diff.x;
    helper_pos = {
      top: top,
      left: left,
      start: {
        top: globalDrag.helperNodeStart.top,
        left: globalDrag.helperNodeStart.left
      }
    };
    pos = {
      x: helper_pos.left,
      y: helper_pos.top,
      w: globalDrag.helperNodeStart.width,
      h: globalDrag.helperNodeStart.height
    };
    if (this._helper_contain_element) {
      dim_contain = CUI.DOM.getDimensions(this._helper_contain_element);
      Draggable.limitRect(pos, {
        min_x: dim_contain.viewportLeft + dim_contain.borderLeftWidth,
        max_x: dim_contain.viewportRight - dim_contain.borderRightWidth - globalDrag.helperNodeStart.marginHorizontal,
        min_y: dim_contain.viewportTop + dim_contain.borderTopWidth,
        max_y: dim_contain.viewportBottom - dim_contain.borderBottomWidth - globalDrag.helperNodeStart.marginVertical
      });
    } else {
      dim_contain = globalDrag.helperNodeStart.body_dim;
      Draggable.limitRect(pos, {
        min_x: dim_contain.borderLeftWidth,
        max_x: dim_contain.scrollWidth - dim_contain.borderRightWidth - globalDrag.helperNodeStart.marginHorizontal,
        min_y: dim_contain.borderTopWidth,
        max_y: dim_contain.scrollHeight - dim_contain.borderBottomWidth - globalDrag.helperNodeStart.marginVertical
      });
    }
    helper_pos.top = pos.y;
    helper_pos.left = pos.x;
    helper_pos.dragDiff = {
      x: helper_pos.left - globalDrag.helperNodeStart.left,
      y: helper_pos.top - globalDrag.helperNodeStart.top
    };
    if (typeof this._helper_set_pos === "function") {
      this._helper_set_pos(globalDrag, helper_pos);
    }
    return CUI.DOM.setStyle(globalDrag.helperNode, {
      top: helper_pos.top,
      left: helper_pos.left
    });
  };

  Draggable.prototype.getSourceCloneForHelper = function() {
    return globalDrag.$source.cloneNode(true);
  };

  Draggable.prototype.init_helper = function(ev, $target, diff) {
    var dim, drag_source, hn, offset, set_dim, start;
    drag_source = globalDrag.$source;
    if (this._helper === "clone") {
      hn = CUI.jQueryCompat(this.getSourceCloneForHelper());
      offset = {
        top: globalDrag.start.top,
        left: globalDrag.start.left
      };
    }
    if (CUI.isFunction(this._helper)) {
      hn = globalDrag.helperNode = this._helper(globalDrag);
      offset = {
        top: 0,
        left: 0
      };
      set_dim = null;
    }
    if (!hn) {
      return;
    }
    globalDrag.helperNode = hn;
    hn.addClass("drag-drop-select-helper cui-debug-node-copyable cui-drag-drop-select-transparent");
    start = {
      top: globalDrag.startCoordinates.pageY - offset.top,
      left: globalDrag.startCoordinates.pageX - offset.left
    };
    CUI.DOM.setStyle(hn, {
      position: "absolute",
      top: start.top,
      left: start.left,
      zIndex: 1000
    });
    document.body.appendChild(hn);
    if (this._helper === "clone") {
      set_dim = DOM.getDimensions(drag_source);
      DOM.setDimensions(hn, {
        marginBoxWidth: set_dim.marginBoxWidth,
        marginBoxHeight: set_dim.marginBoxHeight
      });
    }
    dim = DOM.getDimensions(hn);
    start.width = dim.borderBoxWidth;
    start.height = dim.borderBoxHeight;
    start.marginTop = dim.marginTop;
    start.marginLeft = dim.marginLeft;
    start.marginVertical = dim.marginVertical;
    start.marginHorizontal = dim.marginHorizontal;
    start.body_dim = CUI.DOM.getDimensions(document.body);
    return globalDrag.helperNodeStart = start;
  };

  Draggable.limitRect = function(pos, limitRect, defaults) {
    var diff, i, k, key, len, mkey, ref, skey, v, value;
    if (defaults == null) {
      defaults = {};
    }
    pos.fix = pos.fix || [];
    for (k in defaults) {
      v = defaults[k];
      if (isUndef(pos[k])) {
        pos[k] = v;
      }
    }
    ref = ["min_w", "max_w", "min_h", "max_h", "min_x", "max_x", "min_y", "max_y"];
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      value = limitRect[key];
      if (isUndef(value)) {
        continue;
      }
      assert(!isNaN(value), (getObjectClass(this)) + ".limitRect", "key " + key + " in pos isNaN", {
        pos: pos,
        defaults: defaults,
        limitRect: limitRect
      });
      skey = key.substring(4);
      mkey = key.substring(0, 3);
      if (key === "max_x") {
        value -= pos.w;
      }
      if (key === "max_y") {
        value -= pos.h;
      }
      diff = pos[skey] - value;
      if (mkey === "min") {
        if (diff >= 0) {
          continue;
        }
      }
      if (mkey === "max") {
        if (diff <= 0) {
          continue;
        }
      }
      if (skey === "y" && indexOf.call(pos.fix, "n") >= 0) {
        pos.h -= diff;
        continue;
      }
      if (skey === "x" && indexOf.call(pos.fix, "w") >= 0) {
        pos.w -= diff;
        continue;
      }
      pos[skey] -= diff;
      if (skey === "h" && indexOf.call(pos.fix, "s") >= 0) {
        pos.y += diff;
      }
      if (skey === "w" && indexOf.call(pos.fix, "e") >= 0) {
        pos.x += diff;
      }
      if (skey === "x" && indexOf.call(pos.fix, "e") >= 0) {
        pos.w += diff;
      }
      if (skey === "y" && indexOf.call(pos.fix, "s") >= 0) {
        pos.h += diff;
      }
    }
    return pos;
  };

  return Draggable;

})(CUI.DragDropSelect);

Draggable = CUI.Draggable;
// Generated by CoffeeScript 1.9.3
var Droppable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Droppable = (function(superClass) {
  extend(Droppable, superClass);

  function Droppable() {
    return Droppable.__super__.constructor.apply(this, arguments);
  }

  Droppable.cls = "droppable";

  Droppable.prototype.initOpts = function() {
    Droppable.__super__.initOpts.call(this);
    return this.addOpts({
      accept: {
        check: Function
      },
      drop: {
        "default": (function(_this) {
          return function(ev, info) {
            var pos;
            pos = info.dropTargetPos || "on";
            return CUI.alert({
              markdown: true,
              text: "You dropped me **" + pos + "**: " + CUI.DOM.getAttribute(info.dropTarget, "class")
            });
          };
        })(this),
        check: Function
      },
      hoverClass: {
        "default": "cui-droppable",
        check: String
      },
      dropHelper: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      targetHelper: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      selector: {
        check: (function(_this) {
          return function(v) {
            return isString(v) || CUI.isFunction(v);
          };
        })(this)
      }
    });
  };

  Droppable.prototype.accept = function(ev, info) {
    return typeof this._accept === "function" ? this._accept(ev, info) : void 0;
  };

  Droppable.prototype.destroy = function() {
    this.removeHelper();
    return Droppable.__super__.destroy.call(this);
  };

  Droppable.prototype.readOpts = function() {
    Droppable.__super__.readOpts.call(this);
    if (this._targetHelper) {
      assert(this._selector, "new Droppable", "opts.targetHelper needs opts.selector to be set.", {
        opts: this.opts
      });
    }
    if (this._dropHelper) {
      assert(!this._selector || this._targetHelper, "new Droppable", "opts.dropHelper does only work without opts.selector or with opts.targetHelper and opts.selector. needs opts.selector to be set.", {
        opts: this.opts
      });
      this.__dropHelper = CUI.DOM.element("DIV", {
        "class": "cui-droppable-drop-helper cui-debug-node-copyable"
      });
    }
  };

  Droppable.prototype.removeHelper = function() {
    var el, i, len, ref;
    this.resetMargin();
    if (this.__selectedTarget) {
      CUI.DOM.removeClass(this.__selectedTarget, this._hoverClass);
      this.__selectedTarget = null;
    }
    if (this.__dropHelper) {
      CUI.DOM.remove(this.__dropHelper);
    }
    if (this._targetHelper) {
      ref = CUI.DOM.findElements(this._element, this._selector);
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        el.classList.remove("cui-droppable-target-helper");
      }
    }
    this.__dropTarget = void 0;
    return this.__dropTargetPos = void 0;
  };

  Droppable.prototype.resetMargin = function() {
    if (!this.__resetMargin) {
      return;
    }
    this.__resetMargin.classList.remove(this.__resetMargin.__target_helper_class);
    delete this.__resetMargin.__target_helper_class;
    delete this.__resetMargin;
    return delete this.__saveZoneDims;
  };

  Droppable.prototype.insideSaveZone = function(coord) {
    var buf, i, len, ref, ref1, ref2, zone;
    if (!this.__saveZoneDims) {
      return false;
    }
    buf = 5;
    ref = this.__saveZoneDims;
    for (i = 0, len = ref.length; i < len; i++) {
      zone = ref[i];
      if (((zone.viewportTopMargin - buf) <= (ref1 = coord.pageY) && ref1 <= (zone.viewportBottomMargin + buf)) && ((zone.viewportLeftMargin - buf) <= (ref2 = coord.pageX) && ref2 <= (zone.viewportRightMargin + buf))) {
        return true;
      }
    }
    return false;
  };

  Droppable.prototype.syncDropHelper = function() {
    var dim, drop_helper_dim;
    dim = CUI.DOM.getDimensions(this._element);
    document.body.appendChild(this.__dropHelper);
    CUI.DOM.setDimensions(this.__dropHelper, {
      contentBoxWidth: dim.borderBoxWidth,
      contentBoxHeight: dim.borderBoxHeight
    });
    drop_helper_dim = CUI.DOM.getDimensions(this.__dropHelper);
    return CUI.DOM.setStyle(this.__dropHelper, {
      position: "absolute",
      top: dim.viewportTop - drop_helper_dim.borderTopWidth - drop_helper_dim.marginTop,
      left: dim.viewportLeft - drop_helper_dim.borderLeftWidth - drop_helper_dim.marginLeft
    });
  };

  Droppable.prototype.syncTargetHelper = function(ev, info) {
    var acceptable, coord, dim, dropTarget, dropTargetPos, el, helper_cls, i, last_dim, len, new_target, ref, target;
    target = ev.getTarget();
    coord = getCoordinatesFromEvent(info.originalEvent);
    if (ev.getType() === "cui-dragleave") {
      new_target = info.originalEvent.getTarget();
      if (CUI.DOM.closest(new_target, ".cui-drag-drop-select-droppable") !== this._element) {
        this.removeHelper();
        return true;
      }
      if (this._targetHelper || !this._selector) {
        return;
      }
    }
    acceptable = (function(_this) {
      return function(dropTarget, dropTargetPos) {
        info.dropTarget = dropTarget;
        if (_this._targetHelper) {
          info.dropTargetPos = dropTargetPos;
        }
        if (_this.accept(ev, info) === false) {
          _this.removeHelper();
          return false;
        } else {
          return true;
        }
      };
    })(this);
    if (this.__dropTarget === void 0) {
      last_dim = null;
      this.__axis = null;
      ref = CUI.DOM.findElements(this._element, this._selector);
      for (i = 0, len = ref.length; i < len; i++) {
        el = ref[i];
        dim = CUI.DOM.getDimensions(el);
        if (last_dim && !this.__axis) {
          if (last_dim.viewportLeft === dim.viewportLeft) {
            this.__axis = "y";
          }
          if (last_dim.viewportTop === dim.viewportTop) {
            this.__axis = "x";
          }
        }
        if (this._targetHelper) {
          el.classList.add("cui-droppable-target-helper");
        }
        last_dim = dim;
      }
      if (!this.__axis) {
        this.__axis = "x";
      }
      this.__dropTargetPos = null;
      this.__dropTarget = null;
    }
    CUI.DOM.removeClass(this.__selectedTarget, this._hoverClass);
    if (this._selector) {
      this.__selectedTarget = CUI.DOM.closest(target, this._selector);
    } else {
      this.__selectedTarget = this._element;
    }
    if (!this._targetHelper) {
      if (!acceptable(this.__selectedTarget)) {
        this.removeHelper();
        if (this._selector && !this.__selectedTarget) {
          return true;
        }
        return;
      }
      this.__dropTarget = this.__selectedTarget;
      this.__dropTargetPos = null;
      if (this._selector || !this.__dropHelper) {
        CUI.DOM.addClass(this.__selectedTarget, this._hoverClass);
      } else {
        this.syncDropHelper();
      }
      return;
    }
    if (!this.__selectedTarget) {
      if (this.insideSaveZone(coord)) {
        console.info("Inside save zone...");
        return;
      }
      this.resetMargin();
      if (this.__dropHelper) {
        if (!acceptable(this._element)) {
          return;
        }
        this.__dropTarget = this._element;
        this.__dropTargetPos = null;
        this.syncDropHelper();
      } else {
        console.info("No selected target, no dropHelper...");
        this.removeHelper();
        return true;
      }
      return;
    }
    CUI.DOM.remove(this.__dropHelper);
    dim = CUI.DOM.getDimensions(this.__selectedTarget);
    if ((this.__axis === "x" && coord.pageX > dim.viewportCenterLeft) || (this.__axis === "y" && coord.pageY > dim.viewportCenterTop)) {
      dropTargetPos = "after";
    } else {
      dropTargetPos = "before";
    }
    dropTarget = this.__selectedTarget;
    if (!acceptable(dropTarget, dropTargetPos)) {
      this.removeHelper();
      return;
    }
    this.__dropTarget = dropTarget;
    this.__dropTargetPos = dropTargetPos;
    helper_cls = "cui-droppable-target-helper-" + this.__axis + "--" + this.__dropTargetPos;
    if (this.__resetMargin === this.__selectedTarget && this.__selectedTarget.__target_helper_class === helper_cls) {

    } else {
      this.resetMargin();
      this.__saveZoneDims = [CUI.DOM.getDimensions(this.__selectedTarget)];
      this.__selectedTarget.__target_helper_class = helper_cls;
      this.__selectedTarget.addClass(this.__selectedTarget.__target_helper_class);
      this.__saveZoneDims.push(CUI.DOM.getDimensions(this.__selectedTarget));
      this.__resetMargin = this.__selectedTarget;
    }
  };

  Droppable.prototype.init = function() {
    Events.listen({
      node: this.element,
      type: "cui-dragend",
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          return _this.removeHelper();
        };
      })(this)
    });
    Events.listen({
      node: this.element,
      type: "cui-drop",
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          if (!_this.__dropTarget) {
            return;
          }
          info.dropTarget = _this.__dropTarget;
          if (_this._targetHelper) {
            info.dropTargetPos = _this.__dropTargetPos;
          }
          if (_this.accept(ev, info) !== false) {
            ev.stopPropagation();
            _this._drop(ev, info);
          }
        };
      })(this)
    });
    return Events.listen({
      node: this.element,
      type: ["cui-dragover", "cui-dragenter", "cui-dragleave"],
      instance: this,
      call: (function(_this) {
        return function(ev, info) {
          _this.syncTargetHelper(ev, info);
          ev.stopPropagation();
        };
      })(this)
    });
  };

  return Droppable;

})(CUI.DragDropSelect);

Droppable = CUI.Droppable;
// Generated by CoffeeScript 1.9.3
var Lasso, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Lasso = (function(superClass) {
  extend(Lasso, superClass);

  function Lasso() {
    return Lasso.__super__.constructor.apply(this, arguments);
  }

  Lasso.cls = "lasso";

  Lasso.prototype.initOpts = function() {
    Lasso.__super__.initOpts.call(this);
    this.addOpts({
      filter: {
        "default": "*",
        check: String
      },
      selected: {
        "default": function(ev, info) {
          return alert("You lassoed " + info.elements.length + " elements.");
        },
        check: Function
      },
      lassoClass: {
        "default": "cui-lasso",
        check: String
      }
    });
    return this.removeOpt("helper");
  };

  Lasso.prototype.readOpts = function() {
    Lasso.__super__.readOpts.call(this);
    return this._helper = null;
  };

  Lasso.prototype.lasso_cls = "cui-drag-drop-select-lasso-element-in-lasso";

  Lasso.prototype.init = function() {
    Lasso.__super__.init.call(this);
    this.element.addClass("cui-lasso-area");
    return this.position = null;
  };

  Lasso.prototype.start_drag = function(ev, $target, diff) {
    if (!CUI.DOM.isInDOM(this.element[0])) {
      throw "DragDropSelect: Creating lasso failed, element is not in DOM.";
    }
    globalDrag.lasso = $div(this._lassoClass + " cui-debug-node-copyable");
    return globalDrag.lasso.appendTo(this.element);
  };

  Lasso.prototype.do_drag = function(ev, $target, diff) {
    var el, i, len, over, ref, set_css;
    set_css = {};
    if (diff.x <= 0) {
      set_css.left = globalDrag.start.left + diff.x;
      set_css.width = -diff.x;
      over = -set_css.left;
      if (over > 0) {
        set_css.width -= over;
        set_css.left = 0;
      }
    } else {
      set_css.left = globalDrag.start.left;
      set_css.width = diff.x;
      over = set_css.left + set_css.width - this.element[0].scrollWidth;
      if (over > 0) {
        set_css.width -= over;
      }
    }
    if (diff.y <= 0) {
      set_css.top = globalDrag.start.top + diff.y;
      set_css.height = -diff.y;
      over = -set_css.top;
      if (over > 0) {
        set_css.height -= over;
        set_css.top = 0;
      }
    } else {
      set_css.top = globalDrag.start.top;
      set_css.height = diff.y;
      over = set_css.top + set_css.height - this.element[0].scrollHeight;
      if (over > 0) {
        set_css.height -= over;
      }
    }
    this.resetLassoedElements();
    ref = this.get_lassoed_elements();
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      el.classList.add(this.lasso_cls);
    }
    return globalDrag.lasso.css(set_css);
  };

  Lasso.prototype.resetLassoedElements = function() {
    var el, i, len, ref;
    ref = DOM.matchSelector(this.element, "." + this.lasso_cls);
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      el.classList.remove(this.lasso_cls);
    }
    return this;
  };

  Lasso.prototype.get_lassoed_elements = function() {
    var do_overlap, el, get_dim, i, lassoed, len, ref;
    get_dim = function($el) {
      var dim;
      dim = DOM.getRect($el);
      return dim;
    };
    do_overlap = function(dims1, dims2) {
      var h1, h2, w1, w2, x1, x2, y1, y2;
      x1 = dims1.left;
      y1 = dims1.top;
      w1 = dims1.width;
      h1 = dims1.height;
      x2 = dims2.left;
      y2 = dims2.top;
      w2 = dims2.width;
      h2 = dims2.height;
      return !(y2 + h2 <= y1 || y1 + h1 <= y2 || x2 + w2 <= x1 || x1 + w1 <= x2);
    };
    globalDrag.lasso_dim = get_dim(globalDrag.lasso);
    lassoed = [];
    ref = globalDrag.$source.find(this._filter);
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      if (do_overlap(globalDrag.lasso_dim, get_dim($(el)))) {
        lassoed.push(el);
      }
    }
    return lassoed;
  };

  Lasso.prototype.end_drag = function(ev) {
    this.resetLassoedElements();
    if (ev.getType() === "mouseup") {
      globalDrag.elements = this.get_lassoed_elements();
      this._selected(ev, globalDrag);
    }
    return globalDrag.lasso.remove();
  };

  return Lasso;

})(CUI.Draggable);

Lasso = CUI.Lasso;
// Generated by CoffeeScript 1.9.3
var Sortable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Sortable = (function(superClass) {
  extend(Sortable, superClass);

  function Sortable() {
    return Sortable.__super__.constructor.apply(this, arguments);
  }

  Sortable.cls = "sortable";

  Sortable.prototype.initOpts = function() {
    Sortable.__super__.initOpts.call(this);
    this.addOpts({
      sorted: {
        mandatory: true,
        "default": function(ev, from_idx, to_idx) {
          return alert("You sorted item " + from_idx + " to " + to_idx + ".");
        },
        check: Function
      }
    });
    this.removeOpt("helper_contain_element");
    return this.mergeOpt("selector", {
      "default": function(target, node) {
        var els;
        els = CUI.DOM.elementsUntil(target, null, node);
        if (!els) {
          return null;
        }
        if (els.length > 1) {
          return els[els.length - 2];
        } else {
          return null;
        }
      }
    });
  };

  Sortable.prototype.readOpts = function() {
    Sortable.__super__.readOpts.call(this);
    return this._helper_contain_element = this._element;
  };

  Sortable.prototype.get_child_number = function(child) {
    var c, i, idx, len, ref;
    ref = this.element.children;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      c = ref[idx];
      if (c === child) {
        return idx;
      }
    }
    return null;
  };

  Sortable.prototype.move_element = function(source_idx, dest_idx) {
    var $dest, $source;
    $source = this.element.children[source_idx];
    $dest = this.element.children[dest_idx];
    if (source_idx === dest_idx) {
      return;
    }
    if (source_idx < dest_idx) {
      globalDrag.noClickHandlerKill = true;
      CUI.DOM.insertAfter($dest, $source);
    } else if (source_idx > dest_idx) {
      globalDrag.noClickHandlerKill = true;
      CUI.DOM.insertBefore($dest, $source);
    }
    CUI.DOM.syncAnimatedClone(this.element);
    return this;
  };

  Sortable.prototype.start_drag = function(ev, $target, diff) {
    globalDrag.sort_source = this.__findClosestSon(globalDrag.$source);
    globalDrag.sort_source.classList.add("cui-sortable-placeholder");
    globalDrag.start_idx = this.get_child_number(globalDrag.sort_source);
    return CUI.DOM.initAnimatedClone(this.element);
  };

  Sortable.prototype.getSourceCloneForHelper = function() {
    return this.__findClosestSon(globalDrag.$source).cloneNode(true);
  };

  Sortable.prototype.__findClosestSon = function($target) {
    var parents;
    parents = CUI.DOM.parentsUntil($target, null, this.element);
    if (parents[parents.length - 1] === window) {
      return null;
    }
    switch (parents.length) {
      case 0:
        return null;
      case 1:
        return $target;
      default:
        return parents[parents.length - 2];
    }
  };

  Sortable.prototype.do_drag = function(ev, $target, diff) {
    var dest_idx, source_idx, target_child;
    this.position_helper(ev, $target, diff);
    target_child = this.__findClosestSon($target);
    if (!target_child) {
      return;
    }
    source_idx = this.get_child_number(globalDrag.sort_source);
    dest_idx = this.get_child_number(target_child);
    return this.move_element(source_idx, dest_idx);
  };

  Sortable.prototype.end_drag = function(ev) {
    var curr_idx;
    globalDrag.sort_source.classList.remove("cui-sortable-placeholder");
    CUI.DOM.removeAnimatedClone(this.element);
    curr_idx = this.get_child_number(globalDrag.sort_source);
    if (ev.getType() === "mouseup") {
      globalDrag.helperNode.remove();
      globalDrag.helperNode = null;
      if (this._sorted) {
        if (globalDrag.start_idx !== curr_idx) {
          this._sorted(ev, globalDrag.start_idx, curr_idx);
        }
      }
    } else {
      this.move_element(curr_idx, globalDrag.start_idx);
    }
    return Sortable.__super__.end_drag.call(this, ev);
  };

  return Sortable;

})(CUI.Draggable);

Sortable = CUI.Sortable;
// Generated by CoffeeScript 1.9.3
var Movable, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

CUI.Movable = (function(superClass) {
  extend(Movable, superClass);

  function Movable() {
    return Movable.__super__.constructor.apply(this, arguments);
  }

  Movable.cls = "movable";

  Movable.prototype.initOpts = function() {
    Movable.__super__.initOpts.call(this);
    this.addOpts({
      limitRect: {
        "default": {},
        check: function(v) {
          return CUI.isPlainObject(v) || v instanceof Function;
        }
      },
      onPositioned: {
        check: Function
      },
      onPosition: {
        check: Function
      },
      start_drag: {
        check: Function
      },
      do_drag: {
        check: Function
      }
    });
    return this.removeOpt("helper");
  };

  Movable.prototype.readOpts = function() {
    Movable.__super__.readOpts.call(this);
    return this._helper = null;
  };

  Movable.prototype.getLimitRect = function() {
    if (CUI.isFunction(this._limitRect)) {
      return this._limitRect();
    } else {
      return this._limitRect;
    }
  };

  Movable.prototype.setElementCss = function(pos) {
    var setCss;
    assert(CUI.isPlainObject(pos), getObjectClass(this), "opts.position must return a PlainObject containing any of x, y, w, h", {
      pos: pos
    });
    setCss = {};
    if (!isEmpty(pos.x)) {
      setCss.left = pos.x;
    }
    if (!isEmpty(pos.y)) {
      setCss.top = pos.y;
    }
    if (!isEmpty(pos.w)) {
      setCss.marginBoxWidth = pos.w;
    }
    if (!isEmpty(pos.h)) {
      setCss.marginBoxHeight = pos.h;
    }
    CUI.DOM.setDimensions(this.element[0], setCss);
    return typeof this._onPositioned === "function" ? this._onPositioned(pos) : void 0;
  };

  Movable.prototype.init_drag = function(ev, $target) {
    if (CUI.DOM.closest(ev.getTarget(), ".cui-resizable-handle")) {
      return;
    }
    return Movable.__super__.init_drag.call(this, ev, $target);
  };

  Movable.prototype.before_drag = function() {
    var dim;
    dim = CUI.DOM.getDimensions(this.element[0]);
    this.start = {
      x: dim.left || 0,
      y: dim.top || 0,
      w: dim.marginBoxWidth,
      h: dim.marginBoxHeight
    };
    return this;
  };

  Movable.prototype.start_drag = function(ev, $target, diff) {
    if (this._start_drag) {
      this._start_drag(ev, $target, diff, this);
    }
    return this;
  };

  Movable.prototype.do_drag = function(ev, $target, diff) {
    var pos, ref;
    if (this._do_drag) {
      this._do_drag(ev, $target, diff, this);
      return this;
    }
    pos = {
      x: diff.x + this.start.x,
      y: diff.y + this.start.y,
      w: this.start.w,
      h: this.start.h
    };
    if (this._onPosition) {
      ref = this._onPosition(pos.x, pos.y, this.start, diff), pos.x = ref[0], pos.y = ref[1];
    } else {
      this.limitRect(pos, this.start);
    }
    this.setElementCss(pos);
    return this;
  };

  Movable.prototype.limitRect = function(pos, defaults, limitRect) {
    if (defaults == null) {
      defaults = {};
    }
    if (limitRect == null) {
      limitRect = this.getLimitRect();
    }
    return Draggable.limitRect(pos, limitRect, defaults);
  };

  return Movable;

})(CUI.Draggable);

Movable = CUI.Movable;
// Generated by CoffeeScript 1.9.3
var Resizable, globalDrag,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

Resizable = (function(superClass) {
  extend(Resizable, superClass);

  function Resizable() {
    this.getResizePos = bind(this.getResizePos, this);
    return Resizable.__super__.constructor.apply(this, arguments);
  }

  Resizable.cls = "resizable";

  Resizable.prototype.initOpts = function() {
    Resizable.__super__.initOpts.call(this);
    return this.removeOpt("selector");
  };

  Resizable.prototype.readOpts = function() {
    Resizable.__super__.readOpts.call(this);
    return this._selector = ".cui-resizable-handle";
  };

  Resizable.prototype.init = function() {
    var d, i, len, ref, results;
    Resizable.__super__.init.call(this);
    ref = ["ne", "nw", "se", "sw", "s", "n", "e", "w"];
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      d = ref[i];
      results.push(this.element.append(CUI.DOM.element("DIV", {
        "cui-drag-drop-select-resizable": d,
        "class": "cui-resizable-handle cui-resizable-handle-" + d
      })));
    }
    return results;
  };

  Resizable.prototype.before_drag = function(ev, $target) {
    Resizable.__super__.before_drag.call(this, ev, $target);
    return globalDrag.resize = $target.attr("cui-drag-drop-select-resizable");
  };

  Resizable.prototype.init_drag = function(ev, $target) {
    return Draggable.prototype.init_drag.call(this, ev, $target);
  };

  Resizable.prototype.start_drag = function(ev, $target, diff) {
    if (this._start_drag) {
      return this._start_drag(ev, $target, diff, this);
    }
  };

  Resizable.prototype.do_drag = function(ev, $target, diff) {
    if (this._do_drag) {
      return this._do_drag(ev, $target, diff, this);
    }
    return this.setElementCss(this.getResizePos(this.start, diff));
  };

  Resizable.prototype.getResizePos = function(start, diff, limitRect) {
    var pos;
    if (limitRect == null) {
      limitRect = this.getLimitRect();
    }
    switch (globalDrag.resize) {
      case "se":
        pos = {
          w: start.w + diff.x,
          h: start.h + diff.y,
          fix: ["n", "w"]
        };
        break;
      case "sw":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          h: start.h + diff.y,
          fix: ["n", "e"]
        };
        break;
      case "ne":
        pos = {
          w: start.w + diff.x,
          y: start.y + diff.y,
          h: start.h - diff.y,
          fix: ["s", "e"]
        };
        break;
      case "nw":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          y: start.y + diff.y,
          h: start.h - diff.y,
          fix: ["e", "s"]
        };
        break;
      case "s":
        pos = {
          h: start.h + diff.y,
          fix: ["n"]
        };
        break;
      case "n":
        pos = {
          h: start.h - diff.y,
          y: start.y + diff.y,
          fix: ["s"]
        };
        break;
      case "e":
        pos = {
          w: start.w + diff.x,
          fix: ["w"]
        };
        break;
      case "w":
        pos = {
          w: start.w - diff.x,
          x: start.x + diff.x,
          fix: ["e"]
        };
    }
    return this.limitRect(pos, start, limitRect);
  };

  return Resizable;

})(Movable);
// Generated by CoffeeScript 1.9.3
var Dragscroll, globalDrag,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

globalDrag = null;

Dragscroll = (function(superClass) {
  extend(Dragscroll, superClass);

  function Dragscroll() {
    return Dragscroll.__super__.constructor.apply(this, arguments);
  }

  Dragscroll.prototype.start_drag = function(ev, $target, diff) {
    return this.scrollPos = {
      top: this.element[0].scrollTop,
      left: this.element[0].scrollLeft
    };
  };

  Dragscroll.prototype.do_drag = function(ev, $target, diff) {
    this.element[0].scrollTop = Math.max(0, this.scrollPos.top - diff.y);
    return this.element[0].scrollLeft = Math.max(0, this.scrollPos.left - diff.x);
  };

  return Dragscroll;

})(Draggable);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Event = (function(superClass) {
  extend(Event, superClass);

  function Event(opts) {
    this.opts = opts != null ? opts : {};
    Event.__super__.constructor.call(this, this.opts);
    if (this._require_node_in_dom) {
      console.debug("require node in dom", this.isInDOM(), this.__node);
      assert(this.isInDOM(), "new Event", "node is not in DOM, unable to create event.", {
        opts: this.opts
      });
    }
    this.__propagationStopped = false;
    this.__propagationImmediateStopped = false;
    this.__preventDefault = false;
    this.__dragPrevented = false;
  }

  Event.prototype.initOpts = function() {
    Event.__super__.initOpts.call(this);
    return this.addOpts({
      type: {
        mandatory: true,
        check: function(v) {
          return isString(v) && !isEmpty(v) && v.split(/\s+/).length === 1;
        }
      },
      node: {
        "default": document.documentElement,
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      require_node_in_dom: {
        "default": false,
        mandatory: true,
        check: Boolean
      },
      bubble: {
        "default": false,
        check: Boolean
      },
      sink: {
        "default": false,
        check: Boolean
      },
      exclude_self: {
        "default": false,
        check: Boolean
      },
      info: {
        "default": {},
        check: "PlainObject"
      },
      prevent_default: {
        "default": false,
        check: Boolean
      },
      onProgress: {
        check: Function
      }
    });
  };

  Event.prototype.readOpts = function() {
    Event.__super__.readOpts.call(this);
    this.__node = DOM.getNode(this._node);
    if (this._preventDefault) {
      this.preventDefault();
    }
    this.__listenerClass = null;
    this.__progress_counter = 0;
    return this.__isInDOM = null;
  };

  Event.prototype.setListener = function(listener) {
    if (!this.__listenerClass) {
      this.__listenerClass = listener.getElementClass();
    } else {
      assert(this.__listenerClass === listener.getElementClass(), "Event.setListener", "listener class cannot change during an events life cycle.", {
        listener: listener,
        listenerClass: this.__listenerClass
      });
    }
    return this;
  };

  Event.prototype.progress = function(listener, ret) {
    this.__progress_counter++;
    if (typeof this._onProgress === "function") {
      this._onProgress(listener, ret, this.__progress_counter);
    }
    return this.__progress_counter;
  };

  Event.prototype.isExcludeSelf = function() {
    return this._exclude_self;
  };

  Event.prototype.setPhase = function(__phase) {
    this.__phase = __phase;
  };

  Event.prototype.getPhase = function() {
    return this.__phase;
  };

  Event.prototype.getType = function() {
    return this._type;
  };

  Event.prototype.getDebug = function() {
    return this._type + "[" + this.getUniqueId() + "#" + this.__progress_counter + "]";
  };

  Event.prototype.getInfo = function() {
    return this._info;
  };

  Event.prototype.getNode = function() {
    return this.__node;
  };

  Event.prototype.getElement = function() {
    return DOM.data(this.getNode(), "element");
  };

  Event.prototype.isBubble = function() {
    return this._bubble;
  };

  Event.prototype.isSink = function() {
    return this._sink;
  };

  Event.prototype.isInDOM = function() {
    if (this.__isInDOM !== null) {
      return this.__isInDOM;
    } else if (this.__node === document || this.__node === window) {
      return this.__isInDOM = true;
    } else {
      return this.__isInDOM = DOM.isInDOM(this.__node);
    }
  };

  Event.prototype.setNativeEvent = function(NativeEvent) {
    assert(NativeEvent instanceof window.Event, "CUI.Event.setNativeEvent", "Event needs to be instanceof Event", {
      Event: NativeEvent
    });
    this.__NativeEvent = NativeEvent;
    return this;
  };

  Event.prototype.getNativeEvent = function() {
    return this.__NativeEvent;
  };

  Event.prototype.getPointTarget = function() {
    return document.elementFromPoint(this.clientX(), this.clientY());
  };

  Event.prototype.getTarget = function() {
    var ref;
    return this.__target || ((ref = this.getNativeEvent()) != null ? ref.target : void 0);
  };

  Event.prototype.setTarget = function(tg) {
    return this.__target = tg;
  };

  Event.prototype.getCurrentTarget = function() {
    return this.__currentTarget || this.getTarget();
  };

  Event.prototype.setCurrentTarget = function(ct) {
    return this.__currentTarget = ct;
  };

  Event.prototype.getModifiers = function() {
    var k, mods, ref, v;
    mods = [];
    ref = {
      meta: "Meta",
      ctrl: "Control",
      alt: "Alt",
      shift: "Shift"
    };
    for (k in ref) {
      v = ref[k];
      if (this[k + "Key"]()) {
        mods.push(v);
      }
    }
    return mods;
  };

  Event.prototype.hasModifierKey = function(includeShift) {
    if (includeShift == null) {
      includeShift = false;
    }
    return this.metaKey() || this.ctrlKey() || this.altKey() || (includeShift && this.shiftKey());
  };

  Event.prototype.getButton = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.button : void 0;
  };

  Event.prototype.keyCode = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.which : void 0;
  };

  Event.prototype.metaKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.metaKey : void 0;
  };

  Event.prototype.ctrlKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.ctrlKey : void 0;
  };

  Event.prototype.altKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.altKey : void 0;
  };

  Event.prototype.shiftKey = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.shiftKey : void 0;
  };

  Event.prototype.clientX = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.clientX : void 0;
  };

  Event.prototype.clientY = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.clientY : void 0;
  };

  Event.prototype.pageX = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.pageX : void 0;
  };

  Event.prototype.pageY = function() {
    var ref;
    return (ref = this.getNativeEvent()) != null ? ref.pageY : void 0;
  };

  Event.prototype.stopImmediatePropagation = function() {
    var ref;
    this.__propagationImmediateStopped = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.stopImmediatePropagation();
    }
    return this;
  };

  Event.prototype.stopPropagation = function() {
    var ref;
    this.__propagationStopped = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.stopPropagation();
    }
    return this;
  };

  Event.prototype.preventDefault = function() {
    var ref;
    this.__defaultPrevented = true;
    if ((ref = this.getNativeEvent()) != null) {
      ref.preventDefault();
    }
    return this;
  };

  Event.prototype.isImmediatePropagationStopped = function() {
    return this.__propagationImmediateStopped;
  };

  Event.prototype.isPropagationStopped = function() {
    return this.__propagationStopped;
  };

  Event.prototype.isDefaultPrevented = function() {
    return this.__defaultPrevented;
  };

  Event.prototype.dispatch = function() {
    var ev, node;
    assert(!this.getNativeEvent(), "CUI.Event.dispatch", "Can only dispatch once.", {
      event: this
    });
    ev = document.createEvent("Event");
    ev.initEvent(this.getType(), this.isBubble(), true);
    ev.__cui_event = this;
    if (this.isExcludeSelf()) {
      node = DOM.parent(this.getNode());
    } else {
      node = this.getNode();
    }
    if (this.isDefaultPrevented()) {
      ev.preventDefault();
    }
    this.setNativeEvent(ev);
    node.dispatchEvent(ev);
    return ev;
  };

  Event.prototype.dump = function() {
    var mods, txt;
    txt = this.__cls + ": **" + this.getType() + "**";
    mods = this.getModifiers();
    if (mods.length > 0) {
      txt += " Modifiers: **" + mods.join("+") + "**";
    }
    return txt;
  };

  Event.prototype.stop = function() {
    this.preventDefault();
    this.stopPropagation();
    this.stopImmediatePropagation();
    return false;
  };

  Event.require = function(event, func) {
    var ev, ev_info, eventClass;
    if (CUI.isPlainObject(event)) {
      ev_info = Events.getEventType(event.type);
      if (ev_info.eventClass) {
        eventClass = ev_info.eventClass;
      } else {
        eventClass = CUI.Event;
      }
      CUI.mergeMap(event, ev_info);
      delete event.eventClass;
      delete event.listenerClass;
      ev = new eventClass(event);
    } else {
      ev = event;
    }
    assert(ev instanceof CUI.Event, "" + func, "event needs to be PlainObject or instance of CUI.Event.");
    return ev;
  };

  Event.createFromDOMEvent = function(event, eventClass) {
    var ev, ev_info;
    ev_info = CUI.Events.getEventType(event.type);
    if (!eventClass) {
      if (ev_info.eventClass) {
        eventClass = ev_info.eventClass;
      } else {
        eventClass = CUI.Event;
      }
    }
    ev = new eventClass({
      type: event.type,
      bubble: event.bubbles,
      node: event.target
    });
    ev.setNativeEvent(event);
    return ev;
  };

  return Event;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.MouseEvent = (function(superClass) {
  extend(MouseEvent, superClass);

  function MouseEvent() {
    return MouseEvent.__super__.constructor.apply(this, arguments);
  }

  MouseEvent.prototype.initOpts = function() {
    MouseEvent.__super__.initOpts.call(this);
    return this.addOpts({
      button: {
        check: function(v) {
          return v >= 0;
        }
      },
      pageX: {
        check: function(v) {
          return v > 0;
        }
      },
      pageY: {
        check: function(v) {
          return v > 0;
        }
      },
      clientX: {
        check: function(v) {
          return v > 0;
        }
      },
      clientY: {
        check: function(v) {
          return v > 0;
        }
      }
    });
  };

  MouseEvent.prototype.setNativeEvent = function(ev) {
    var i, k, len, prop, ref;
    ref = ["button", "pageX", "pageY", "clientX", "clientY"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      prop = "_" + k;
      if (this.hasOwnProperty(prop)) {
        ev[k] = this[prop];
      }
    }
    return MouseEvent.__super__.setNativeEvent.call(this, ev);
  };

  return MouseEvent;

})(CUI.Event);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.KeyboardEvent = (function(superClass) {
  extend(KeyboardEvent, superClass);

  function KeyboardEvent() {
    return KeyboardEvent.__super__.constructor.apply(this, arguments);
  }

  KeyboardEvent.prototype.getKeys = function() {
    return CUI.KeyboardEvent.__keys;
  };

  KeyboardEvent.prototype.getKeyboard = function() {
    var keys;
    keys = this.getModifiers();
    keys.push.apply(keys, this.getKeys());
    return keys.join("+");
  };

  KeyboardEvent.prototype.keyboardKey = function() {
    var key, s;
    key = this.keyCode();
    if (indexOf.call([96, 97, 98, 99, 100, 101, 102, 103, 104, 105], key) >= 0) {
      s = "Num" + String.fromCharCode(key - 48);
    }
    if (indexOf.call([112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123], key) >= 0) {
      s = "F" + String.fromCharCode(key - 111);
    } else {
      switch (key) {
        case 8:
          s = "Backspace";
          break;
        case 9:
          s = "Tab";
          break;
        case 13:
          s = "Return";
          break;
        case 16:
          s = "Shift";
          break;
        case 17:
          s = "Ctrl";
          break;
        case 18:
          s = "Alt";
          break;
        case 20:
          s = "CapsLock";
          break;
        case 27:
          s = "Esc";
          break;
        case 32:
          s = "Space";
          break;
        case 33:
          s = "PageUp";
          break;
        case 34:
          s = "PageDown";
          break;
        case 37:
          s = "Left";
          break;
        case 38:
          s = "Up";
          break;
        case 39:
          s = "Right";
          break;
        case 40:
          s = "Down";
          break;
        case 46:
          s = "Insert";
          break;
        case 46:
          s = "Delete";
          break;
        case 110:
          s = "Num.";
          break;
        case 144:
          s = "Numlock";
          break;
        case 111:
          s = "Num/";
          break;
        case 106:
          s = "Num*";
          break;
        case 107:
          s = "Num+";
          break;
        default:
          s = String.fromCharCode(key);
      }
    }
    console.debug(key, s);
    return s;
  };

  KeyboardEvent.prototype.key = function() {
    return this.getNativeEvent().key;
  };

  KeyboardEvent.prototype.dump = function() {
    var keyboard, txt;
    txt = this.__cls + ": **" + this.getType() + "**";
    txt += " Key: **" + this.key() + "** KeyCode: **" + this.keyCode() + "**";
    keyboard = this.getKeyboard();
    if (keyboard.length > 0) {
      txt = txt + " Keyboard: **" + keyboard + "**";
    }
    return txt;
  };

  KeyboardEvent.isModifierKey = function(keyCode) {
    switch (keyCode) {
      case 16:
      case 17:
      case 18:
      case 91:
      case 93:
        return true;
      default:
        return false;
    }
  };

  KeyboardEvent.initKeyboardListener = function() {
    CUI.KeyboardEvent.__keys = [];
    CUI.KeyboardEvent.__modifier_keys = [];
    Events.listen({
      type: ["keydown"],
      node: window,
      capture: true,
      call: function(ev) {
        console.debug("keyboard key:", ev.keyboardKey());
        if (!KeyboardEvent.isModifierKey(ev.keyCode())) {
          pushOntoArray(ev.keyboardKey(), CUI.KeyboardEvent.__keys);
        }
      }
    });
    Events.listen({
      type: ["keyup"],
      node: window,
      capture: true,
      call: function(ev) {
        if (!KeyboardEvent.isModifierKey(ev.keyCode())) {
          removeFromArray(ev.keyboardKey(), CUI.KeyboardEvent.__keys);
        }
      }
    });
    return Events.listen({
      type: ["blur"],
      node: window,
      capture: true,
      call: function(ev) {
        return CUI.KeyboardEvent.__keys = [];
      }
    });
  };

  return KeyboardEvent;

})(CUI.Event);

CUI.ready((function(_this) {
  return function() {
    return CUI.KeyboardEvent.initKeyboardListener();
  };
})(this));
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.CUIEvent = (function(superClass) {
  extend(CUIEvent, superClass);

  function CUIEvent() {
    return CUIEvent.__super__.constructor.apply(this, arguments);
  }

  return CUIEvent;

})(CUI.Event);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Listener = (function(superClass) {
  extend(Listener, superClass);

  function Listener() {
    return Listener.__super__.constructor.apply(this, arguments);
  }

  Listener.prototype.initOpts = function() {
    Listener.__super__.initOpts.call(this);
    return this.addOpts({
      type: {
        mandatory: true,
        check: function(v) {
          return isString(v) || CUI.isArray(v);
        }
      },
      node: {
        "default": document.documentElement,
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      call: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v);
        }
      },
      only_once: {
        check: Boolean
      },
      selector: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v);
        }
      },
      instance: {},
      capture: {
        "default": false,
        check: Boolean
      }
    });
  };

  Listener.prototype.readOpts = function() {
    var ev, i, len, ref, type;
    Listener.__super__.readOpts.call(this);
    if (isString(this._type)) {
      this.__types = this._type.split(/\s+/);
    } else {
      this.__types = this._type;
    }
    this.__node = CUI.DOM.getNode(this._node);
    ref = this.__types;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      ev = Events.getEventType(type);
    }
    if (isString(this._selector)) {
      assert(this.__node instanceof HTMLElement || this.__node === document, "new CUI.Listener", "opts.selector requires the node to be instance of HTMLElement.", {
        opts: this.opts
      });
    }
    this.__handleDOMEvent = (function(_this) {
      return function(ev) {
        return _this.handleDOMEvent(ev);
      };
    })(this);
    if (this._selector) {
      if (isString(this._selector)) {
        this.__selector = (function(_this) {
          return function(target, node) {
            return DOM.closestUntil(target, _this._selector, node);
          };
        })(this);
      } else {
        this.__selector = this._selector;
      }
    }
    this.registerDOMEvent();
    return this;
  };

  Listener.prototype.isCapture = function() {
    return this._capture;
  };

  Listener.prototype.getNode = function() {
    return this.__node;
  };

  Listener.prototype.getTypes = function() {
    return this.__types;
  };

  Listener.prototype.registerDOMEvent = function() {
    var _type, i, j, len, len1, ref, ref1, type;
    ref = this.getTypes();
    for (i = 0, len = ref.length; i < len; i++) {
      _type = ref[i];
      ref1 = Events.getEventTypeAliases(_type);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        type = ref1[j];
        this.__node.addEventListener(type, this.__handleDOMEvent, this.isCapture());
      }
    }
    return this;
  };

  Listener.prototype.handleDOMEvent = function(ev) {
    var currentTarget, event, ret;
    if (this.__selector) {
      currentTarget = this.__selector(ev.target, this.__node);
      if (!currentTarget) {
        return false;
      }
    } else {
      currentTarget = this.__node;
    }
    if (ev.__cui_event) {
      event = ev.__cui_event;
    } else {
      event = CUI.Event.createFromDOMEvent(ev);
      ev.__cui_event = event;
    }
    event.setCurrentTarget(currentTarget);
    if (this.isCapture()) {
      ret = this.handleEvent(event, "capture");
    } else {
      ret = this.handleEvent(event, "bubble");
    }
    return ret;
  };

  Listener.prototype.isOnlyOnce = function() {
    return this._only_once;
  };

  Listener.prototype.destroy = function() {
    var _type, i, j, len, len1, ref, ref1, type;
    if (this.isDestroyed()) {
      return;
    }
    Events.unregisterListener(this);
    ref = this.getTypes();
    for (i = 0, len = ref.length; i < len; i++) {
      _type = ref[i];
      ref1 = Events.getEventTypeAliases(_type);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        type = ref1[j];
        this.__node.removeEventListener(type, this.__handleDOMEvent, this.isCapture());
      }
    }
    return Listener.__super__.destroy.call(this);
  };

  Listener.prototype.matchesEvent = function(event) {
    var ev_node, i, len, parent, ref, ref1;
    assert(event instanceof CUI.Event, "CUI.Listener.matchesEvent", "event needs to be instance of CUI.Event.");
    delete this.__depth;
    if (ref = event.getType(), indexOf.call(this.getTypes(), ref) < 0) {
      return null;
    }
    ev_node = event.getNode();
    this.__depth = 0;
    if (this.isCapture()) {
      return null;
    }
    if (!event.isExcludeSelf() && !event.isBubble() && event.isInDOM()) {
      if (this.__node === ev_node) {
        return this.__depth;
      }
    }
    if (event.isSink()) {
      ref1 = DOM.parents(this.__node);
      for (i = 0, len = ref1.length; i < len; i++) {
        parent = ref1[i];
        this.__depth++;
        if (parent === ev_node) {
          return this.__depth;
        }
      }
    }
    delete this.__depth;
    return null;
  };

  Listener.prototype.getDepthFromLastMatchedEvent = function() {
    return this.__depth;
  };

  Listener.prototype.handleEvent = function(event, phase) {
    var info, ret;
    assert(event instanceof CUI.Event, "CUI.Listener.handleEvent", "event needs to be instance of CUI.Event", {
      event: event
    });
    event.setPhase(phase);
    event.setListener(this);
    if (this.isOnlyOnce()) {
      this.destroy();
    }
    ret = this._call.call(this, event, event.getInfo());
    event.progress(this, ret);
    if (isPromise(ret)) {
      info = event.getInfo();
      if (!info.__waits) {
        assert(false, "CUI.Listener.handleEvent", "Event \"" + (event.getType()) + "\" to handle was not triggered by CUI.Events.trigger, but instead by a regular DOMEvent.\n\nMake sure that, if your handler returns a Promise, the event is triggered by Events.trigger.", {
          event: event,
          listener: this,
          "return": ret
        });
      }
      info.__waits.push(ret);
    }
    return ret;
  };

  Listener.prototype.getInstance = function() {
    return this._instance;
  };

  Listener.prototype.matchesFilter = function(filter) {
    var filter_node, filtered, match, ref;
    if (filter instanceof CUI.Listener) {
      return filter === this;
    }
    assert(CUI.isPlainObject(filter), "CUI.Listener.matchesFilter", "filter needs to be PlainObject.");
    match = true;
    filtered = false;
    if (filter.node) {
      filter_node = DOM.getNode(filter.node);
      filtered = true;
      match = DOM.closestUntil(this.__node, filter_node);
    }
    if (match && filter.type) {
      filtered = true;
      match = (ref = filter.type, indexOf.call(this.__types, ref) >= 0);
    }
    if (match && filter.call) {
      filtered = true;
      match = filter.call === this._call;
    }
    if (match && filter.instance) {
      filtered = true;
      match = filter.instance === this.getInstance();
    }
    assert(filtered, "Listener.matchesFilter", "Filter did not filter anything, make sure you have 'node', 'type', 'call', or 'instance' set.", {
      filter: filter
    });
    return match;
  };

  Listener.require = function(listener, func) {
    var ev, i, len, listen, listenerFunc, type, types;
    if (CUI.isPlainObject(listener)) {
      listenerFunc = null;
      if (!(listener.type instanceof Array)) {
        types = [listener.type];
      } else {
        types = listener.type;
      }
      for (i = 0, len = types.length; i < len; i++) {
        type = types[i];
        ev = Events.getEventType(type);
        assert(ev, "" + func, "listener.type needs to be registered", {
          listener: listener
        });
        if (ev.listenerClass) {
          assert(!listenerFunc || listenerFunc === ev.listenerClass, "" + func, "listenerFunction differs for different listener types.", {
            listener: listener
          });
          listenerFunc = ev.listenerClass;
        } else {
          assert(!listenerFunc || listenerFunc === CUI.Listener, "" + func, "listenerFunction differs for different listener types.", {
            listener: listener
          });
          listenerFunc = CUI.Listener;
        }
      }
      listen = new listenerFunc(listener);
    } else {
      listen = listener;
    }
    assert(listen instanceof CUI.Listener, "" + func, "listener needs to be PlainObject or instance of CUI.Listener.");
    return listen;
  };

  return Listener;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.MouseIsDownEvent = (function(superClass) {
  extend(MouseIsDownEvent, superClass);

  function MouseIsDownEvent() {
    return MouseIsDownEvent.__super__.constructor.apply(this, arguments);
  }

  MouseIsDownEvent.prototype.readOpts = function() {
    MouseIsDownEvent.__super__.readOpts.call(this);
    return this.__preventNext = false;
  };

  MouseIsDownEvent.prototype.initOpts = function() {
    MouseIsDownEvent.__super__.initOpts.call(this);
    this.addOpts({
      ms: {
        mandatory: true,
        "default": 0,
        check: function(v) {
          return v >= 0;
        }
      },
      counter: {
        mandatory: true,
        check: function(v) {
          return v >= 0;
        }
      },
      mousedownEvent: {
        mandatory: true,
        check: function(v) {
          return v instanceof CUI.MouseEvent || v instanceof CUI.MouseIsDownEvent;
        }
      }
    });
    return this.mergeOpt("type", {
      check: function(v) {
        return v === "mouseisdown";
      }
    });
  };

  MouseIsDownEvent.prototype.getCounter = function() {
    return this._counter;
  };

  MouseIsDownEvent.prototype.getMilliseconds = function() {
    return this._ms;
  };

  MouseIsDownEvent.prototype.getMousedownEvent = function() {
    return this._mousedownEvent;
  };

  MouseIsDownEvent.prototype.preventNext = function() {
    return this.__preventNext = true;
  };

  MouseIsDownEvent.prototype.isNextPrevented = function() {
    return this.__preventNext;
  };

  MouseIsDownEvent.prototype.hasModifierKey = function(includeShift) {
    if (includeShift == null) {
      includeShift = false;
    }
    return this._mousedownEvent.hasModifierKey(includeShift);
  };

  MouseIsDownEvent.prototype.getButton = function() {
    return this._mousedownEvent.getButton();
  };

  MouseIsDownEvent.prototype.keyCode = function() {
    return this._mousedownEvent.keyCode();
  };

  MouseIsDownEvent.prototype.metaKey = function() {
    return this._mousedownEvent.metaKey();
  };

  MouseIsDownEvent.prototype.ctrlKey = function() {
    return this._mousedownEvent.ctrlKey();
  };

  MouseIsDownEvent.prototype.altKey = function() {
    return this._mousedownEvent.altKey();
  };

  MouseIsDownEvent.prototype.shiftKey = function() {
    return this._mousedownEvent.shiftKey();
  };

  MouseIsDownEvent.prototype.wheelDeltaX = function() {
    return this._mousedownEvent.wheelDeltaX();
  };

  MouseIsDownEvent.prototype.wheelDeltaY = function() {
    return this._mousedownEvent.wheelDeltaY();
  };

  MouseIsDownEvent.prototype.clientX = function() {
    return this._mousedownEvent.clientX();
  };

  MouseIsDownEvent.prototype.clientY = function() {
    return this._mousedownEvent.clientY();
  };

  MouseIsDownEvent.prototype.pageX = function() {
    return this._mousedownEvent.pageX();
  };

  MouseIsDownEvent.prototype.pageY = function() {
    return this._mousedownEvent.pageY();
  };

  MouseIsDownEvent.prototype.toHtml = function() {
    var html;
    html = MouseIsDownEvent.__super__.toHtml.call(this);
    return html += " <b>" + this.getMilliseconds() + "</b>ms";
  };

  return MouseIsDownEvent;

})(CUI.MouseEvent);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.MouseIsDownListener = (function(superClass) {
  extend(MouseIsDownListener, superClass);

  function MouseIsDownListener() {
    return MouseIsDownListener.__super__.constructor.apply(this, arguments);
  }

  MouseIsDownListener.prototype.initOpts = function() {
    MouseIsDownListener.__super__.initOpts.call(this);
    return this.addOpts({
      interval_ms: {
        "default": CUI.MouseIsDownListener.interval_ms,
        check: (function(_this) {
          return function(v) {
            return v > 10;
          };
        })(this)
      }
    });
  };

  MouseIsDownListener.interval_ms = 50;

  MouseIsDownListener.prototype.readOpts = function() {
    MouseIsDownListener.__super__.readOpts.call(this);
    this.__reset();
    return Events.listen({
      type: "mousedown",
      node: this.getNode(),
      instance: this,
      capture: true,
      call: (function(_this) {
        return function(ev) {
          var listen;
          if (ev.isImmediatePropagationStopped()) {
            return;
          }
          _this.__reset();
          _this.__mousedown_event = ev;
          listen = Events.listen({
            type: "mouseup",
            node: window,
            only_once: true,
            capture: true,
            call: function(ev) {
              return _this.__reset();
            }
          });
          _this.__triggerEvent();
        };
      })(this)
    });
  };

  MouseIsDownListener.prototype.destroy = function() {
    Events.ignore({
      instance: this
    });
    return MouseIsDownListener.__super__.destroy.call(this);
  };

  MouseIsDownListener.prototype.__reset = function() {
    if (this.__mouseisdown_interval) {
      CUI.clearTimeout(this.__mouseisdown_interval);
      this.__mouseisdown_interval = null;
    }
    this.__counter = 0;
    this.__mousedown_event = null;
    this.__last_triggered = null;
    return this;
  };

  MouseIsDownListener.prototype.__triggerEvent = function() {
    var ev, ref;
    if (this.__mousedown_event.isImmediatePropagationStopped() || ((ref = this.__last_triggered) != null ? ref.isNextPrevented() : void 0)) {
      return;
    }
    if (!CUI.DOM.isInDOM(this.__mousedown_event.getNode())) {
      this.__reset();
      return;
    }
    ev = CUI.Event.require({
      node: this.__mousedown_event.getNode(),
      type: "mouseisdown",
      bubble: true,
      ms: this.__counter * this._interval_ms,
      counter: this.__counter,
      mousedownEvent: this.__mousedown_event
    });
    CUI.Events.trigger(ev);
    this.__last_triggered = ev;
    return this.__scheduleNextEvent();
  };

  MouseIsDownListener.prototype.__scheduleNextEvent = function() {
    this.__counter++;
    if (this.__mouseisdown_interval) {
      CUI.clearTimeout(this.__mouseisdown_interval);
    }
    this.__mouseisdown_interval = CUI.setTimeout(((function(_this) {
      return function() {
        return _this.__triggerEvent();
      };
    })(this)), this._interval_ms, false);
    return this;
  };

  return MouseIsDownListener;

})(CUI.Listener);

CUI.ready((function(_this) {
  return function() {
    return CUI.Events.registerEvent({
      type: ["mouseisdown"],
      bubble: true,
      eventClass: CUI.MouseIsDownEvent,
      listenerClass: CUI.MouseIsDownListener
    });
  };
})(this));
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.WheelEvent = (function(superClass) {
  extend(WheelEvent, superClass);

  function WheelEvent() {
    return WheelEvent.__super__.constructor.apply(this, arguments);
  }

  WheelEvent.prototype.dump = function() {
    return WheelEvent.__super__.dump.call(this) + " wheelY: **" + this.wheelDeltaY() + "**";
  };

  WheelEvent.prototype.wheelDeltaY = function() {
    var ne;
    ne = this.getNativeEvent();
    if (!ne) {
      return 0;
    }
    return ne.deltaY || 0;
  };

  return WheelEvent;

})(CUI.MouseEvent);
// Generated by CoffeeScript 1.9.3
var Events,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Events = (function(superClass) {
  extend(Events, superClass);

  function Events() {
    return Events.__super__.constructor.apply(this, arguments);
  }

  Events.defaults = {
    maxWait: 1500
  };

  Events.__listeners = [];

  Events.__eventRegistry = {};

  Events.__getListenersForNode = function(node) {
    if (node === document || node === window) {
      return this.__listeners;
    } else {
      return DOM.data(node, "listeners");
    }
  };

  Events.__registerListener = function(listener) {
    var listeners, node;
    assert(listener instanceof CUI.Listener, "CUI.Events.__registerListener", "listener needs to be instance of Listener", {
      listener: listener
    });
    node = listener.getNode();
    listeners = this.__getListenersForNode(node);
    if (!listeners) {
      listeners = [];
      DOM.data(node, "listeners", listeners);
    }
    listeners.push(listener);
    if (node instanceof HTMLElement) {
      node.setAttribute("cui-events-listener-element", "cui-events-listener-element");
    }
    return this;
  };

  Events.getActiveListeners = function() {
    var el, j, len, listeners, ref;
    listeners = this.__listeners.slice(0);
    ref = CUI.DOM.matchSelector(document, "[cui-events-listener-element]");
    for (j = 0, len = ref.length; j < len; j++) {
      el = ref[j];
      listeners.push.apply(listeners, DOM.data(el, "listeners"));
    }
    return listeners;
  };

  Events.unregisterListener = function(listener) {
    var arr, node;
    node = listener.getNode();
    arr = this.__getListenersForNode(node);
    assert(arr, "CUI.Events.unregisterListeners", "Listeners not found for node.", {
      node: node,
      listener: listener
    });
    removeFromArray(listener, arr);
    if (arr.length === 0 && node instanceof HTMLElement) {
      node.removeAttribute("cui-events-listener-element");
      DOM.removeData(node, "listeners");
    }
    return this;
  };

  Events.wait = function(_opts) {
    var _node, dfr, dfrs, listeners, master_dfr, opts;
    opts = CUI.Element.readOpts(_opts, "Events.wait", {
      type: {
        mandatory: true,
        check: String
      },
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      maxWait: {
        "default": CUI.defaults["class"].Events.defaults.maxWait,
        check: function(v) {
          var i;
          i = parseInt(v);
          if (isNaN(i)) {
            return false;
          } else if (i === -1) {
            return true;
          } else if (i >= 0) {
            return true;
          } else {
            return false;
          }
        }
      }
    });
    dfrs = [];
    listeners = [];
    _node = DOM.getNode(opts.node);
    dfr = new CUI.Deferred();
    listeners.push(Events.listen({
      type: opts.type,
      node: _node,
      call: function() {
        dfr.resolve();
      }
    }));
    dfrs.push(dfr);
    master_dfr = new CUI.Deferred();
    master_dfr.always(function() {
      var j, len, listener;
      for (j = 0, len = listeners.length; j < len; j++) {
        listener = listeners[j];
        listener.destroy();
      }
    });
    CUI.when(dfrs).fail(function() {
      return master_dfr.reject();
    }).done(function() {
      return master_dfr.resolve();
    });
    if (opts.maxWait >= 0) {
      CUI.setTimeout(function() {
        var j, len;
        for (j = 0, len = dfrs.length; j < len; j++) {
          dfr = dfrs[j];
          if (dfr.state() === "pending") {
            dfr.reject();
          }
        }
      }, opts.maxWait);
    }
    return master_dfr.promise();
  };

  Events.listen = function(_listener) {
    var listener;
    listener = CUI.Listener.require(_listener, "CUI.Events.listen");
    this.__registerListener(listener);
    return listener;
  };

  Events.active = function(type) {
    var _type, j, k, l, len, len1, len2, llm, ln, ref, ref1, types;
    llm = {};
    ref = this.getActiveListeners();
    for (j = 0, len = ref.length; j < len; j++) {
      ln = ref[j];
      types = ln.getTypes();
      for (k = 0, len1 = types.length; k < len1; k++) {
        _type = types[k];
        if (!llm[_type]) {
          llm[_type] = [];
        }
        llm[_type].push(ln);
      }
    }
    if (type) {
      ref1 = llm[type];
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        ln = ref1[l];
        CUI.debug(type, ln.getNode()[0]);
      }
    } else {
      return Object.keys(llm).sort();
    }
  };

  Events.trigger = function(_event) {
    var bubble, ev_node, event, exclude, idx, info, j, k, l, len, len1, len2, len3, listener, listener_node, listener_node_parent, listener_node_parents, m, node, ref, ref1, sink, skip, stopNode, stopNodes, triggerListeners, waits;
    event = CUI.Event.require(_event, "CUI.Events.trigger");
    info = event.getInfo();
    waits = [];
    info.__waits = waits;
    bubble = event.isBubble();
    sink = event.isSink();
    exclude = event.isExcludeSelf();
    node = event.getNode();
    if (bubble || !event.isInDOM()) {
      event.dispatch();
    } else {
      event.setTarget(node);
    }
    if (exclude && !bubble && !sink) {
      assert(false, "CUI.Events.trigger", "Unable to trigger event with bubble == false, sink == false and exclude_self == true.", {
        event: event
      });
    }
    if (sink || (!sink && !bubble && !exclude && event.isInDOM())) {
      triggerListeners = [];
      ref = this.getActiveListeners();
      for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
        listener = ref[idx];
        if (ref1 = event.getType(), indexOf.call(listener.getTypes(), ref1) < 0) {
          continue;
        }
        if (listener.matchesEvent(event) === null) {
          continue;
        }
        triggerListeners.push(listener);
      }
      triggerListeners.sort(function(a, b) {
        return compareIndex(a.getDepthFromLastMatchedEvent(), b.getDepthFromLastMatchedEvent());
      });
      stopNodes = [];
      ev_node = event.getNode();
      for (k = 0, len1 = triggerListeners.length; k < len1; k++) {
        listener = triggerListeners[k];
        listener_node = listener.getNode();
        if (listener_node && stopNodes.length > 0) {
          listener_node_parents = DOM.parents(listener_node);
          skip = false;
          for (l = 0, len2 = stopNodes.length; l < len2; l++) {
            stopNode = stopNodes[l];
            for (m = 0, len3 = listener_node_parents.length; m < len3; m++) {
              listener_node_parent = listener_node_parents[m];
              if (listener_node_parent === stopNode) {
                skip = true;
                break;
              }
            }
          }
          if (skip) {
            continue;
          }
        }
        event.setCurrentTarget(listener_node);
        listener.handleEvent(event, "sink");
        if (event.isImmediatePropagationStopped()) {
          break;
        }
        if (event.isPropagationStopped() && listener_node) {
          stopNodes.push(listener_node[0]);
        }
      }
    }
    return CUI.when(waits);
  };

  Events.ignore = function(filter) {
    var j, len, listener, ref;
    ref = this.getActiveListeners();
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      if (!filter || CUI.isEmptyObject(filter) || listener.matchesFilter(filter)) {
        listener.destroy();
      }
    }
    return this;
  };

  Events.dump = function(filter) {
    var j, len, listener, ref;
    if (filter == null) {
      filter = {};
    }
    ref = this.getActiveListeners();
    for (j = 0, len = ref.length; j < len; j++) {
      listener = ref[j];
      if (listener.matchesFilter(filter)) {
        CUI.debug("Listener", listener.getTypes(), (listener.getNode() ? "NODE" : "-"), listener);
      }
    }
    return this;
  };

  Events.hasEventType = function(type) {
    return !!this.__eventRegistry[type];
  };

  Events.getEventType = function(type) {
    var ev;
    ev = this.__eventRegistry[type];
    assert(ev, "Unknown event type \"" + type + "\". Use Events.registerEvent to register this type.");
    return ev;
  };

  Events.getEventTypeAliases = function(type) {
    return this.getEventType(type).alias || [type];
  };

  Events.registerEvent = function(event, allow_array) {
    var j, k, len, len1, ref, ref1, register_other_type, type;
    if (allow_array == null) {
      allow_array = true;
    }
    if (!CUI.isArray(event.type) || !allow_array) {
      assert(isString(event != null ? event.type : void 0) && event.type.length > 0, "CUI.Events.registerEvent", "event.type must be String.", {
        event: event
      });
    }
    register_other_type = (function(_this) {
      return function(_type) {
        var _event;
        _event = copyObject(event, true);
        _event.type = _type;
        return _this.registerEvent(_event, false);
      };
    })(this);
    if (CUI.isArray(event.type)) {
      ref = event.type;
      for (j = 0, len = ref.length; j < len; j++) {
        type = ref[j];
        register_other_type(type);
      }
    } else {
      if (event.hasOwnProperty("DOMEvent")) {
        CUI.error("event.DOMEvent is obsolete");
        delete event.DOMEvent;
      }
      if (event.hasOwnProperty("CUIEvent")) {
        CUI.error("event.CUIEvent is obsolete");
        delete event.CUIEvent;
      }
      this.__eventRegistry[event.type] = event;
      if (event.alias) {
        ref1 = event.alias;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          type = ref1[k];
          if (!this.__eventRegistry[type]) {
            register_other_type(type);
          }
        }
      }
    }
    return this;
  };

  Events.init = function() {
    var block, defaults, ev, events, ref, results, type;
    defaults = {
      BrowserEvents: {
        bubble: true
      },
      DOM: {
        bubble: true
      },
      CUI: {
        eventClass: CUI.CUIEvent,
        sink: true
      },
      KeyboardEvents: {
        eventClass: CUI.KeyboardEvent,
        bubble: true
      },
      MouseEvents: {
        eventClass: CUI.MouseEvent,
        bubble: true
      }
    };
    ref = {
      MouseEvents: {
        mousemove: {},
        mouseover: {},
        mouseout: {},
        mouseleave: {},
        mouseenter: {},
        wheel: {
          eventClass: CUI.WheelEvent,
          bubble: false
        },
        mousedown: {},
        mouseup: {},
        click: {}
      },
      KeyboardEvents: {
        input: {
          bubble: false
        },
        keyup: {},
        keydown: {},
        keypress: {}
      },
      BrowserEvents: {
        beforeunload: {},
        unload: {},
        load: {},
        error: {},
        close: {},
        contextmenu: {},
        dragstart: {},
        dragover: {},
        dragleave: {},
        dragenter: {},
        message: {},
        fullscreenchange: {
          alias: "fullscreenchange mozfullscreenchange webkitfullscreenchange MSFullscreenChange".split(" ")
        },
        hashchange: {
          bubble: false
        },
        change: {
          bubble: false
        },
        focus: {
          bubble: false
        },
        blur: {
          bubble: false
        },
        paste: {
          bubble: false
        },
        dragover: {
          bubble: false
        },
        drop: {
          bubble: false
        },
        dblclick: {},
        scroll: {
          bubble: false
        },
        selectstart: {
          bubble: false
        },
        animationstart: {
          alias: "animationstart MSAnimationStart webkitAnimationStart".split(" "),
          bubble: false
        },
        animationend: {
          alias: "animationend MSAnimationEnd webkitAnimationEnd".split(" "),
          bubble: false
        },
        transitionend: {
          alias: "transitionend webkitTransitionEnd MSTransitionEnd".split(" "),
          bubble: false
        },
        resize: {
          bubble: false
        }
      },
      DOM: {
        "content-resize": {
          eventClass: CUI.CUIEvent
        }
      },
      CUI: {
        "viewport-resize": {}
      }
    };
    results = [];
    for (block in ref) {
      events = ref[block];
      results.push((function() {
        var results1;
        results1 = [];
        for (type in events) {
          ev = events[type];
          CUI.mergeMap(ev, defaults[block]);
          ev.type = type;
          results1.push(this.registerEvent(ev));
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  return Events;

})(CUI.Element);

CUI.Events.init();

Events = CUI.Events;

CUI.defaults["class"].Events = CUI.Events;
// Generated by CoffeeScript 1.9.3
var DOM,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DOM = (function(superClass) {
  extend(DOM, superClass);

  function DOM() {
    return DOM.__super__.constructor.apply(this, arguments);
  }

  DOM.prototype.initOpts = function() {
    DOM.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        "default": "",
        check: String
      }
    });
  };

  DOM.prototype.registerTemplate = function(template) {
    assert(template instanceof Template, (getObjectClass(this)) + ".registerDOMElement", "template must be instance of Template but is " + (getObjectClass(template)) + ".", {
      template: template
    });
    if (this.__template) {
      CUI.warn((getObjectClass(this)) + ".registerDOMElement", "Already called before, destroying existing template", {
        template: this.__template
      });
      this.__template.destroy();
    }
    this.__template = template;
    return this.registerDOMElement(this.__template.DOM);
  };

  DOM.prototype.getDOMElementClasses = function() {
    if (CUI.__ng__) {
      return "cui-dom-element cui-" + (toDash(this.__cls));
    } else {
      return "cui-dom-element cui-" + (toDash(this.__cls)) + " ez-" + (toDash(this.__cls));
    }
  };

  DOM.prototype.registerDOMElement = function(_dom) {
    this.DOM = _dom;
    CUI.DOM.addClass(this.DOM, this.getDOMElementClasses());
    CUI.DOM.setAttribute(this.DOM, "id", "cui-dom-element-" + this.getUniqueId());
    if (this._class) {
      CUI.DOM.addClass(this.DOM, this._class);
    }
    CUI.DOM.setElement(this.DOM, this);
    return this;
  };

  DOM.prototype.unregisterDOMElement = function(DOM1) {
    this.DOM = DOM1;
    CUI.removeClass(this.DOM, this.getDOMElementClasses());
    CUI.DOM.removeAttribute(this.DOM, "id");
    if (this._class) {
      CUI.DOM.removeClass(this.DOM, this._class);
    }
    DOM.removeData(this.DOM, "element");
    return this;
  };

  DOM.prototype.assertDOMElement = function(func) {
    return assert(this.DOM, this.__cls + "." + func, "registerDOMElement needs to be called before \"" + func + "\" is supported.");
  };

  DOM.prototype.assertTemplateElement = function(func) {
    return assert(this.__template, this.__cls + "." + func, "registerTemplateElement needs to be called before \"" + func + "\" is supported.");
  };

  DOM.prototype.addClass = function(cls) {
    assert(arguments.length === 1, "DOM.addClass", "Only one parameter allowed.");
    this.assertDOMElement("addClass");
    return CUI.DOM.addClass(this.DOM, cls);
  };

  DOM.prototype.removeClass = function(cls) {
    assert(arguments.length === 1, "DOM.removeClass", "Only one parameter allowed.");
    this.assertDOMElement("removeClass");
    return CUI.DOM.removeClass(this.DOM, cls);
  };

  DOM.prototype.hasClass = function(cls) {
    assert(arguments.length === 1, "DOM.hasClass", "Only one parameter allowed.");
    this.assertDOMElement("hasClass");
    return CUI.DOM.hasClass(this.DOM, cls);
  };

  DOM.prototype.isDestroyed = function(key) {
    var ref;
    return (ref = this.__template) != null ? ref.isDestroyed.call(this.__template, key) : void 0;
  };

  DOM.prototype.empty = function(key) {
    this.assertTemplateElement("empty");
    return this.__template.empty.call(this.__template, key);
  };

  DOM.prototype.replace = function(value, key) {
    this.assertTemplateElement("replace");
    return this.__template.replace.call(this.__template, value, key, this);
  };

  DOM.prototype.append = function(value, key) {
    this.assertTemplateElement("append");
    return this.__template.append.call(this.__template, value, key, this);
  };

  DOM.prototype.prepend = function(value, key) {
    this.assertTemplateElement("prepend");
    return this.__template.prepend.call(this.__template, value, key, this);
  };

  DOM.prototype.text = function(value, key) {
    this.assertTemplateElement("text");
    return this.__template.text.call(this.__template, value, key, this);
  };

  DOM.prototype.getFlexHandle = function(key, do_assert) {
    this.assertTemplateElement("getFlexHandle");
    return this.__template.getFlexHandle.call(this.__template, key, do_assert);
  };

  DOM.prototype.destroy = function() {
    var ref;
    DOM.__super__.destroy.call(this);
    if (this.__template) {
      if ((ref = this.__template) != null) {
        ref.destroy();
      }
    } else if (this.DOM) {
      DOM.remove(this.DOM);
    }
    return this;
  };

  DOM.setElement = function(element, inst) {
    CUI.jQueryCompat(element);
    return DOM.data(element, "element", inst);
  };

  DOM.data = function(node, key, data) {
    var k, ref, v;
    if (!node) {
      return void 0;
    }
    assert(node instanceof HTMLElement, "DOM.data", "node needs to be instance of HTMLElement", {
      node: node
    });
    if (key === void 0) {
      return node.__dom_data;
    }
    if (CUI.isPlainObject(key)) {
      for (k in key) {
        v = key[k];
        DOM.data(node, k, v);
      }
      return node;
    }
    if (data === void 0) {
      return (ref = node.__dom_data) != null ? ref[key] : void 0;
    }
    if (!node.__dom_data) {
      node.__dom_data = {};
    }
    node.__dom_data[key] = data;
    return node;
  };

  DOM.removeData = function(node, key) {
    if (!node) {
      return void 0;
    }
    if (node.__dom_data) {
      delete node.__dom_data[key];
      if (CUI.isEmptyObject(node.__dom_data)) {
        delete node.__dom_data;
      }
    }
    return DOM;
  };

  DOM.findElement = function(node, selector, nodeFilter, forward, siblingOnly) {
    var els;
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = false;
    }
    els = this.findElements(node, selector, nodeFilter, 1, forward, siblingOnly);
    if (els.length === 0) {
      return null;
    }
    return els[0];
  };

  DOM.findNextElement = function(node, selector, nodeFilter, forward, siblingOnly) {
    var el, sibling;
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = true;
    }
    el = this.findElement(node, selector, nodeFilter, forward, siblingOnly);
    if (el) {
      return el;
    }
    while (true) {
      node = node.parentNode;
      if (!node) {
        return null;
      }
      if (forward) {
        sibling = node.nextElementSibling;
      } else {
        sibling = node.previousElementSibling;
      }
      if (sibling) {
        break;
      }
    }
    return this.findNextElement(sibling, selector, nodeFilter, forward, false);
  };

  DOM.findPreviousElement = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findNextElement(node, selector, nodeFilter, false);
  };

  DOM.findNextVisibleElement = function(node, selector, forward) {
    if (forward == null) {
      forward = true;
    }
    return this.findNextElement(node, selector, ((function(_this) {
      return function(node) {
        return DOM.isVisible(node);
      };
    })(this)), forward);
  };

  DOM.findPreviousVisibleElement = function(node, selector) {
    return this.findNextVisibleElement(node, selector, false);
  };

  DOM.findNextSiblings = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findElements(node, selector, nodeFilter, null, true, true);
  };

  DOM.findPreviousSiblings = function(node, selector, nodeFilter) {
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    return this.findElements(node, selector, nodeFilter, null, false, true);
  };

  DOM.findElements = function(node, selector, nodeFilter, maxEls, forward, siblingOnly, elements) {
    var accept_node, check_node, child, sibling;
    if (node == null) {
      node = document.documentElement;
    }
    if (selector == null) {
      selector = null;
    }
    if (nodeFilter == null) {
      nodeFilter = false;
    }
    if (maxEls == null) {
      maxEls = null;
    }
    if (forward == null) {
      forward = true;
    }
    if (siblingOnly == null) {
      siblingOnly = false;
    }
    if (!elements) {
      assert(node instanceof HTMLElement, "DOM.findElement", "node needs to be instanceof HTMLElement.", {
        node: node,
        selector: selector
      });
      elements = [];
      check_node = !siblingOnly;
    } else {
      check_node = true;
    }
    accept_node = !nodeFilter || nodeFilter(node);
    if (check_node && accept_node) {
      if (selector === null || DOM.matches(node, selector)) {
        elements.push(node);
        if (elements.length === maxEls) {
          return elements;
        }
      } else {

      }
    }
    if (forward) {
      child = node.firstElementChild;
      sibling = node.nextElementSibling;
    } else {
      child = node.lastElementChild;
      sibling = node.previousElementSibling;
    }
    if (child && !siblingOnly && accept_node) {
      this.findElements(child, selector, nodeFilter, maxEls, forward, siblingOnly, elements);
      if (elements.length === maxEls) {
        return elements;
      }
    }
    if (sibling) {
      this.findElements(sibling, selector, nodeFilter, maxEls, forward, siblingOnly, elements);
      if (elements.length === maxEls) {
        return elements;
      }
    }
    return elements;
  };

  DOM.firstElementChild = function(node, nodeFilter) {
    var child;
    child = node.firstElementChild;
    while (true) {
      if (!nodeFilter || nodeFilter(child)) {
        return child;
      }
      child = child.nextElementSibling;
      if (!child) {
        return null;
      }
    }
  };

  DOM.children = function(node, filter) {
    var child, children, i, idx, len1, ref;
    children = [];
    ref = node.children;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      child = ref[idx];
      if (!filter || this.is(child, filter)) {
        children.push(child);
      }
    }
    return children;
  };

  DOM.lastElementChild = function(node, nodeFilter) {
    var child;
    child = node.lastElementChild;
    while (true) {
      if (!nodeFilter || nodeFilter(child)) {
        return child;
      }
      child = child.previousElementSibling;
      if (!child) {
        return null;
      }
    }
  };

  DOM.nextElementSibling = function(node, nodeFilter) {
    var sibling;
    while (true) {
      sibling = node.nextElementSibling;
      if (!nodeFilter || nodeFilter(child)) {
        return sibling;
      }
      if (!sibling) {
        return null;
      }
    }
  };

  DOM.previousElementSibling = function(node, nodeFilter) {
    var sibling;
    while (true) {
      sibling = node.previousElementSibling;
      if (!nodeFilter || nodeFilter(child)) {
        return sibling;
      }
      if (!sibling) {
        return null;
      }
    }
  };

  DOM.removeAttribute = function(node, key) {
    if (!node) {
      return null;
    }
    node.removeAttribute(key);
    return node;
  };

  DOM.setAttribute = function(node, key, value) {
    if (!node) {
      return null;
    }
    if (isNull(value) || value === false) {
      return this.removeAttribute(node, key);
    }
    if (value === true) {
      node.setAttribute(key, key);
    } else {
      node.setAttribute(key, value);
    }
    return node;
  };

  DOM.hasAttribute = function(node, key) {
    if (!node) {
      return false;
    }
    return node.hasAttribute(key);
  };

  DOM.setAttributeMap = function(node, map) {
    var key, value;
    if (!node) {
      return null;
    }
    for (key in map) {
      value = map[key];
      CUI.DOM.setAttribute(node, key, value);
    }
    return node;
  };

  DOM.width = function(docElem, value) {
    if (docElem === document || docElem === window) {
      if (value !== void 0) {
        assert(false, "DOM.width", "Unable to set width on a non HTMLElement", {
          docElem: docElem
        });
      }
      return window.innerWidth;
    }
    if (value === void 0) {
      return this.getDimension(docElem, "contentBoxWidth");
    } else {
      return this.setDimension(docElem, "contentBoxWidth", value);
    }
  };

  DOM.height = function(docElem, value) {
    if (docElem === document || docElem === window) {
      if (value !== void 0) {
        assert(false, "DOM.height", "Unable to set width on a non HTMLElement", {
          docElem: docElem
        });
      }
      return window.innerHeight;
    }
    if (value === void 0) {
      return this.getDimension(docElem, "contentBoxHeight");
    } else {
      return this.setDimension(docElem, "contentBoxHeight", value);
    }
  };

  DOM.__append = function(node, content, append) {
    var append_node, idx, len;
    if (append == null) {
      append = true;
    }
    if (isNull(content)) {
      return node;
    }
    if (CUI.isArray(content) || content instanceof HTMLCollection || content instanceof NodeList) {
      idx = 0;
      len = content.length;
      while (idx < len) {
        CUI.DOM.append(node, content[idx], append);
        if (len > content.length) {

        } else {
          idx++;
        }
        len = content.length;
      }
      return node;
    }
    switch (typeof content) {
      case "number":
      case "boolean":
        append_node = document.createTextNode(content + "");
        break;
      case "string":
        append_node = document.createTextNode(content);
        break;
      default:
        append_node = content;
    }
    if (append) {
      assert(append_node instanceof Node, "DOM.append", "Content needs to be instanceof Node, string, boolean, or number.", {
        node: content
      });
      node.appendChild(append_node);
    } else {
      assert(append_node instanceof Node, "DOM.prepend", "Content needs to be instanceof Node, string, boolean, or number.", {
        node: content
      });
      node.insertBefore(content, node.firstChild);
    }
    return node;
  };

  DOM.prepend = function(node, content) {
    return this.__append(node, content, false);
  };

  DOM.append = function(node, content) {
    return this.__append(node, content);
  };

  DOM.getById = function(uniqueId) {
    var dom_el;
    dom_el = document.getElementById("cui-dom-element-" + uniqueId);
    if (!dom_el) {
      return null;
    }
    return DOM.data(dom_el, "element");
  };

  DOM.getAttribute = function(node, key) {
    return node.getAttribute(key);
  };

  DOM.remove = function(element) {
    var ref;
    if (!element) {
      return null;
    }
    if ((ref = element.parentNode) != null) {
      ref.removeChild(element);
    }
    return element;
  };

  DOM.empty = function(element) {
    if (!element) {
      return null;
    }
    assert(isElement(element), "DOM.empty", "top needs to be Element", {
      element: element
    });
    element.innerHTML = "";
    return element;
  };

  DOM.hasClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!cls) {
      return null;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      if (element.classList.contains(_cls)) {
        return true;
      }
    }
    return false;
  };

  DOM.toggleClass = function(element, cls, on_off) {
    return this.setClass(element, cls, !this.hasClass(element, cls));
  };

  DOM.setClass = function(element, cls, on_off) {
    if (on_off) {
      this.addClass(element, cls);
    } else {
      this.removeClass(element, cls);
    }
    return on_off;
  };

  DOM.addClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!cls || !element) {
      return element;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      element.classList.add(_cls);
    }
    return element;
  };

  DOM.removeClass = function(element, cls) {
    var _cls, i, len1, ref;
    if (!cls || !element) {
      return element;
    }
    ref = cls.trim().split(/\s+/);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      _cls = ref[i];
      if (_cls === "") {
        continue;
      }
      element.classList.remove(_cls);
    }
    return element;
  };

  DOM.getRelativeOffset = function(node, untilElem, ignore_margin) {
    var dim, dim_node, margin_key_left, margin_key_top, offset, parent;
    if (untilElem == null) {
      untilElem = null;
    }
    if (ignore_margin == null) {
      ignore_margin = false;
    }
    assert(isElement(node), "CUI.DOM.getRelativePosition", "Node needs to HTMLElement.", {
      node: node
    });
    dim_node = CUI.DOM.getDimensions(node);
    parent = node.parentNode;
    if (ignore_margin) {
      margin_key_top = "viewportTop";
      margin_key_left = "viewportLeft";
    } else {
      margin_key_top = "viewportTopMargin";
      margin_key_left = "viewportLeftMargin";
    }
    while (true) {
      dim = CUI.DOM.getDimensions(parent);
      if (parent === document.body || parent === document.documentElement || parent === document) {
        offset = {
          parent: parent,
          top: dim_node[margin_key_top] + document.body.scrollTop,
          left: dim_node[margin_key_left] + document.body.scrollLeft
        };
        break;
      }
      if (dim.canHaveScrollbar || parent === node.offsetParent || parent === untilElem) {
        offset = {
          parent: parent,
          top: dim_node[margin_key_top] - (dim.viewportTop + dim.borderTop) + dim.scrollTop,
          left: dim_node[margin_key_left] - (dim.viewportLeft + dim.borderTop) + dim.scrollLeft
        };
        break;
      }
      parent = parent.parentNode;
    }
    return offset;
  };

  DOM.hasAnimatedClone = function(node) {
    return !!node.__clone;
  };

  DOM.initAnimatedClone = function(node, selector) {
    var clone, clone_child, dim, div, i, idx, len1, offset, ref, watched_nodes;
    this.removeAnimatedClone(node);
    clone = node.cloneNode(true);
    node.__clone = clone;
    if (selector) {
      watched_nodes = CUI.DOM.matchSelector(node, selector);
      clone.__watched_nodes = CUI.DOM.matchSelector(clone, selector);
    } else {
      watched_nodes = CUI.DOM.children(node);
      clone.__watched_nodes = CUI.DOM.children(clone);
    }
    offset = CUI.DOM.getRelativeOffset(node);
    if (!CUI.DOM.isPositioned(offset.parent)) {
      node.__parent_saved_position = offset.parent.style.position;
      offset.parent.style.position = "relative";
    }
    CUI.DOM.setStyle(clone, {
      position: "absolute",
      "pointer-events": "none",
      top: offset.top,
      left: offset.left
    });
    node.style.opacity = "0";
    dim = DOM.getDimensions(node);
    CUI.DOM.addClass(clone, "cui-dom-animated-clone cui-debug-node-copyable");
    div = CUI.DOM.element("div", {
      style: "position: absolute; opacity: 0; width: 1px; height: 1px;"
    });
    clone.appendChild(div);
    CUI.DOM.insertAfter(node, clone);
    CUI.DOM.setDimension(clone, "marginBoxWidth", dim.marginBoxWidth);
    CUI.DOM.setDimension(clone, "marginBoxHeight", dim.marginBoxHeight);
    ref = clone.__watched_nodes;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      clone_child = ref[idx];
      clone_child.__watched_node = watched_nodes[idx];
      CUI.DOM.setStyle(clone_child, {
        position: "absolute",
        margin: 0
      });
    }
    this.syncAnimatedClone(node);
    node.__clone.__syncScroll = (function(_this) {
      return function() {
        div.style.top = (node.scrollHeight - 1) + "px";
        div.style.left = (node.scrollWidth - 1) + "px";
        clone.scrollTop = node.scrollTop;
        return clone.scrollLeft = node.scrollLeft;
      };
    })(this);
    Events.listen({
      type: "scroll",
      instance: clone,
      node: node,
      call: (function(_this) {
        return function() {
          return node.__clone.__syncScroll();
        };
      })(this)
    });
    node.__clone.__syncScroll();
    return node;
  };

  DOM.syncAnimatedClone = function(node) {
    var child, clone, clone_child, i, idx, len1, offset_new, ref;
    clone = node.__clone;
    if (!clone) {
      return;
    }
    ref = clone.__watched_nodes;
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      clone_child = ref[idx];
      child = clone_child.__watched_node;
      offset_new = this.getRelativeOffset(child, node, true);
      CUI.DOM.setStyle(clone_child, {
        top: offset_new.top,
        left: offset_new.left
      });
    }
    return node;
  };

  DOM.removeAnimatedClone = function(node) {
    if (node.hasOwnProperty("__parent_saved_position")) {
      node.style.position = node.__parent_saved_position || "";
      delete node.__parent_saved_position;
    }
    if (!node.__clone) {
      return;
    }
    Events.ignore({
      instance: node.__clone
    });
    node.style.opacity = "";
    node.__clone.remove();
    delete node.__clone;
    return node;
  };

  DOM.setAbsolutePosition = function(element, offset) {
    var correct_offset, dim, layer_parent_offset, offsetParent;
    assert(isElement(element), "DOM.setAbsolutePosition", "element needs to be a jQuery element", {
      element: element,
      offset: offset
    });
    assert(isNumber(offset != null ? offset.left : void 0) && isNumber(offset != null ? offset.top : void 0), "DOM.setAbsolutePosition", "offset.left and offset.top must be >= 0", {
      element: element,
      offset: offset
    });
    offsetParent = element.offsetParent;
    if (offsetParent === document.documentElement) {
      layer_parent_offset = {
        top: 0,
        left: 0
      };
      correct_offset = {
        top: document.body.scrollTop,
        left: document.body.scrollLeft
      };
    } else {
      dim = DOM.getDimensions(offsetParent);
      layer_parent_offset = {
        top: dim.top,
        left: dim.left
      };
      layer_parent_offset.top += dim.borderTopWidth;
      layer_parent_offset.left += dim.borderLeftWidth;
      correct_offset = {
        top: dim.scrollTop,
        left: dim.scrollLeft
      };
    }
    element.css({
      top: offset.top - layer_parent_offset.top + correct_offset.top,
      left: offset.left - layer_parent_offset.left + correct_offset.left
    });
    return this;
  };

  DOM.__failedDOMInserts = 0;

  DOM.waitForDOMRemove = function(_opts) {
    var check_in_dom, dfr, node, opts;
    opts = CUI.Element.readOpts(_opts, "DOM.waitForDOMRemove", {
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      },
      ms: {
        "default": 200,
        check: function(v) {
          return v > 0;
        }
      }
    });
    node = DOM.getNode(opts.node);
    dfr = new CUI.Deferred();
    check_in_dom = (function(_this) {
      return function() {
        if (!CUI.DOM.isInDOM(node)) {
          dfr.resolve();
          return;
        }
        return CUI.setTimeout({
          call: check_in_dom,
          ms: opts.ms,
          track: false
        });
      };
    })(this);
    check_in_dom();
    return dfr.promise();
  };

  DOM.waitForDOMInsert = function(_opts) {
    var dfr, i, len1, node, opts, prefix, ref, timeout;
    opts = CUI.Element.readOpts(_opts, "DOM.waitForDOMInsert", {
      node: {
        mandatory: true,
        check: function(v) {
          return DOM.isNode(v);
        }
      }
    });
    node = DOM.getNode(opts.node);
    if (CUI.DOM.isInDOM(node)) {
      return CUI.resolvedPromise(true);
    }
    ref = ["-webkit-", "-moz-", "-ms-", "-o-", ""];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      prefix = ref[i];
      DOM.setStyleOne(node, prefix + "animation-duration", "0.001s");
      DOM.setStyleOne(node, prefix + "animation-name", "nodeInserted");
    }
    timeout = null;
    dfr = new CUI.Deferred();
    Events.wait({
      node: node,
      type: "animationstart",
      maxWait: -1
    }).done((function(_this) {
      return function() {
        var c, check_for_node, tries;
        if (DOM.isInDOM(node)) {
          dfr.resolve();
          return;
        }
        c = _this.__failedDOMInserts++;
        console.warn("[#" + c + "] Element received animationstart event but is not in DOM yet. We poll with timeout 0.");
        tries = 0;
        check_for_node = function() {
          if (DOM.isInDOM(node)) {
            console.warn("[#" + c + "] Poll done, element is in DOM now.");
            return dfr.resolve();
          } else if (tries < 10) {
            console.warn("[#" + c + "] Checking for node failed, try: ", tries);
            tries = tries + 1;
            return CUI.setTimeout(check_for_node, 0);
          } else {
            return console.error("[#" + c + "] Checking for node failed. Giving up.", node);
          }
        };
        return CUI.setTimeout(check_for_node, 0);
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  DOM.getNode = function(node) {
    if (node.DOM && node !== window) {
      return node.DOM;
    } else {
      return node;
    }
  };

  DOM.printElement = function(_opts) {
    var cls, docElem, href, i, j, len1, len2, new_node, opts, ref, ref1, style_node, win;
    opts = CUI.Element.readOpts(_opts, "DOM.printElement", {
      docElem: {
        check: function(v) {
          return v instanceof HTMLElement;
        }
      },
      title: {
        "default": "CUI-Print-Window",
        check: String
      },
      windowName: {
        "default": "_blank",
        check: String
      },
      windowFeatures: {
        "default": "width=400,height=800",
        check: String
      },
      bodyClasses: {
        "default": [],
        check: Array
      }
    });
    if (opts.docElem === document.documentElement) {
      docElem = document.body;
    } else {
      docElem = opts.docElem;
    }
    win = window.open("", opts.windowName, opts.windowFeatures);
    if (!isEmpty(opts.title)) {
      win.document.title = opts.title;
    }
    ref = DOM.matchSelector(document.head, "link[rel='stylesheet']");
    for (i = 0, len1 = ref.length; i < len1; i++) {
      style_node = ref[i];
      new_node = style_node.cloneNode(true);
      href = ez5.getAbsoluteURL(new_node.getAttribute("href"));
      new_node.setAttribute("href", href);
      console.debug("cloning css node for href", href);
      win.document.head.appendChild(new_node);
    }
    win.document.body.innerHTML = docElem.outerHTML;
    win.document.body.classList.add("cui-dom-print-element");
    ref1 = opts.bodyClasses;
    for (j = 0, len2 = ref1.length; j < len2; j++) {
      cls = ref1[j];
      win.document.body.classList.add(cls);
    }
    return win.print();
  };

  DOM.isNode = function(node) {
    if (node === document.documentElement || node === window || node === document || node.nodeType || node.DOM) {
      return true;
    } else {
      return false;
    }
  };

  DOM.insertChildAtPosition = function(node, node_insert, pos) {
    assert(isInteger(pos) && pos >= 0 && pos <= node.children.length, "CUI.DOM.insertAtPosition", "Unable to insert node at position #" + pos + ".", {
      node: node,
      node_insert: node_insert,
      pos: pos
    });
    if (pos === node.children.length) {
      return node.appendChild(node_insert);
    } else if (node.children[pos] !== node_insert) {
      return this.insertBefore(node.children[pos], node_insert);
    }
  };

  DOM.insertBefore = function(node, node_before) {
    if (node_before) {
      node.parentNode.insertBefore(node_before, node);
    }
    return node;
  };

  DOM.insertAfter = function(node, node_after) {
    if (node_after) {
      node.parentNode.insertBefore(node_after, node.nextElementSibling);
    }
    return node;
  };

  DOM.is = function(node, selector) {
    if (!node) {
      return null;
    }
    if (selector instanceof HTMLElement) {
      return node === selector;
    }
    if (CUI.isFunction(selector)) {
      return !!selector(node);
    }
    if (!(node instanceof HTMLElement)) {
      return null;
    }
    return this.matches(node, selector);
  };

  DOM.matches = function(node, selector) {
    if (!node) {
      return null;
    }
    return node[CUI.DOM.matchFunc](selector);
  };

  DOM.matchFunc = (function() {
    var d, i, k, len1, ref;
    d = document.createElement("div");
    ref = ["matches", "webkitMatchesSelector", "mozMatchesSelector", "oMatchesSelector", "msMatchesSelector"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (d[k]) {
        return k;
      }
    }
    return assert(false, "Could not determine match function on docElem");
  })();

  DOM.find = function(sel) {
    return this.matchSelector(document.documentElement, sel);
  };

  DOM.matchSelector = function(docElem, sel, trySelf) {
    var list;
    if (trySelf == null) {
      trySelf = false;
    }
    assert(docElem instanceof HTMLElement || docElem === document, "CUI.DOM.matchSelector", "docElem needs to be instanceof HTMLElement or document.", {
      docElem: docElem
    });
    list = docElem.querySelectorAll(sel);
    if (trySelf && list.length === 0) {
      if (docElem[CUI.DOM.matchFunc](sel)) {
        list = [docElem];
      } else {
        list = [];
      }
    }
    return list;
  };

  DOM.elementsUntil = function(docElem, selector, untilDocElem) {
    var path, testDocElem;
    assert(docElem instanceof HTMLElement || docElem === document || docElem === window, "CUI.DOM.elementsUntil", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem,
      selector: selector,
      untilDocElem: untilDocElem
    });
    testDocElem = docElem;
    path = [testDocElem];
    while (true) {
      if (selector && this.is(testDocElem, selector)) {
        return path;
      }
      if (testDocElem === untilDocElem) {
        if (selector) {
          return null;
        } else {
          return path;
        }
      }
      testDocElem = CUI.DOM.parent(testDocElem);
      if (testDocElem === null) {
        if (selector) {
          return null;
        } else {
          return path;
        }
      }
      path.push(testDocElem);
    }
    return null;
  };

  DOM.parent = function(docElem) {
    if (docElem === window) {
      return null;
    } else if (docElem === document) {
      return window;
    } else {
      return docElem.parentNode;
    }
  };

  DOM.closest = function(docElem, selector) {
    return this.closestUntil(docElem, selector);
  };

  DOM.closestUntil = function(docElem, selector, untilDocElem) {
    var path;
    if (!selector) {
      return null;
    }
    path = this.elementsUntil(docElem, selector, untilDocElem);
    if (path === null || path.length === 0) {
      return null;
    }
    return path[path.length - 1];
  };

  DOM.parentsUntil = function(docElem, selector, untilDocElem) {
    var parentElem, path;
    if (untilDocElem == null) {
      untilDocElem = document.documentElement;
    }
    parentElem = CUI.DOM.parent(docElem);
    if (!parentElem) {
      return [];
    }
    path = this.elementsUntil(parentElem, selector, untilDocElem);
    if (!(path != null ? path.length : void 0)) {
      return [];
    }
    return path;
  };

  DOM.parents = function(docElem, selector) {
    var i, len1, parent, parents, path;
    assert(docElem instanceof HTMLElement || docElem === document || docElem === window, "CUI.DOM.parents", "element needs to be instanceof HTMLElement, document, or window.", {
      element: docElem
    });
    path = this.parentsUntil(docElem);
    if (!selector) {
      return path;
    }
    parents = [];
    for (i = 0, len1 = path.length; i < len1; i++) {
      parent = path[i];
      if (this.is(parent, selector)) {
        parents.push(parent);
      }
    }
    return parents;
  };

  DOM.isInDOM = function(docElem) {
    if (!docElem) {
      return null;
    }
    assert(docElem instanceof HTMLElement, "CUI.DOM.isInDOM", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem
    });
    if (this.closestUntil(docElem, document.documentElement)) {
      return true;
    } else {
      return false;
    }
  };

  DOM.replaceWith = function(node, new_node) {
    assert(node instanceof HTMLElement && new_node instanceof HTMLElement, "CUI.DOM.replaceWidth", "nodes need to be instanceof HTMLElement.", {
      node: node,
      newNode: node
    });
    return node.parentNode.replaceChild(new_node, node);
  };

  DOM.getRect = function(docElem) {
    return docElem.getBoundingClientRect();
  };

  DOM.getComputedStyle = function(docElem) {
    return window.getComputedStyle(docElem);
  };

  DOM.setStyle = function(docElem, style, append) {
    var k, v;
    if (append == null) {
      append = "px";
    }
    assert(docElem instanceof HTMLElement, "CUI.DOM.setStyle", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem
    });
    for (k in style) {
      v = style[k];
      switch (v) {
        case "":
        case null:
          docElem.style[k] = "";
          break;
        default:
          if (isNaN(Number(v))) {
            docElem.style[k] = v;
          } else if (v === 0 || v === "0") {
            docElem.style[k] = 0;
          } else {
            docElem.style[k] = v + append;
          }
      }
    }
    return docElem;
  };

  DOM.setStyleOne = function(docElem, key, value) {
    var map;
    map = {};
    map[key] = value;
    return this.setStyle(docElem, map);
  };

  DOM.setStylePx = function(docElem, style) {
    console.error("DOM.setStylePx is deprectaed, use DOM.setStyle.");
    return this.setStyle(docElem, style);
  };

  DOM.getRelativePosition = function(docElem) {
    var dim;
    assert(docElem instanceof HTMLElement, "CUI.DOM.getRelativePosition", "docElem needs to be instanceof HTMLElement.", {
      docElem: docElem
    });
    dim = CUI.DOM.getDimensions(docElem);
    return {
      top: dim.offsetTopScrolled,
      left: dim.offsetLeftScrolled
    };
  };

  DOM.getDimensions = function(docElem) {
    var cs, dim, dim_key, i, j, k, k1, k2, l, len1, len2, len3, len4, len5, len6, m, n, o, rect, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
    if (isNull(docElem)) {
      return null;
    }
    if (docElem === window || docElem === document) {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }
    cs = this.getComputedStyle(docElem);
    rect = this.getRect(docElem);
    dim = {
      computedStyle: cs,
      clientBoundingRect: rect
    };
    ref = ["margin", "padding", "border"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k1 = ref[i];
      ref1 = ["Top", "Right", "Bottom", "Left"];
      for (j = 0, len2 = ref1.length; j < len2; j++) {
        k2 = ref1[j];
        dim_key = k1 + k2;
        switch (k1) {
          case "border":
            dim[dim_key] = this.getCSSFloatValue(cs["border" + k2 + "Width"]);
            break;
          default:
            dim[dim_key] = this.getCSSFloatValue(cs[dim_key]);
        }
      }
      dim[k1 + "Vertical"] = dim[k1 + "Top"] + dim[k1 + "Bottom"];
      dim[k1 + "Horizontal"] = dim[k1 + "Left"] + dim[k1 + "Right"];
    }
    dim.contentBoxWidth = Math.max(0, rect.width - dim.borderHorizontal - dim.paddingHorizontal);
    dim.contentBoxHeight = Math.max(0, rect.height - dim.borderVertical - dim.paddingVertical);
    dim.innerBoxWidth = Math.max(0, rect.width - dim.borderHorizontal);
    dim.innerBoxHeight = Math.max(0, rect.height - dim.borderVertical);
    dim.borderBoxWidth = rect.width;
    dim.borderBoxHeight = rect.height;
    dim.marginBoxWidth = Math.max(0, rect.width + dim.marginHorizontal);
    dim.marginBoxHeight = Math.max(0, rect.height + dim.marginVertical);
    dim.viewportTop = rect.top;
    dim.viewportTopMargin = rect.top - dim.marginTop;
    dim.viewportLeft = rect.left;
    dim.viewportLeftMargin = rect.left - dim.marginLeft;
    dim.viewportBottom = rect.bottom;
    dim.viewportBottomMargin = rect.bottom + dim.marginBottom;
    dim.viewportRight = rect.right;
    dim.viewportRightMargin = rect.right + dim.marginRight;
    dim.viewportCenterTop = rect.top + ((rect.bottom - rect.top) / 2);
    dim.viewportCenterLeft = rect.left + ((rect.right - rect.left) / 2);
    ref2 = ["left", "top", "minWidth", "minHeight", "maxWidth", "maxHeight", "marginRight", "marginLeft", "marginTop", "marginBottom", "borderTopWidth", "borderLeftWidth", "borderBottomWidth", "borderRightWidth"];
    for (l = 0, len3 = ref2.length; l < len3; l++) {
      k = ref2[l];
      dim[k] = this.getCSSFloatValue(cs[k]);
    }
    ref3 = ["offsetWidth", "offsetHeight", "offsetTop", "offsetLeft", "clientWidth", "clientHeight", "scrollWidth", "scrollHeight", "scrollLeft", "scrollTop"];
    for (m = 0, len4 = ref3.length; m < len4; m++) {
      k = ref3[m];
      dim[k] = docElem[k];
    }
    dim.scaleX = dim.borderBoxWidth / dim.offsetWidth || 1;
    dim.scaleY = dim.borderBoxHeight / dim.offsetHeight || 1;
    if (docElem.offsetParent) {
      dim.offsetTopScrolled = dim.offsetTop + docElem.offsetParent.scrollTop;
      dim.offsetLeftScrolled = dim.offsetLeft + docElem.offsetParent.scrollLeft;
    } else {
      dim.offsetTopScrolled = dim.offsetTop + document.body.scrollTop;
      dim.offsetLeftScrolled = dim.offsetLeft + document.body.scrollLeft;
    }
    ref4 = ["offsetWidth", "offsetLeft", "clientWidth", "scrollWidth", "scrollLeft"];
    for (n = 0, len5 = ref4.length; n < len5; n++) {
      k = ref4[n];
      dim[k + "Scaled"] = dim[k] * dim.scaleX;
    }
    ref5 = ["offsetHeight", "offsetTop", "clientHeight", "scrollHeight", "scrollTop"];
    for (o = 0, len6 = ref5.length; o < len6; o++) {
      k = ref5[o];
      dim[k + "Scaled"] = dim[k] * dim.scaleY;
    }
    if (dim.scrollHeight > dim.clientHeight) {
      dim.hasVerticalScrollbar = true;
      dim.verticalScrollbarWidth = dim.contentBoxWidth - dim.clientWidth;
    } else {
      dim.verticalScrollbarWidth = 0;
    }
    if (dim.scrollWidth > dim.clientWidth) {
      dim.hasHorizontalScrollbar = true;
      dim.horizontalScrollbarHeight = dim.contentBoxHeight - dim.clientHeight;
    } else {
      dim.horizontalScrollbarHeight = 0;
    }
    dim.hasScrollbar = dim.hasVerticalScrollbar || dim.hasHorizontalScrollbar;
    dim.canHaveScrollbar = ((ref6 = cs.overflowX) === "auto" || ref6 === "scroll") || ((ref7 = cs.overflowY) === "auto" || ref7 === "scroll");
    dim.horizontalScrollbarAtStart = dim.scrollLeft === 0;
    dim.horizontalScrollbarAtEnd = dim.scrollWidth - dim.scrollLeft - dim.clientWidth - dim.verticalScrollbarWidth < 1;
    dim.verticalScrollbarAtStart = dim.scrollTop === 0;
    dim.verticalScrollbarAtEnd = dim.scrollHeight - dim.scrollTop - dim.clientHeight - dim.horizontalScrollbarHeight < 1;
    dim.viewportTopContent = rect.top + dim.borderTop + dim.paddingTop;
    dim.viewportLeftContent = rect.left + dim.borderLeft + dim.paddingLeft;
    dim.viewportBottomContent = rect.bottom - dim.borderBottom - Math.max(dim.paddingBottom, dim.horizontalScrollbarHeight);
    dim.viewportRightContent = rect.right - dim.borderRight - Math.max(dim.paddingRight, dim.verticalScrollbarWidth);
    dim.viewportTopInner = rect.top + dim.borderTop;
    dim.viewportLeftInner = rect.left + dim.borderLeft;
    dim.viewportBottomInner = rect.bottom - dim.borderBottom - dim.horizontalScrollbarHeight;
    dim.viewportRightInner = rect.right - dim.borderRight - dim.verticalScrollbarWidth;
    return dim;
  };

  DOM.parentsScrollable = function(node) {
    var dim, i, idx, len1, parent, parents, ref;
    parents = [];
    ref = DOM.parents(node);
    for (idx = i = 0, len1 = ref.length; i < len1; idx = ++i) {
      parent = ref[idx];
      dim = DOM.getDimensions(parent);
      if (dim.canHaveScrollbar) {
        parents.push(parent);
      }
    }
    return parents;
  };

  DOM.setDimension = function(docElem, key, value) {
    var set;
    set = {};
    set[key] = value;
    return this.setDimensions(docElem, set);
  };

  DOM.getDimension = function(docElem, key) {
    return this.getDimensions(docElem)[key];
  };

  DOM.setDimensions = function(docElem, _dim) {
    var borderBox, css, cssFloat, dim, i, k, left_over_keys, len1, ref, set, set_dim;
    borderBox = this.isBorderBox(docElem);
    css = {};
    dim = this.getDimensions(docElem);
    set_dim = copyObject(_dim);
    cssFloat = {};
    set = (function(_this) {
      return function(key, value) {
        if (isNull(value) || isNaN(value)) {
          return;
        }
        if (!cssFloat.hasOwnProperty(key)) {
          if ((key === "width" || key === "height") && value < 0) {
            value = 0;
          }
          cssFloat[key] = value;
          return;
        }
        assert(cssFloat[key] === value, "DOM.setDimensions", "Unable to set contradicting values for " + key + ".", {
          docElem: docElem,
          dim: set_dim
        });
      };
    })(this);
    ref = ["width", "height", "left", "top"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (set_dim.hasOwnProperty(k)) {
        set(k, set_dim[k]);
        delete set_dim[k];
      }
    }
    if (set_dim.hasOwnProperty("contentBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.contentBoxWidth + dim.paddingHorizontal + dim.borderHorizontal);
      } else {
        set("width", set_dim.contentBoxWidth);
      }
      delete set_dim.contentBoxWidth;
    }
    if (set_dim.hasOwnProperty("contentBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.contentBoxHeight + dim.paddingVertical + dim.borderVertical);
      } else {
        set("height", set_dim.contentBoxHeight);
      }
      delete set_dim.contentBoxHeight;
    }
    if (set_dim.hasOwnProperty("borderBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.borderBoxWidth);
      } else {
        set("width", set_dim.borderBoxWidth - dim.paddingHorizontal - dim.borderHorizontal);
      }
      delete set_dim.borderBoxWidth;
    }
    if (set_dim.hasOwnProperty("borderBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.borderBoxHeight);
      } else {
        set("height", set_dim.borderBoxHeight - dim.paddingVertical - dim.borderVertical);
      }
      delete set_dim.borderBoxHeight;
    }
    if (set_dim.hasOwnProperty("marginBoxWidth")) {
      if (borderBox) {
        set("width", set_dim.marginBoxWidth - dim.marginHorizontal);
      } else {
        set("width", set_dim.marginBoxWidth - dim.marginHorizontal - dim.paddingHorizontal - dim.borderHorizontal);
      }
      delete set_dim.marginBoxWidth;
    }
    if (set_dim.hasOwnProperty("marginBoxHeight")) {
      if (borderBox) {
        set("height", set_dim.marginBoxHeight - dim.marginVertical);
      } else {
        set("height", set_dim.marginBoxHeight - dim.marginVertical - dim.paddingVertical - dim.borderHorizontal);
      }
      delete set_dim.marginBoxHeight;
    }
    left_over_keys = Object.keys(set_dim);
    assert(left_over_keys.length === 0, "DOM.setDimensions", "Unknown keys in dimension: \"" + left_over_keys.join("\", \"") + "\".", {
      docElem: docElem,
      dim: _dim
    });
    this.setStyle(docElem, cssFloat);
    return cssFloat;
  };

  DOM.htmlToNodes = function(html) {
    var d;
    d = this.element("DIV");
    d.innerHTML = html;
    return d.childNodes;
  };

  DOM.getCSSFloatValue = function(v) {
    var fl;
    if (v.indexOf("px") === -1) {
      return 0;
    }
    fl = parseFloat(v.substr(0, v.length - 2));
    return fl;
  };

  DOM.isPositioned = function(docElem) {
    var ref;
    assert(docElem instanceof HTMLElement, "DOM.isPositioned", "docElem needs to be instance of HTMLElement.", {
      docElem: docElem
    });
    if (docElem === document.body || docElem === document.documentElement) {
      return true;
    }
    return (ref = this.getComputedStyle(docElem).position) === "relative" || ref === "absolute" || ref === "fixed";
  };

  DOM.isVisible = function(docElem) {
    var style;
    style = this.getComputedStyle(docElem);
    if (style.visibility === "hidden" || style.display === "none") {
      return false;
    } else {
      return true;
    }
  };

  DOM.getBoxSizing = function(docElem) {
    return this.getComputedStyle(docElem).boxSizing;
  };

  DOM.isBorderBox = function(docElem) {
    return this.getBoxSizing(docElem) === "border-box";
  };

  DOM.isContentBox = function(docElem) {
    return CUI.DOM.getBoxSizing() === "content-box";
  };

  DOM.hideElement = function(docElem) {
    if (!docElem) {
      return;
    }
    if (docElem.style.display !== "none") {
      docElem.__saved_display = docElem.style.display;
    }
    docElem.style.display = "none";
    return docElem;
  };

  DOM.removeChildren = function(docElem, filter) {
    var child, i, len1, ref;
    assert(docElem instanceof HTMLElement, "CUI.DOM.removeChildren", "element needs to be instance of HTMLElement", {
      element: docElem
    });
    ref = this.children(docElem, filter);
    for (i = 0, len1 = ref.length; i < len1; i++) {
      child = ref[i];
      docElem.removeChild(child);
    }
    return docElem;
  };

  DOM.showElement = function(docElem) {
    if (!docElem) {
      return;
    }
    docElem.style.display = docElem.__saved_display || "";
    delete docElem.__saved_display;
    return docElem;
  };

  DOM.element = function(tagName, attrs) {
    if (attrs == null) {
      attrs = {};
    }
    return DOM.setAttributeMap(document.createElement(tagName), attrs);
  };

  DOM.debugRect = function() {
    var arr, bottom, d, dim, height, i, k, left, len1, pattern, ref, right, top, value, width;
    this.remove(this.find("#cui-debug-rect")[0]);
    if (arguments.length === 0) {
      return;
    }
    if (arguments.length === 2 || !CUI.isArray(arguments[0])) {
      dim = arguments[0];
      pattern = arguments[1];
      arr = [];
      ref = ["Top", "Left", "Bottom", "Right"];
      for (i = 0, len1 = ref.length; i < len1; i++) {
        k = ref[i];
        if (isEmpty(pattern) || pattern === "*") {
          k = k.toLowerCase();
          value = dim[k];
        } else {
          value = dim[pattern.replace("*", k)];
        }
        arr.push(value);
      }
    } else if (CUI.isArray(arguments[0])) {
      arr = arguments[0];
    } else {
      console.error("CUI.DOM.debugRect: Argument Error.");
      return;
    }
    top = arr[0], left = arr[1], bottom = arr[2], right = arr[3];
    width = right - left;
    height = bottom - top;
    d = this.element("DIV", {
      id: "cui-debug-rect"
    });
    this.setStyle(d, {
      position: "absolute",
      border: "2px solid red",
      boxSizing: "border-box",
      top: top,
      left: left,
      width: width,
      height: height
    });
    document.body.appendChild(d);
    console.debug("DOM.debugRect:", [top, left, bottom, right]);
    return d;
  };

  DOM.scrollIntoView = function(docElem) {
    var dim, dim_p, i, idx, len1, measure, off_bottom, off_left, off_right, off_top, p, parents;
    if (!docElem) {
      return null;
    }
    parents = CUI.DOM.parentsUntil(docElem);
    dim = null;
    measure = (function(_this) {
      return function() {
        return dim = _this.getDimensions(docElem);
      };
    })(this);
    measure();
    for (idx = i = 0, len1 = parents.length; i < len1; idx = ++i) {
      p = parents[idx];
      dim_p = this.getDimensions(p);
      if (dim_p.computedStyle.overflowY !== "visible") {
        off_bottom = dim.viewportBottomMargin - dim_p.viewportBottomContent;
        if (off_bottom > 0) {
          p.scrollTop = p.scrollTop + off_bottom;
          measure();
        }
        off_top = dim.viewportTopMargin - dim_p.viewportTopContent;
        if (off_top < 0) {
          p.scrollTop = p.scrollTop + off_top;
          measure();
        }
      }
      if (dim_p.computedStyle.overflowX !== "visible") {
        off_right = dim.viewportRightMargin - dim_p.viewportRightContent;
        if (off_right > 0) {
          p.scrollLeft = p.scrollLeft + off_right;
          measure();
        }
        off_left = dim.viewportLeftMargin - dim_p.viewportLeftContent;
        if (off_left < 0) {
          p.scrollLeft = p.scrollLeft + off_left;
          measure();
        }
      }
    }
    return docElem;
  };

  DOM.setClassOnMousemove = function(_opts) {
    var opts, remove_mousemoved_class, schedule_remove_mousemoved_class;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "DOM.setClassOnMousemove", {
      delayRemove: {
        check: Function
      },
      "class": {
        mandatory: true,
        check: String
      },
      ms: {
        "default": 3000,
        mandatory: true,
        check: function(v) {
          return v > 0;
        }
      },
      element: {
        mandatory: true,
        check: function(v) {
          return v instanceof HTMLElement;
        }
      },
      instance: {}
    });
    remove_mousemoved_class = (function(_this) {
      return function() {
        if ((typeof opts.delayRemove === "function" ? opts.delayRemove() : void 0) || window.globalDrag) {
          schedule_remove_mousemoved_class();
          return;
        }
        return opts.element.classList.remove(opts["class"]);
      };
    })(this);
    schedule_remove_mousemoved_class = (function(_this) {
      return function() {
        return CUI.scheduleCallback({
          ms: opts.ms,
          call: remove_mousemoved_class
        });
      };
    })(this);
    Events.listen({
      node: opts.element,
      type: "mousemove",
      instance: opts.instance,
      call: (function(_this) {
        return function(ev) {
          if (!opts.element.classList.contains(opts["class"])) {
            opts.element.classList.add(opts["class"]);
          }
          schedule_remove_mousemoved_class();
        };
      })(this)
    });
    return Events.listen({
      node: opts.element,
      type: "mouseleave",
      instance: opts.instance,
      call: (function(_this) {
        return function(ev) {
          return remove_mousemoved_class();
        };
      })(this)
    });
  };

  DOM.requestFullscreen = function(elem) {
    var dfr, fsc_ev;
    assert(elem instanceof HTMLElement, "startFullscreen", "element needs to be instance of HTMLElement", {
      element: elem
    });
    if (elem.requestFullscreen) {
      elem.requestFullscreen();
    } else if (elem.webkitRequestFullscreen) {
      elem.webkitRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem.mozRequestFullScreen();
    } else if (elem.msRequestFullscreen) {
      elem.msRequestFullscreen();
    }
    dfr = new CUI.Deferred();
    fsc_ev = Events.listen({
      type: "fullscreenchange",
      node: window,
      call: (function(_this) {
        return function(ev) {
          if (DOM.isFullscreen()) {
            dfr.notify();
          } else {
            Events.ignore(fsc_ev);
            dfr.resolve();
          }
        };
      })(this)
    });
    return dfr.promise();
  };

  DOM.exitFullscreen = function() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  };

  DOM.fullscreenElement = function() {
    return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || void 0;
  };

  DOM.fullscreenEnabled = function() {
    return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || false;
  };

  DOM.isFullscreen = function() {
    return document.fullscreen || document.webkitIsFullScreen || document.mozFullScreen || false;
  };

  return DOM;

})(CUI.Element);

DOM = CUI.DOM;
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.CSSLoader = (function(superClass) {
  extend(CSSLoader, superClass);

  function CSSLoader() {
    return CSSLoader.__super__.constructor.apply(this, arguments);
  }

  CSSLoader.prototype.initOpts = function() {
    CSSLoader.__super__.initOpts.call(this);
    return this.addOpts({
      group: {
        mandatory: true,
        "default": "main",
        check: String
      }
    });
  };

  CSSLoader.prototype.readOpts = function() {
    CSSLoader.__super__.readOpts.call(this);
    this.__cssName = "cui-css-" + this._group;
    return this.__themes = {};
  };

  CSSLoader.prototype.__getCSSNodes = function() {
    return CUI.DOM.matchSelector(document.documentElement, "link[name=\"" + this.__cssName + "\"]");
  };

  CSSLoader.prototype.getActiveTheme = function() {
    var active_theme, cssNode, i, len, name, ref;
    ref = this.__getCSSNodes();
    for (i = 0, len = ref.length; i < len; i++) {
      cssNode = ref[i];
      if (!CUI.DOM.getAttribute(cssNode, "loading")) {
        name = CUI.DOM.getAttribute(cssNode, "theme");
        active_theme = this.__themes[name];
        break;
      }
    }
    if (active_theme) {
      return active_theme;
    }
    return null;
  };

  CSSLoader.prototype.getThemes = function() {
    return this.__themes;
  };

  CSSLoader.prototype.registerTheme = function(_opts) {
    var opts;
    opts = CUI.Element.readOpts(_opts, "CSS.registerTheme", {
      name: {
        mandatory: true,
        check: String
      },
      url: {
        mandatory: true,
        check: String
      }
    });
    return this.__themes[opts.name] = opts;
  };

  CSSLoader.prototype.forceReloadTheme = function() {
    var theme;
    theme = this.getActiveTheme();
    if (!active_theme) {
      return CUI.rejectedPromise();
    }
    return this.loadTheme(theme, true);
  };

  CSSLoader.prototype.loadTheme = function(name, overload_url) {
    var cssNode, css_href, dfr, i, is_loading, len, loader_deferred, loc, oldCssNode, ref, ref1, same_theme, same_url, url;
    if (overload_url == null) {
      overload_url = null;
    }
    url = (ref = this.__themes[name]) != null ? ref.url : void 0;
    assert(url, "CSSLoader.loadTheme", "Theme not found.", {
      name: name,
      themes: this.__themes
    });
    if (overload_url) {
      url = overload_url;
    }
    ref1 = this.__getCSSNodes();
    for (i = 0, len = ref1.length; i < len; i++) {
      oldCssNode = ref1[i];
      same_theme = CUI.DOM.getAttribute(oldCssNode, "theme") === name;
      same_url = CUI.DOM.getAttribute(oldCssNode, "href") === url;
      is_loading = CUI.DOM.getAttribute(oldCssNode, "loading");
      if (is_loading) {
        loader_deferred = CUI.DOM.data(oldCssNode, "css-loader-deferred");
        if (same_theme && same_url) {
          console.warn("CSSLoader.loadTheme:", name, ". Theme already loading, returning Promise.");
          return loader_deferred.promise();
        }
        console.warn("CSSLoader.loadTheme:", name, ". Theme still loading, but a different one, aborting other load.");
        load_deferred.reject();
      } else {
        if (same_theme && same_url) {
          console.warn("CSSLoader.loadTheme:", name, ". Theme already loaded.");
          return CUI.resolvedPromise();
        }
      }
    }
    console.info("CSSLoader: Loading:", url);
    if (name.startsWith("ng")) {
      CUI.__ng__ = true;
    }
    dfr = new CUI.Deferred();
    cssNode = CUI.DOM.element("LINK", {
      rel: "stylesheet",
      charset: "utf-8",
      name: this.__cssName,
      loading: "1",
      theme: name,
      href: url
    });
    loc = CUI.parseLocation(url);
    if (!loc.origin) {
      css_href = document.location.origin + url;
    } else {
      css_href = url;
    }
    CUI.DOM.data(cssNode, "css-loader-deferred", dfr);
    dfr.always((function(_this) {
      return function() {
        CUI.DOM.removeData(cssNode, "css-loader-deferred");
        return CUI.DOM.removeAttribute(cssNode, "loading");
      };
    })(this));
    dfr.fail((function(_this) {
      return function(css_href) {
        console.error("CSSLoader: Loading failed, removing node.", css_href);
        return CUI.DOM.remove(cssNode);
      };
    })(this));
    Events.listen({
      node: cssNode,
      type: "load",
      call: (function(_this) {
        return function(ev, info) {
          var css_node, j, k, len1, len2, old_css_nodes, ref2, ref3, styleSheet;
          if (dfr.state() !== "pending") {
            console.warn("CSSLoader.loadTheme: Caught event load second time, ignoring. IE does that for some reason.");
            return;
          }
          ref2 = document.styleSheets;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            styleSheet = ref2[j];
            if (styleSheet.href === css_href) {
              if (styleSheet.cssRules.length === 0) {
                console.error("CSSLoader: Loaded a stylesheet with no rules: ", css_href, styleSheet);
                dfr.reject(css_href);
                return;
              }
            }
          }
          old_css_nodes = [];
          ref3 = DOM.matchSelector(document.head, "link[name='" + _this.__cssName + "']");
          for (k = 0, len2 = ref3.length; k < len2; k++) {
            css_node = ref3[k];
            if (css_node !== cssNode) {
              console.warn("CSSLoader.loadTheme: Removing old css node:", CUI.DOM.getAttribute(css_node, "href"), "New Node is:", CUI.DOM.getAttribute(cssNode, "href"), "Is loading:", CUI.DOM.getAttribute(css_node, "loading"));
              CUI.DOM.remove(css_node);
              old_css_nodes.push(css_node);
            }
          }
          CUI.DOM.setAttribute(document.body, "cui-theme", name);
          console.info("CSSLoader.loadTheme: Loading went fine: ", url, "Removing the old CSS node: ", old_css_nodes);
          Events.trigger({
            type: "viewport-resize",
            info: {
              css_load: true
            }
          });
          dfr.resolve(css_href);
        };
      })(this)
    });
    Events.listen({
      node: cssNode,
      type: "error",
      call: (function(_this) {
        return function(ev, info) {
          console.error("CSS.load: loading error:", url);
          dfr.reject(css_href);
        };
      })(this)
    });
    document.head.appendChild(cssNode);
    return dfr.promise();
  };

  return CSSLoader;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var Template,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Template = (function(superClass) {
  extend(Template, superClass);

  function Template(opts) {
    var node;
    this.opts = opts != null ? opts : {};
    Template.__super__.constructor.call(this, this.opts);
    node = Template.nodeByName[this._name];
    assert(node, "CUI.Template", this._name + " not found. Make sure to call Template.loadFile(...).");
    this.DOM = node.cloneNode(true);
    if (this._class) {
      DOM.addClass(this.DOM, this._class);
    }
    CUI.DOM.setElement(this.DOM, this);
    this.map = this.getElMap(this._map);
    if (!CUI.isEmptyObject(this.map)) {
      CUI.DOM.addClass(this.DOM, "cui-template-empty");
    }
    return;
  }

  Template.prototype.initOpts = function() {
    Template.__super__.initOpts.call(this);
    this.addOpts({
      name: {
        mandatory: true,
        check: String
      },
      map_prefix: {
        check: String
      },
      map: {
        type: "PlainObject",
        "default": {}
      },
      "class": {
        check: String
      }
    });
    return this;
  };

  Template.prototype.initFlexHandles = function() {
    var fh, fh_el, fh_name, i, len, ref;
    this.__flexHandles = {};
    ref = CUI.DOM.matchSelector(this.DOM, "[cui-flex-handle]");
    for (i = 0, len = ref.length; i < len; i++) {
      fh_el = ref[i];
      fh = new FlexHandle({
        element: fh_el
      });
      if (!isEmpty(fh_name = fh.getName())) {
        this.__flexHandles[fh_name] = fh;
        fh.init();
      }
    }
    return this;
  };

  Template.prototype.getFlexHandle = function(name) {
    var fh;
    assert(this.__flexHandles, "Template.getFlexHandle", "flexHandles are not initialized yet, call Template.initFlexHandles(opts) first.", {
      name: name
    });
    fh = this.__flexHandles[name];
    assert(fh instanceof FlexHandle, this.__cls + ".getFlexHandle", "FlexHandle \"" + name + "\" not found, make sure you have specified a name in the cui-flex-handle attribute.", {
      opts: this.opts,
      flexHandles: this.__flexHandles
    });
    return fh;
  };

  Template.prototype.getFlexHandles = function() {
    return this.__flexHandles;
  };

  Template.prototype.getElMap = function(map) {
    var clean_k, el_map, k, map_obj, misses, prefix, report, sel, v;
    el_map = {};
    report = [];
    misses = 0;
    for (k in map) {
      v = map[k];
      if (isNull(v)) {
        continue;
      }
      if (v === true) {
        clean_k = k.replace(/_/g, "-");
        if (this._map_prefix) {
          prefix = this._map_prefix;
        } else {
          prefix = toDash(this._name);
        }
        sel = ".ez-" + prefix + "-" + clean_k + ",.cui-" + prefix + "-" + clean_k;
      } else {
        sel = v;
      }
      map_obj = CUI.DOM.matchSelector(this.DOM, sel, true);
      if (map_obj.length === 0) {
        report.push("* " + k + ": not found (" + sel + ")");
        misses++;
      } else if (map_obj.length > 1) {
        CUI.debug(k, v, "found more than once", map_obj, this.DOM);
        report.push("* " + k + ": found more than once (" + sel + ")");
        misses++;
      } else {
        report.push("+ " + k + ": found");
        el_map[k] = CUI.jQueryCompat(map_obj[0]);
      }
    }
    if (misses) {
      alert(("Not all required elements were found for Template:\n\n\"" + this._name + "\"\n\n") + report.join("\n"));
    }
    return el_map;
  };

  Template.prototype.destroy = function() {
    DOM.remove(this.DOM);
    delete this.map;
    return Template.__super__.destroy.call(this);
  };

  Template.prototype.addClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".addClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.addClass(this.map[key], cls);
    } else {
      return DOM.addClass(this.DOM, cls);
    }
  };

  Template.prototype.removeClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".removeClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.removeClass(this.map[key], cls);
    } else {
      return DOM.removeClass(this.DOM, cls);
    }
  };

  Template.prototype.hasClass = function(cls, key) {
    if (key) {
      assert(this.map[key], this.__cls + ".hasClass", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
      return DOM.hasClass(this.map[key], cls);
    } else {
      return DOM.hasClass(this.DOM, cls);
    }
  };

  Template.prototype.has = function(key) {
    return !!this.map[key];
  };

  Template.prototype.empty = function(key) {
    var is_empty;
    assert(this.map, "Template[" + this._name + "].empty [" + (this.getUniqueId()) + "]", "Already destroyed", {
      template: this,
      name: this._name
    });
    if (this.isEmpty(key)) {
      if (key) {
        return this.map[key];
      } else {
        return this.DOM;
      }
    }
    if (key) {
      assert(this.map[key], this.__cls + ".empty", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
      DOM.empty(this.map[key]);
      is_empty = true;
      for (key in this.map) {
        if (!this.isEmpty(key)) {
          is_empty = false;
          break;
        }
      }
      if (is_empty) {
        DOM.addClass(this.DOM, "cui-template-empty");
      }
      return this.map[key];
    }
    if (CUI.isEmptyObject(this.map)) {
      DOM.empty(this.DOM);
    } else {
      for (key in this.map) {
        DOM.empty(this.map[key]);
      }
      DOM.addClass(this.DOM, "cui-template-empty");
    }
    return this.DOM;
  };

  Template.prototype.replace = function(value, key, element) {
    assert(this.map, "Template[" + this._name + "].replace [" + (this.getUniqueId()) + "]", "Already destroyed");
    if (key) {
      assert(this.map[key], this.__cls + ".replace", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map,
        DOM: this.DOM
      });
    }
    this.empty(key);
    return this.append(value, key, element);
  };

  Template.prototype.text = function(value, key, element) {
    assert(isString(value), this.__cls + ".text", "Value must be String", {
      value: value,
      key: key,
      element: element
    });
    if (key) {
      return this.map[key].text(value);
    } else {
      return this.DOM.text(value);
    }
  };

  Template.prototype.prepend = function(value, key, element) {
    return this.append(value, key, element, true);
  };

  Template.prototype.append = function(value, key, element, prepend) {
    var _value, appends, fn, i, len, node;
    if (prepend == null) {
      prepend = false;
    }
    if (prepend) {
      fn = "prepend";
    } else {
      fn = "append";
    }
    assert(this.map, "Template[" + this._name + "]." + fn + " [" + (this.getUniqueId()) + "]", "Already destroyed");
    if (key) {
      assert(this.map[key], this.__cls + "." + fn, "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
    }
    if (CUI.isFunction(value)) {
      value = value(element);
    }
    if (!CUI.isArray(value)) {
      value = [value];
    }
    appends = [];
    for (i = 0, len = value.length; i < len; i++) {
      _value = value[i];
      if (_value != null ? _value.DOM : void 0) {
        appends.push(_value.DOM);
      } else {
        assert(!isPromise(_value), "Template.append", "value cannot be Promise", {
          value: value
        });
        if (_value) {
          appends.push(_value);
        }
      }
    }
    if (key) {
      node = this.map[key];
    } else {
      node = this.DOM;
    }
    if (appends.length > 0) {
      CUI.DOM[fn](node, appends);
      CUI.DOM.removeClass(this.DOM, "cui-template-empty");
    }
    return node;
  };

  Template.prototype.isEmpty = function(key) {
    if (!key) {
      return !this.DOM.firstChild;
    } else {
      assert(this.map[key], this.__cls + ".isEmpty", "Key \"" + key + "\" not found in map. Template: \"" + this._name + "\".", {
        map: this.map
      });
      return !this.map[key].firstChild;
    }
  };

  Template.nodeByName = {};

  Template.start = function() {
    var dfr;
    dfr = new CUI.Deferred();
    this.load();
    if (!this.nodeByName["cui-base"]) {
      CUI.Template.loadFile("easydbui.html").done((function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this));
    } else {
      dfr.resolve();
    }
    return dfr.promise();
  };

  Template.loadFile = function(filename) {
    var div, p;
    if (filename.match("^(https://|http://|/)")) {
      p = filename;
    } else {
      p = CUI.pathToScript + "/" + filename;
    }
    div = CUI.DOM.element("DIV", {
      style: "display:none;"
    });
    return new CUI.XHR({
      url: p,
      responseType: "text"
    }).start().done(function(data) {
      var count;
      div.innerHTML = data;
      count = Template.load(div);
      if (div.children.length > 0) {
        document.body.appendChild(div);
        console.error("Template.loadFile:", filename, "contains extra content.", div);
      }
      if (count === 0) {
        console.warn("Template.loadFile:", filename, "contains no Templates.");
      } else {
        console.info("Template.loadFile:", count, "Template loaded from", filename);
      }
    }).fail(function(xhr) {
      return CUI.error("Template.loadFile: Unable to load filename: \"" + filename + "\", see Console for more details. You can however, output easydbui.html manually before loading easydbui.js.", xhr);
    });
  };

  Template.load = function(start_element) {
    var cls, count, el, i, j, len, len1, name, ref, ref1;
    if (start_element == null) {
      start_element = document.documentElement;
    }
    count = 0;
    ref = CUI.DOM.matchSelector(start_element, ".cui-tmpl");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      ref1 = el.classList;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        cls = ref1[j];
        if (cls.startsWith("cui-tmpl-")) {
          name = cls.substr(9);
          if (Template.nodeByName[name]) {
            console.error("Template.load:", name, "already found in DOM tree. Make sure all elements exists only once.", el);
            continue;
          }
          Template.nodeByName[name] = el;
          CUI.DOM.remove(el);
          el.classList.remove("cui-tmpl");
          count = count + 1;
          break;
        }
      }
    }
    return count;
  };

  return Template;

})(CUI.Element);

Template = CUI.Template;
// Generated by CoffeeScript 1.9.3
var FlexHandle,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FlexHandle = (function(superClass) {
  extend(FlexHandle, superClass);

  function FlexHandle(opts1) {
    var c, children, i, idx, len;
    this.opts = opts1 != null ? opts1 : {};
    this.addOptsFromAttr(CUI.DOM.getAttribute(this.opts.element, "cui-flex-handle"));
    FlexHandle.__super__.constructor.call(this, this.opts);
    this.__pane = null;
    children = this._element.parentNode.children;
    for (idx = i = 0, len = children.length; i < len; idx = ++i) {
      c = children[idx];
      if (CUI.DOM.is(c, this._pane)) {
        this.__pane = c;
        this.__pane_idx = idx;
      }
      if (CUI.DOM.is(c, this._element)) {
        this.__element_idx = idx;
      }
    }
    this.__adjacent_pane = null;
    if (this.__element_idx > this.__pane_idx) {
      if (this.__element_idx < children.length - 1) {
        this.__adjacent_pane = children[this.__element_idx + 1];
      }
    } else {
      if (this.__element_idx > 0) {
        this.__adjacent_pane = children[this.__element_idx - 1];
      }
    }
    this.__closed = this._closed;
    this.__hidden = this._hidden;
    this.__stretched = null;
    this.__size = null;
    assert(this.__pane, "new " + this.__cls, "pane \"" + this._pane + "\" not found in parent element of cui-flex-handle element.", {
      opts: this.opts,
      children: children
    });
    CUI.DOM.data(this.__pane, "flexHandle", this);
    CUI.DOM.setAttribute(this.__pane, "flex-handled-pane", this._name);
  }

  FlexHandle.prototype.readOpts = function() {
    var ref, ref1, ref2;
    FlexHandle.__super__.readOpts.call(this);
    if ((ref = this._direction) === "horizontal" || ref === "row") {
      this.__direction = "row";
    } else if ((ref1 = this._direction) === "vertical" || ref1 === "column") {
      this.__direction = "column";
    }
    assert((ref2 = this.__direction) === "row" || ref2 === "column", "new " + this.__cls, "opts.direction needs to be set", {
      opts: this.opts,
      element: this._element[0]
    });
    this.setClosable(this._closable);
    if (this._label) {
      this.addLabel(this._label);
    }
  };

  FlexHandle.prototype.initOpts = function() {
    FlexHandle.__super__.initOpts.call(this);
    return this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return isElement(v);
        }
      },
      pane: {
        mandatory: true,
        check: String
      },
      name: {
        mandatory: true,
        check: String
      },
      closed: {
        check: Boolean
      },
      closable: {
        mandatory: true,
        "default": true,
        check: Boolean
      },
      label: {
        check: function(v) {
          return v instanceof Label || CUI.isPlainObject(v);
        }
      },
      hidden: {
        check: Boolean
      },
      direction: {
        check: ["horizontal", "vertical", "row", "column"]
      },
      manage_state: {
        "default": true,
        check: Boolean
      }
    });
  };

  FlexHandle.prototype.init = function() {
    var axis;
    if (this.isDestroyed()) {
      return;
    }
    DOM.addClass(this._element, "cui-flex-handle cui-flex-handle-" + this.__direction + " cui-flex-handle-" + this._name);
    if (this.__closed) {
      this.close();
    }
    if (this.__hidden) {
      this.hide();
    }
    if (this.__direction === "row") {
      axis = "x";
      this.__css_value = "Width";
    } else {
      axis = "y";
      this.__css_value = "Height";
    }
    Events.listen({
      type: "dblclick",
      node: this._element,
      call: (function(_this) {
        return function(ev) {
          if (_this.__size === null) {
            if (_this.isClosed()) {
              _this.open();
            } else if (_this.getClosable()) {
              _this.close();
            }
          } else {
            _this.resetSize();
          }
          _this.storeState();
        };
      })(this)
    });
    Events.listen({
      type: "click",
      node: this._element,
      call: (function(_this) {
        return function(ev) {
          if (!_this.__label) {
            return;
          }
          if (_this.isClosed()) {
            _this.open();
            _this.storeState();
          }
        };
      })(this)
    });
    new Draggable({
      element: this._element,
      axis: axis,
      create: (function(_this) {
        return function() {
          if (_this.isClosed()) {
            return false;
          }
        };
      })(this),
      dragstart: (function(_this) {
        return function(ev, gd) {
          var adj_data, data, flip, get_data, max_diff;
          if (_this.__pane_idx < _this.__element_idx) {
            flip = 1;
          } else {
            flip = -1;
          }
          get_data = function(pane) {
            var dim, min;
            dim = DOM.getDimensions(pane);
            min = dim["min" + _this.__css_value];
            if (min < 10) {
              min = 10;
            }
            return {
              min: min,
              max: dim["max" + _this.__css_value],
              value: dim["contentBox" + _this.__css_value]
            };
          };
          data = get_data(_this.__pane);
          if (_this.__adjacent_pane) {
            adj_data = get_data(_this.__adjacent_pane);
            max_diff = adj_data.value - adj_data.min;
            data.max = Math.max(0, data.value + max_diff);
          }
          gd.__pane_data = {
            flip: flip,
            axis: axis,
            min: data.min,
            max: data.max,
            value: data.value
          };
          gd.isFlexHandleDrag = true;
          return gd;
        };
      })(this),
      helper_set_pos: function(gd, helper_pos) {
        var data, key, new_value;
        data = gd.__pane_data;
        if (data.axis === "x") {
          key = "left";
        } else {
          key = "top";
        }
        new_value = data.value + gd.dragDiff[data.axis] * data.flip;
        if (new_value < data.min) {
          new_value = data.min;
        } else if (new_value > data.max) {
          new_value = data.max;
        }
        helper_pos[key] = (new_value - data.value) * data.flip + helper_pos.start[key];
      },
      dragend: (function(_this) {
        return function(ev, gd) {
          var new_value;
          if (ev.getType() !== "mouseup") {
            return;
          }
          new_value = gd.__pane_data.value + gd.dragDiff[gd.__pane_data.axis] * gd.__pane_data.flip;
          if (gd.__pane_data.min) {
            new_value = Math.max(gd.__pane_data.min, new_value);
          }
          if (gd.__pane_data.max) {
            new_value = Math.min(gd.__pane_data.max, new_value);
          }
          return _this.__setSize(new_value);
        };
      })(this)
    });
    DOM.waitForDOMInsert({
      node: this._element
    }).done((function(_this) {
      return function() {
        _this.__initState();
        _this.__setState();
        return Events.listen({
          type: "content-resize",
          node: _this._element,
          call: function(ev) {
            return ev.stopPropagation();
          }
        });
      };
    })(this));
    return this;
  };

  FlexHandle.prototype.__setSize = function(size) {
    if (isNull(size)) {
      DOM.setStyleOne(this.__pane, this.__css_value.toLowerCase(), "");
      if (DOM.getDimension(this.__pane, "contentBox" + this.__css_value) === 0) {
        CUI.error("FlexHandle.__setSize: Pane size is 0 if unset, this needs to be fixed in CSS.", this.__pane[0]);
        DOM.setDimension(this.__pane, "contentBox" + this.__css_value, 100);
      }
      this._element.classList.remove("cui-flex-handle-manual-size");
      this.__size = null;
    } else {
      console.debug("DOM set dimension", size, this.__css_value, this.__pane);
      this._element.classList.add("cui-flex-handle-manual-size");
      DOM.setDimension(this.__pane, "contentBox" + this.__css_value, size);
      this.__size = DOM.getDimension(this.__pane, "contentBox" + this.__css_value);
    }
    this.storeState();
    return this.__resize();
  };

  FlexHandle.prototype.setClosable = function(__closable) {
    this.__closable = __closable;
  };

  FlexHandle.prototype.getClosable = function() {
    return !!this.__closable;
  };

  FlexHandle.prototype.resetSize = function() {
    this.__setSize(null);
    return this;
  };

  FlexHandle.prototype.__getSize = function() {
    return this.__size;
  };

  FlexHandle.prototype.__isAlive = function() {
    if (this.isDestroyed() || !CUI.DOM.isInDOM(this._element)) {
      return false;
    } else {
      return true;
    }
  };

  FlexHandle.prototype.__resize = function() {
    if (!this.__isAlive()) {
      return;
    }
    return Events.trigger({
      type: "viewport-resize",
      info: {
        FlexHandle: true
      }
    });
  };

  FlexHandle.prototype.__initState = function() {
    var add_cls, cls_for_unique_name, i, idx, len, parent, ref;
    if (!this._manage_state) {
      return;
    }
    cls_for_unique_name = [this._name];
    add_cls = function(el) {
      var cls, i, len, ref, use_cls;
      use_cls = [];
      ref = el.classList;
      for (i = 0, len = ref.length; i < len; i++) {
        cls = ref[i];
        if (cls.match(/^(ez-|cui-)/)) {
          continue;
        }
        use_cls.push(cls);
      }
      return cls_for_unique_name.push("." + use_cls.join("."));
    };
    add_cls(this.__pane);
    ref = DOM.parents(this.__pane);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      parent = ref[idx];
      add_cls(parent);
    }
    this.__state_name = "CUI-FlexHandle-" + cls_for_unique_name.join("/");
    return DOM.setAttribute(this._element, "title", this.__unique_name);
  };

  FlexHandle.prototype.__getState = function() {
    var state, value;
    value = window.localStorage[this.__state_name];
    if (!isNull(value)) {
      state = JSON.parse(value);
    } else {
      state = {};
    }
    return state;
  };

  FlexHandle.prototype.__setState = function() {
    var state;
    if (!this._manage_state) {
      return;
    }
    state = this.__getState();
    if (!isUndef(state.closed)) {
      if (state.closed) {
        this.close();
      } else {
        this.open();
      }
    }
    if (!isUndef(state.size)) {
      this.__setSize(state.size);
    }
    return this;
  };

  FlexHandle.prototype.storeState = function() {
    var state, value;
    if (!this._manage_state) {
      return;
    }
    state = {
      closed: this.isClosed(),
      size: this.__getSize()
    };
    value = JSON.stringify(state);
    window.localStorage[this.__state_name] = value;
    return this;
  };

  FlexHandle.prototype.isStretched = function() {
    return this.__stretched;
  };

  FlexHandle.prototype.stretch = function(direction, do_stretch) {
    var el, els, i, j, len, len1, pane, set;
    if (do_stretch == null) {
      do_stretch = true;
    }
    if (do_stretch) {
      if (this.isStretched() === direction) {
        return;
      } else {
        this.unstretch();
      }
    }
    pane = this.getPane();
    switch (direction) {
      case "west":
      case "north":
        els = DOM.findPreviousSiblings(pane);
        break;
      case "east":
      case "south":
        els = DOM.findNextSiblings(pane);
    }
    switch (direction) {
      case "west":
      case "east":
        set = "width";
        break;
      case "north":
      case "south":
        set = "height";
    }
    if (do_stretch) {
      for (i = 0, len = els.length; i < len; i++) {
        el = els[i];
        el.classList.add("cui-flex-handle-hide-for-stretch");
        el.classList.add("cui-flex-handle-hide-for-stretch-" + direction);
      }
      this.__pane[set]("");
      pane.classList.add("cui-flex-handle-stretched");
      pane.classList.add("cui-flex-handle-stretched-" + direction);
      Events.trigger({
        node: pane,
        type: "flex-stretch-start"
      });
      this.__stretched = direction;
    } else {
      for (j = 0, len1 = els.length; j < len1; j++) {
        el = els[j];
        el.classList.remove("cui-flex-handle-hide-for-stretch");
        el.classList.remove("cui-flex-handle-hide-for-stretch-" + direction);
      }
      this.__stretched = null;
      if (this.__size) {
        this.__pane[set](this.__size);
      }
      pane.classList.remove("cui-flex-handle-stretched");
      pane.classList.remove("cui-flex-handle-stretched-" + direction);
      Events.trigger({
        node: pane,
        type: "flex-stretch-end"
      });
      this.__resize();
    }
    return this;
  };

  FlexHandle.prototype.unstretch = function() {
    if (!this.isStretched()) {
      return;
    }
    return this.stretch(this.__stretched, false);
  };

  FlexHandle.prototype.getLabel = function() {
    if (!this.__isAlive()) {
      return null;
    }
    return this.__label;
  };

  FlexHandle.prototype.addLabel = function(opts) {
    if (opts == null) {
      opts = {};
    }
    if (opts instanceof Label) {
      this.__label = opts;
    } else {
      if (this.__direction === "row") {
        opts.rotate_90 = true;
      }
      this.__label = new Label(opts);
    }
    DOM.append(this._element, this.__label.DOM);
    return DOM.addClass(this._element, "cui-flex-handle-has-label");
  };

  FlexHandle.prototype.getName = function() {
    return this._name;
  };

  FlexHandle.prototype.getHandle = function() {
    return this._element;
  };

  FlexHandle.prototype.getPane = function() {
    return this.__pane;
  };

  FlexHandle.prototype.isShown = function() {
    return !this.isHidden();
  };

  FlexHandle.prototype.isHidden = function() {
    return this._element.classList.contains("cui-flex-handle-hidden");
  };

  FlexHandle.prototype.isClosed = function() {
    return this._element.classList.contains("cui-flex-handle-closed");
  };

  FlexHandle.prototype.isOpen = function() {
    return !this.isClosed();
  };

  FlexHandle.prototype.close = function() {
    if (this.isClosed()) {
      return this;
    }
    Events.trigger({
      node: this.getPane(),
      type: "flex-close"
    });
    this._element.classList.add("cui-flex-handle-closed");
    this.__pane.css("display", "none");
    this.__resize();
    return this;
  };

  FlexHandle.prototype.open = function() {
    if (this.isOpen()) {
      return this;
    }
    this._element.classList.remove("cui-flex-handle-closed");
    this.__pane.css("display", "");
    delete this.__closed;
    this.__resize();
    return this;
  };

  FlexHandle.prototype.hide = function() {
    if (this.isHidden()) {
      return this;
    }
    this._element.classList.add("cui-flex-handle-hidden");
    this.__resize();
    return this;
  };

  FlexHandle.prototype.show = function() {
    if (this.isShown()) {
      return this;
    }
    this._element.classList.remove("cui-flex-handle-hidden");
    delete this.__hidden;
    this.__resize();
    return this;
  };

  FlexHandle.prototype.destroy = function() {
    DOM.removeData(this.__pane, "flexHandle");
    DOM.removeAttribute(this.__pane, "flex-handled-pane");
    DOM.remove(this._element);
    return FlexHandle.__super__.destroy.call(this);
  };

  FlexHandle.getStretchButton = function(_opts) {
    var activedir, btn_opts, k, opts, ref, v;
    if (_opts == null) {
      _opts = {};
    }
    opts = CUI.Element.readOpts(_opts, "FlexHandle.getPushButton", {
      direction: {
        check: ["west", "east", "north", "south"]
      },
      text: {
        check: String
      },
      flexHandle: {
        check: FlexHandle
      },
      button: {
        "default": {}
      }
    });
    activedir = {
      west: "east",
      east: "west",
      north: "south",
      south: "north"
    };
    btn_opts = opts.button;
    ref = {
      icon_active: activedir[opts.direction],
      icon_inactive: opts.direction,
      "class": "cui-pane-stretch-button",
      text: opts.text,
      "switch": true,
      onClick: (function(_this) {
        return function(ev, btn) {
          var fh, fh_els;
          if (opts.flexHandle) {
            fh = opts.flexHandle;
          } else {
            fh_els = btn.DOM.closest("[flex-handled-pane]");
            assert(fh_els.length === 1, "FlexHandle.getStretchButton", "FlexHandle not or more than one found, name: " + opts.name + ".", {
              opts: opts,
              flexHandles: fh_els
            });
            fh = DOM.data(fh_els[0], "flexHandle");
          }
          if (fh.isStretched()) {
            return fh.unstretch();
          } else {
            return fh.stretch(opts.direction);
          }
        };
      })(this)
    };
    for (k in ref) {
      v = ref[k];
      btn_opts[k] = v;
    }
    return new CUI.defaults["class"].Button(btn_opts);
  };

  return FlexHandle;

})(CUI.Element);

CUI.Events.registerEvent({
  type: ["flex-stretch-start", "flex-stretch-end", "flex-close"],
  sink: true
});
// Generated by CoffeeScript 1.9.3
var Layout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Layout = (function(superClass) {
  extend(Layout, superClass);

  function Layout(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    Layout.__super__.constructor.call(this, this.opts);
    this.__isInit = false;
    this.init();
  }

  Layout.prototype.initOpts = function() {
    var i, len, pn, ref, results;
    Layout.__super__.initOpts.call(this);
    this.addOpts({
      absolute: {
        check: Boolean
      },
      maximize: {
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean
      },
      maximize_vertical: {
        check: Boolean
      },
      auto_buttonbar: {
        "default": true,
        mandatory: true,
        check: Boolean
      },
      center: {
        "default": {},
        check: "PlainObject"
      }
    });
    ref = this.getSupportedPanes();
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      results.push(this.addOpt(pn, {
        check: function(v) {
          return CUI.isPlainObject(v) || v === false;
        }
      }));
    }
    return results;
  };

  Layout.prototype.readOpts = function() {
    this.initDefaultPanes();
    Layout.__super__.readOpts.call(this);
    if (isNull(this._maximize) && isNull(this._maximize_horizontal) && isNull(this._maximize_vertical)) {
      this._maximize = true;
    }
    if (this._maximize) {
      assert(!this._maximize_horizontal && !this._maximize_vertical, "new Layout", "opts.maximize cannot be set together with opts.maximize_horizontal or opts.maximize_vertical", {
        opts: this.opts
      });
      this.__maximize_horizontal = true;
      this.__maximize_vertical = true;
    } else {
      if (this._maximize_horizontal) {
        this.__maximize_horizontal = true;
      }
      if (this._maximize_vertical) {
        this.__maximize_vertical = true;
      }
    }
    if (this.__maximize_vertical && this.__maximize_horizontal) {
      this.__maximize = true;
    }
    if (this._absolute) {
      assert(this.__maximize, "new " + this.__cls, "opts.absolute needs opts.maximize to be set.", {
        opts: this.opts
      });
    }
    return this;
  };

  Layout.prototype.init = function() {
    return this.__init();
  };

  Layout.prototype.getTemplateMap = function() {
    var i, len, map, pn, ref;
    map = {};
    ref = this.__panes;
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      map[pn] = true;
    }
    return map;
  };

  Layout.prototype.__init = function() {
    var fn, has_flex_handles, i, len, pane, pn, ref, ref1;
    assert(!(this._maximize === false && this._absolute === true), "Layout.__init", "opts.maximize == false and opts.absolute == true is not allowed.", {
      opts: this.opts
    });
    this.__panes = this.getPanes();
    this.__panes.push("center");
    this.__name = this.getName();
    this.__layout = new Template({
      name: this.__name,
      map_prefix: this.getMapPrefix(),
      map: this.getTemplateMap()
    });
    this.registerTemplate(this.__layout);
    if (this.__maximize) {
      this.addClass("cui-maximize");
    }
    if (this.__maximize_horizontal) {
      this.addClass("cui-maximize-horizontal");
    }
    if (this.__maximize_vertical) {
      this.addClass("cui-maximize-vertical");
    }
    this.addClass("cui-" + this.getMapPrefix());
    if (this._absolute) {
      this.addClass("cui-absolute");
      assert((ref = CUI.DOM.getAttribute(this.DOM, "cui-absolute-container")) === "row" || ref === "column", "new Layout", "opts.absolute: template must include a cui-absolute-container attribute set to \"row\" or \"column\".");
      DOM.waitForDOMInsert({
        node: this.DOM
      }).done((function(_this) {
        return function() {
          return Layout.all();
        };
      })(this));
    }
    this.__buttonbars = {};
    if (this.hasFlexHandles()) {
      has_flex_handles = true;
      this.__layout.initFlexHandles();
    } else {
      has_flex_handles = false;
    }
    CUI.DOM.setAttribute(this.__layout.DOM, "has-flex-handles", (has_flex_handles ? true : false));
    ref1 = this.__panes;
    fn = (function(_this) {
      return function(pn) {
        return _this[pn] = function() {
          assert(_this["_" + pn], _this.__cls + "." + pn, "Pane \"" + pn + "\" not initialized.", {
            opts: _this.opts
          });
          assert(!_this.__layout.isDestroyed(), "Layout already destroyed, cannot get pane \"" + pn + "\".");
          return _this.__layout.map[pn];
        };
      };
    })(this);
    for (i = 0, len = ref1.length; i < len; i++) {
      pn = ref1[i];
      fn(pn);
      pane = this["_" + pn];
      if (pane) {
        this.__initPane(pane, pn);
        if (has_flex_handles && pn !== "center" && !pane.flexHandle) {
          this.__layout.getFlexHandle(pn).destroy();
        }
      } else {
        this.__layout.map[pn].remove();
        if (has_flex_handles) {
          this.__layout.getFlexHandle(pn).destroy();
        }
      }
    }
    return this.__isInit = true;
  };

  Layout.prototype.destroy = function() {
    Events.ignore({
      instance: this
    });
    return Layout.__super__.destroy.call(this);
  };

  Layout.prototype.getMapPrefix = function() {
    return void 0;
  };

  Layout.prototype.getPaneCheckMap = function() {
    var map;
    map = {
      "class": {
        check: String
      },
      content: {}
    };
    if (this.hasFlexHandles()) {
      map.flexHandle = {
        check: {
          label: {
            check: function(v) {
              return v instanceof Label || CUI.isPlainObject(v);
            }
          },
          hidden: {
            "default": false,
            check: Boolean
          },
          closed: {
            "default": false,
            check: Boolean
          },
          closable: {
            "default": true,
            check: Boolean
          },
          "class": {
            check: String
          }
        }
      };
    }
    return map;
  };

  Layout.prototype.__initPane = function(options, pane_name) {
    var fh, fh_inst, opts;
    assert(pane_name, "Layout.initPane", "pane_name must be set", {
      options: options,
      pane_name: pane_name
    });
    opts = CUI.Element.readOpts(options, "new Layout.__initPane", this.getPaneCheckMap());
    this.append(opts.content, pane_name);
    fh = opts.flexHandle;
    if (fh) {
      fh_inst = this.__layout.getFlexHandle(pane_name);
      if (fh.label) {
        fh_inst.addLabel(fh.label);
      }
      fh_inst.setClosable(fh.closable);
      if (fh.hidden) {
        fh_inst.hide();
      }
      if (fh.closed) {
        fh_inst.close();
      }
      if (fh["class"]) {
        CUI.DOM.addClass(fh_inst.getHandle(), fh["class"]);
      }
    }
    if (opts["class"]) {
      return this.__layout.addClass(opts["class"], pane_name);
    }
  };

  Layout.prototype.hasFlexHandles = function() {
    return true;
  };

  Layout.prototype.initDefaultPanes = function() {
    var i, len, pn, ref;
    ref = this.getPanes();
    for (i = 0, len = ref.length; i < len; i++) {
      pn = ref[i];
      if (!this.opts.hasOwnProperty(pn)) {
        this.opts[pn] = {};
      }
    }
    return this;
  };

  Layout.prototype.getPanes = function() {
    return assert(false, this.__cls + ".getPanes", "Needs implementation");
  };

  Layout.prototype.getSupportedPanes = function() {
    return assert(false, this.__cls + ".getSupportedPanes", "Needs implementation");
  };

  Layout.prototype.getLayout = function() {
    return this.__layout;
  };

  Layout.prototype.getButtonbar = function(key) {
    if (!this.__buttonbars[key]) {
      this.__buttonbars[key] = new Buttonbar();
      DOM.prototype.append.call(this, this.__buttonbars[key], key);
    }
    return this.__buttonbars[key];
  };

  Layout.prototype.__callAutoButtonbar = function(value, key) {
    var _v, get_value, i, len, results, v;
    if (CUI.isFunction(value)) {
      value = value(this);
    }
    get_value = function(v) {
      if (CUI.isPlainObject(v)) {
        return new CUI.defaults["class"].Button(v);
      } else {
        return v;
      }
    };
    value = get_value(value);
    if (CUI.isArray(value)) {
      results = [];
      for (i = 0, len = value.length; i < len; i++) {
        _v = value[i];
        v = get_value(_v);
        if (v instanceof Button) {
          results.push(this.getButtonbar(key).addButton(v));
        } else {
          results.push(DOM.prototype.append.call(this, _v, key));
        }
      }
      return results;
    } else if (value instanceof Button) {
      return this.getButtonbar(key).addButton(value);
    } else {
      return DOM.prototype.append.call(this, value, key);
    }
  };

  Layout.prototype.append = function(value, key, auto_buttonbar) {
    if (auto_buttonbar == null) {
      auto_buttonbar = this._auto_buttonbar;
    }
    if (auto_buttonbar) {
      return this.__callAutoButtonbar(value, key);
    } else {
      return Layout.__super__.append.call(this, value, key);
    }
  };

  Layout.prototype.replace = function(value, key, auto_buttonbar) {
    if (auto_buttonbar == null) {
      auto_buttonbar = this._auto_buttonbar;
    }
    if (auto_buttonbar) {
      delete this.__buttonbars[key];
      this.empty(key);
      return this.__callAutoButtonbar(value, key);
    } else {
      return Layout.__super__.replace.call(this, value, key);
    }
  };

  Layout.prototype.getName = function() {
    return assert(false, this.__cls + ".getName", "Needs to be overwritten.");
  };

  Layout.setAbsolute = function(layout) {
    var abs_values, check_value, child, children, css, direction, i, idx, j, k, key, len, len1, len2, rect_check_key, rect_key, ref, set, value, values;
    assert(isElement(layout), "Layout.setAbsolute", "layout needs to be HTMLElement", {
      layout: layout
    });
    direction = CUI.DOM.getAttribute(layout, "cui-absolute-container");
    switch (direction) {
      case "row":
        rect_key = "marginBoxWidth";
        rect_check_key = "marginBoxHeight";
        break;
      case "column":
        rect_key = "marginBoxHeight";
        rect_check_key = "marginBoxWidth";
        break;
      default:
        assert(false, "Layout.setAbsolute", "cui-absolute-container is not set for .cui-absolute container or not set to row or column.", {
          container: layout,
          direction: direction
        });
    }
    values = [];
    children = DOM.children(layout);
    for (idx = i = 0, len = children.length; i < len; idx = ++i) {
      child = children[idx];
      values[idx] = DOM.getDimensions(child)[rect_key];
    }
    abs_values = values.join(",");
    check_value = DOM.getDimensions(layout)[rect_check_key] + "";
    if (CUI.DOM.getAttribute(layout, "cui-absolute-values") === abs_values && CUI.DOM.getAttribute(layout, "cui-absolute-check-value") === check_value) {
      return false;
    }
    if (CUI.DOM.getAttribute(layout, "cui-absolute-check-value") !== check_value) {
      CUI.DOM.setAttribute(layout, "cui-absolute-check-value", check_value);
    }
    if (CUI.DOM.getAttribute(layout, "cui-absolute-values") !== abs_values) {
      CUI.DOM.setAttribute(layout, "cui-absolute-values", abs_values);
      for (idx = j = 0, len1 = children.length; j < len1; idx = ++j) {
        child = children[idx];
        set = CUI.DOM.getAttribute(child, "cui-absolute-set");
        if (!set) {
          continue;
        }
        css = {};
        ref = set.split(",");
        for (k = 0, len2 = ref.length; k < len2; k++) {
          key = ref[k];
          switch (key) {
            case "left":
            case "top":
              if (idx > 0) {
                value = values.slice(0, idx).reduce(function(a, b) {
                  return a + b;
                });
              } else {
                value = 0;
              }
              break;
            case "right":
            case "bottom":
              if (idx + 1 < values.length) {
                value = values.slice(idx + 1).reduce(function(a, b) {
                  return a + b;
                });
              } else {
                value = 0;
              }
              break;
            default:
              assert(false, "Layout.setAbsolute: Unknown key " + key + " in cui-absolute-set.");
          }
          css[key] = value;
        }
        DOM.setStyle(child, css);
      }
    }
    return true;
  };

  Layout.__all = function() {
    var changed, i, idx, layout, layouts, len, ref;
    layouts = [];
    changed = 0;
    ref = DOM.matchSelector(document.documentElement, ".cui-layout.cui-absolute");
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      layout = ref[idx];
      if (Layout.setAbsolute(layout)) {
        changed++;
      }
    }
    if (changed > 0) {
      Events.trigger({
        type: "viewport-resize"
      });
    }
    return this;
  };

  Layout.all = function() {
    return CUI.scheduleCallback({
      call: Layout.__all
    });
  };

  return Layout;

})(CUI.DOM);

Layout = CUI.Layout;

CUI.ready(function() {
  return Events.listen({
    type: ["viewport-resize", "content-resize"],
    call: function(ev, info) {
      if (info.FlexHandle) {
        return Layout.__all();
      } else {
        return Layout.all();
      }
    }
  });
});
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.Layer = (function(superClass) {
  extend(Layer, superClass);

  function Layer(opts) {
    var bc, body_clone, cls;
    this.opts = opts != null ? opts : {};
    Layer.__super__.constructor.call(this, this.opts);
    this.__layer = this.getTemplate();
    this.registerTemplate(this.__layer);
    this.__layer_root = new Template({
      "class": "cui-layer-root-" + (toDash(this.__cls) + " " + this._class).trim().split(/\s+/).join(" cui-layer-root-"),
      name: "layer-root"
    });
    if (this._backdrop) {
      this.__bd_policy = this._backdrop.policy || "click-thru";
      this.__backdrop = new Template({
        "class": "cui-layer-backdrop",
        name: "layer-backdrop"
      });
      this.__layer_root.addClass("cui-layer-backdrop-policy-" + this.__bd_policy);
      if (this._backdrop.content) {
        this.setBackdropContent(this._backdrop.content);
      } else if (this._backdrop.blur) {
        body_clone = document.body.firstChild.cloneNode(true);
        if (this.__bd_policy === "click-thru") {
          this.__backdrop_crop = this.__backdrop.DOM;
          this.setBackdropContent(body_clone);
        } else {
          this.__backdrop_crop = $div("cui-layer-backdrop-body-clone")[0];
          this.__backdrop_crop.appendChild(body_clone);
          this.setBackdropContent(this.__backdrop_crop);
        }
        this.__layer_root.addClass("cui-layer-root-backdrop-blur");
      }
      if (this.__bd_policy === "click-thru" && !this._backdrop.blur && !this._backdrop.content) {

      } else {
        this.__layer_root.DOM.appendChild(this.__backdrop.DOM);
        switch (this.__bd_policy) {
          case "click-thru":
            break;
          case "click":
            Events.listen({
              type: ["click", "contextmenu"],
              node: this.__backdrop,
              call: (function(_this) {
                return function(ev) {
                  if (ev.ctrlKey() && ev.getButton() === 2) {
                    return;
                  }
                  _this.hide(ev);
                  return ev.stopPropagation();
                };
              })(this)
            });
            break;
          case "modal":
            this.__backdrop.addClass("layer-backdrop-modal");
            if (this._backdrop.add_bounce_class !== false) {
              if (isString(this._backdrop.add_bounce_class)) {
                bc = this._backdrop.add_bounce_class;
              } else {
                bc = "cui-layer-bounce";
              }
              Events.listen({
                type: "click",
                node: this.__backdrop,
                call: (function(_this) {
                  return function(ev) {
                    CUI.debug("clicked on modal backdrop", bc, _this._backdrop);
                    if (!_this.__layer) {
                      return;
                    }
                    Events.wait({
                      type: "transitionend",
                      node: _this.__layer
                    }).always(function() {
                      if (_this.isDestroyed()) {
                        return;
                      }
                      return _this.__layer.removeClass(bc);
                    });
                    _this.__layer.addClass(bc);
                  };
                })(this)
              });
            }
            break;
          default:
            assert("new " + this.__cls, "Unknown backdrop policy: \"" + this.__bd_policy + "\".");
        }
      }
    }
    if (this._visible === false) {
      this.setVisible(this._visible);
    }
    this.__layer_root.DOM.appendChild(this.__layer.DOM);
    Events.listen({
      type: "click",
      node: this.__layer,
      call: (function(_this) {
        return function(ev) {
          if (!ev.altKey()) {
            return;
          }
          _this.hide();
          return _this.show();
        };
      })(this)
    });
    if (this._handle_focus) {
      DOM.setAttribute(this.__layer.DOM, "tabindex", "0");
    }
    if (this._element) {
      this.__setElement(this._element);
    }
    if (this._use_element_width_as_min_width) {
      assert(this.__element, "new CUI.Layer", "opts.use_element_width_as_min_width requires opts.element to be set.", {
        opts: this.opts
      });
    }
    if (this._pointer) {
      if (this._class) {
        cls = "cui-layer-pointer-" + this._class.split(/\s+/).join(" cui-layer-pointer-");
      }
      this.__pointer = new Template({
        "class": cls,
        name: "layer-pointer"
      }).DOM;
      this.__layer_root.DOM.appendChild(this.__pointer);
    }
    this.__shown = false;
  }

  Layer.prototype.setBackdropContent = function(content) {
    assert(this.__backdrop, "CUI.Layer.setBackdropContent", "No backdrop found in layer", {
      layer: this
    });
    return this.__backdrop.DOM.append(content);
  };

  Layer.prototype.getTemplate = function() {
    return new Template({
      name: "layer"
    });
  };

  Layer.prototype.getLayerRoot = function() {
    return this.__layer_root;
  };

  Layer.prototype.getLayer = function() {
    return this.__layer;
  };

  Layer.prototype.initOpts = function() {
    Layer.__super__.initOpts.call(this);
    this.addOpts({
      backdrop: {
        "default": {
          policy: "click-thru",
          add_bounce_class: true,
          content: null
        },
        check: function(v) {
          if (CUI.isPlainObject(v) || v === false) {
            return true;
          }
        }
      },
      add_bounce_class: {
        deprecated: "use backdrop.add_bounce_class instead"
      },
      onBeforeShow: {
        check: Function
      },
      onShow: {
        check: Function
      },
      onPosition: {
        check: Function
      },
      onHide: {
        check: Function
      },
      handle_focus: {
        "default": true,
        check: Boolean
      },
      pointer: {
        check: ["arrow"]
      },
      placement: {
        check: String
      },
      placements: {
        check: function(v) {
          var a, i, len;
          if (!CUI.isArray(v)) {
            return false;
          }
          for (i = 0, len = v.length; i < len; i++) {
            a = v[i];
            if (CUI.Layer.knownPlacements.indexOf(a) === -1) {
              return false;
            }
          }
          return true;
        }
      },
      element: {
        check: function(v) {
          return isElement(v) || isElement(v != null ? v.DOM : void 0);
        }
      },
      use_element_width_as_min_width: {
        "default": false,
        check: Boolean
      },
      show_at_position: {
        check: function(v) {
          return CUI.isPlainObject(v) && v.top >= 0 && v.left >= 0;
        }
      },
      fill_space: {
        check: ["auto", "both", "horizontal", "vertical"]
      },
      check_for_element: {
        "default": false,
        check: Boolean
      },
      auto_size: {
        "default": true,
        check: Boolean
      },
      show_ms: {
        "default": 700,
        check: (function(_this) {
          return function(v) {
            return v > 0;
          };
        })(this)
      },
      visible: {
        check: Boolean
      },
      hide_ms: {
        "default": 100,
        check: (function(_this) {
          return function(v) {
            return v > 0;
          };
        })(this)
      }
    });
    return this;
  };

  Layer.prototype.setVisible = function(on_off) {
    if (on_off == null) {
      on_off = true;
    }
    if (on_off) {
      return DOM.setStyleOne(this.__layer_root.DOM[0], "visibility", "");
    } else {
      return DOM.setStyleOne(this.__layer_root.DOM[0], "visibility", "hidden");
    }
  };

  Layer.knownPlacements = ["s", "e", "w", "ws", "wn", "n", "se", "ne", "es", "en", "nw", "sw", "c"];

  Layer.prototype.__setElement = function(element) {
    if (element.DOM) {
      this.__element = element.DOM;
    } else {
      this.__element = element;
    }
    assert(!DOM.closest(this.__element, ".cui-tmpl"), "Layer.__setElement", "element cannot be inside a Template.", {
      element: element
    });
    assert(this.__element instanceof HTMLElement, "Layer.__setElement", "element needs to be HTMLElement.", {
      element: element
    });
    return this.__element;
  };

  Layer.prototype.autoSize = function() {
    return this.position();
  };

  Layer.prototype.position = function(ev) {
    var allowed_placements, available_placements, dbg_pl, dim_element, dim_layer, dim_pointer, dim_window, direction, get_pointer_class, get_pointer_direction, i, j, k, l, layer_pos, layer_pos_bottom, layer_pos_right, len, len1, len2, len3, len4, listener, m, marginBottom, marginLeft, marginRight, marginTop, minWidth, overlap_bottom, overlap_height, overlap_right, overlap_width, placement, placement_parts, pointer_direction, pointer_pos, pointer_pos_bottom, pointer_pos_right, pushNeeded, ref, ref1, ref2, ref3, ref4, show_dbg_div, spaceAvailable, vp, vp_pl, wanted_placement, wanted_rank;
    if (!this.isShown()) {
      return;
    }
    dim_window = CUI.DOM.getDimensions(window);
    get_pointer_direction = function(placement) {
      return {
        n: "s",
        s: "n",
        e: "w",
        w: "e"
      }[placement];
    };
    get_pointer_class = (function(_this) {
      return function(direction) {
        if (CUI.__ng__) {
          return "cui-layer-pointer--" + direction;
        } else {
          return "cui-pointer-placement-" + get_pointer_direction(direction);
        }
      };
    })(this);
    if (this.__pointer) {
      CUI.DOM.setStyle(this.__pointer, {
        top: 0,
        left: 0,
        margin: ""
      });
      ref = ["w", "s", "e", "n"];
      for (i = 0, len = ref.length; i < len; i++) {
        direction = ref[i];
        CUI.DOM.removeClass(this.__pointer, get_pointer_class(direction));
      }
    }
    dim_pointer = {};
    ref1 = ["n", "s", "e", "w"];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      placement = ref1[j];
      pointer_direction = get_pointer_direction(placement);
      if (this.__pointer) {
        CUI.DOM.addClass(this.__pointer, get_pointer_class(pointer_direction));
        dim_pointer[placement] = CUI.DOM.getDimensions(this.__pointer);
        CUI.DOM.removeClass(this.__pointer, get_pointer_class(pointer_direction));
      } else {
        dim_pointer[placement] = {
          borderBoxWidth: 0,
          borderBoxHeight: 0,
          marginLeft: 0,
          marginRight: 0,
          marginTop: 0,
          marginBottom: 0
        };
      }
      dim_pointer[placement].direction = pointer_direction;
    }
    CUI.DOM.setStyle(this.__layer.DOM, {
      top: 0,
      left: 0,
      width: "",
      height: "",
      margin: "",
      "max-width": "",
      "max-height": ""
    });
    dim_layer = CUI.DOM.getDimensions(this.__layer.DOM);
    allowed_placements = (this._placements || CUI.Layer.knownPlacements).slice(0);
    wanted_placement = this._placement || allowed_placements[0];
    if (this.__element) {
      dim_element = CUI.DOM.getDimensions(this.__element);
    } else if (this._show_at_position) {
      dim_element = {
        viewportTop: this._show_at_position.top,
        viewportLeft: this._show_at_position.left
      };
      dim_element.viewportBottom = dim_element.viewportTop;
      dim_element.viewportRight = dim_element.viewportLeft;
    } else {
      dim_element = {
        viewportTop: 0,
        viewportLeft: 0,
        viewportBottom: dim_window.height,
        viewportRight: dim_window.width,
        viewportCenterLeft: dim_window.width / 2,
        viewportCenterTop: dim_window.height / 2,
        borderBoxWidth: dim_window.width,
        borderBoxHeight: dim_window.height
      };
    }
    vp_pl = {};
    ref2 = CUI.Layer.knownPlacements;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      placement = ref2[k];
      if (placement !== "n" && placement !== "s" && placement !== "e" && placement !== "w" && placement !== "c") {
        continue;
      }
      vp_pl[placement] = vp = {};
      vp.window_top = dim_layer.marginTop;
      vp.window_left = dim_layer.marginLeft;
      vp.window_right = dim_window.width - dim_layer.marginRight;
      vp.window_bottom = dim_window.height - dim_layer.marginBottom;
      vp.dim_window = dim_window;
      vp.dim_layer = dim_layer;
      vp.dim_element = dim_element;
      vp.dim_pointer = dim_pointer[placement];
      switch (placement) {
        case "c":
          vp.top = vp.window_top;
          vp.left = vp.window_left;
          vp.right = vp.window_right;
          vp.bottom = vp.window_bottom;
          vp.align_vertical = "center";
          vp.align_horizontal = "center";
          break;
        case "n":
          vp.top = dim_layer.marginTop;
          vp.left = dim_layer.marginLeft;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_element.viewportTop - vp.dim_pointer.borderBoxHeight - vp.dim_pointer.marginBottom;
          vp.align_vertical = "bottom";
          vp.align_horizontal = "center";
          break;
        case "s":
          vp.top = dim_element.viewportBottom + vp.dim_pointer.borderBoxHeight + vp.dim_pointer.marginTop;
          vp.left = dim_layer.marginLeft;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.align_vertical = "top";
          vp.align_horizontal = "center";
          break;
        case "e":
          vp.top = dim_layer.marginTop;
          vp.right = dim_window.width - dim_layer.marginRight;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.left = dim_element.viewportRight + vp.dim_pointer.borderBoxWidth + vp.dim_pointer.marginLeft;
          vp.align_vertical = "center";
          vp.align_horizontal = "left";
          break;
        case "w":
          vp.top = dim_layer.marginTop;
          vp.bottom = dim_window.height - dim_layer.marginBottom;
          vp.right = dim_element.viewportLeft - vp.dim_pointer.borderBoxWidth - vp.dim_pointer.marginRight;
          vp.left = dim_layer.marginLeft;
          vp.align_vertical = "center";
          vp.align_horizontal = "right";
      }
      vp.pointer_align_vertical = vp.align_vertical;
      vp.pointer_align_horizontal = vp.align_horizontal;
      vp.overlap_align = null;
    }
    ref3 = CUI.Layer.knownPlacements;
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      placement = ref3[l];
      if (placement === "n" || placement === "s" || placement === "e" || placement === "w" || placement === "c") {
        continue;
      }
      placement_parts = placement.split("");
      vp_pl[placement] = vp = copyObject(vp_pl[placement_parts[0]]);
      vp.dim_pointer = dim_pointer[placement_parts[0]];
      if (!vp) {
        continue;
      }
      switch (placement_parts[1]) {
        case "s":
          vp.top = dim_element.viewportTop;
          vp.align_vertical = "top";
          vp.pointer_align_vertical = "center";
          vp.overlap_align = "bottom";
          break;
        case "n":
          vp.bottom = dim_element.viewportBottom;
          vp.align_vertical = "bottom";
          vp.pointer_align_vertical = "center";
          vp.overlap_align = "top";
          break;
        case "e":
          vp.left = dim_element.viewportLeft;
          vp.align_horizontal = "left";
          vp.pointer_align_horizontal = "center";
          vp.overlap_align = "right";
          break;
        case "w":
          vp.right = dim_element.viewportRight;
          vp.align_horizontal = "right";
          vp.pointer_align_horizontal = "center";
          vp.overlap_align = "left";
      }
    }
    ref4 = CUI.Layer.knownPlacements;
    for (m = 0, len4 = ref4.length; m < len4; m++) {
      placement = ref4[m];
      if (indexOf.call(allowed_placements, placement) < 0) {
        delete vp_pl[placement];
        continue;
      }
      vp = vp_pl[placement];
      vp.width = vp.right - vp.left;
      vp.height = vp.bottom - vp.top;
      if (vp.width < 10 || vp.height < 10) {
        delete vp_pl[placement];
      }
    }
    for (placement in vp_pl) {
      vp = vp_pl[placement];
      layer_pos = vp.layer_pos = {};
      pointer_pos = vp.pointer_pos = {};
      vp.cuts = 0;
      switch (this._fill_space) {
        case "both":
          layer_pos.width = vp.width;
          layer_pos.height = vp.height;
          break;
        case "vertical":
          layer_pos.height = vp.height;
          layer_pos.width = dim_layer.borderBoxWidth;
          break;
        case "horizontal":
          layer_pos.width = vp.width;
          layer_pos.height = dim_layer.borderBoxHeight;
          break;
        default:
          layer_pos.width = dim_layer.borderBoxWidth;
          layer_pos.height = dim_layer.borderBoxHeight;
      }
      if (layer_pos.width > vp.width) {
        layer_pos.width = vp.width;
        vp.cuts++;
      }
      if (layer_pos.height > vp.height) {
        layer_pos.height = vp.height;
        vp.cuts++;
      }
      switch (vp.align_horizontal) {
        case "left":
          layer_pos.left = vp.left;
          break;
        case "right":
          layer_pos.left = vp.right - layer_pos.width;
          break;
        case "center":
          layer_pos.left = dim_element.viewportCenterLeft - layer_pos.width / 2;
      }
      switch (vp.align_vertical) {
        case "top":
          layer_pos.top = vp.top;
          break;
        case "bottom":
          layer_pos.top = vp.bottom - layer_pos.height;
          break;
        case "center":
          layer_pos.top = dim_element.viewportCenterTop - layer_pos.height / 2;
      }
      if (vp.dim_pointer) {
        switch (vp.pointer_align_horizontal) {
          case "left":
            pointer_pos.left = dim_element.viewportRight + vp.dim_pointer.marginLeft;
            break;
          case "right":
            pointer_pos.left = dim_element.viewportLeft - vp.dim_pointer.borderBoxWidth - vp.dim_pointer.marginLeft;
            break;
          case "center":
            pointer_pos.left = dim_element.viewportCenterLeft - vp.dim_pointer.borderBoxWidth / 2;
        }
        switch (vp.pointer_align_vertical) {
          case "top":
            pointer_pos.top = dim_element.viewportBottom + vp.dim_pointer.marginTop;
            break;
          case "bottom":
            pointer_pos.top = dim_element.viewportTop - vp.dim_pointer.marginBoxHeight + vp.dim_pointer.marginTop;
            break;
          case "center":
            pointer_pos.top = dim_element.viewportCenterTop - vp.dim_pointer.borderBoxHeight / 2;
        }
        pointer_pos.width = vp.dim_pointer.borderBoxWidth;
        pointer_pos.height = vp.dim_pointer.borderBoxHeight;
        pointer_pos.direction = vp.dim_pointer.direction;
      }
      if (layer_pos.top < vp.top) {
        layer_pos.top = vp.top;
        vp.cuts++;
      }
      if (layer_pos.left < vp.left) {
        layer_pos.left = vp.left;
        vp.cuts++;
      }
      overlap_bottom = layer_pos.top + layer_pos.height - vp.bottom;
      if (overlap_bottom > 0) {
        layer_pos.top = layer_pos.top - overlap_bottom;
      }
      overlap_right = layer_pos.left + layer_pos.width - vp.right;
      if (overlap_right > 0) {
        layer_pos.left = layer_pos.left - overlap_right;
      }
      vp.overlap_height = 0;
      vp.overlap_width = 0;
      if (this.__pointer || this._show_at_position) {
        overlap_height = dim_layer.borderBoxHeight - layer_pos.height;
        if (overlap_height > 0) {
          switch (vp.overlap_align) {
            case "bottom":
              vp.overlap_height = Math.min(layer_pos.top - vp.window_top, overlap_height);
              layer_pos.top = layer_pos.top - vp.overlap_height;
              layer_pos.height = layer_pos.height + vp.overlap_height;
              break;
            case "top":
              vp.overlap_height = Math.min(vp.window_bottom - layer_pos.top - layer_pos.height, overlap_height);
              layer_pos.height = layer_pos.height + vp.overlap_height;
          }
        }
        overlap_width = dim_layer.borderBoxWidth - layer_pos.width;
        if (overlap_width > 0) {
          switch (vp.overlap_align) {
            case "right":
              vp.overlap_width = Math.min(layer_pos.left - vp.window_left, overlap_width);
              layer_pos.left = layer_pos.left - vp.overlap_width;
              layer_pos.width = layer_pos.width + vp.overlap_width;
              break;
            case "left":
              vp.overlap_height = Math.min(vp.window_right - layer_pos.right, overlap_width);
              layer_pos.width = layer_pos.width + vp.overlap_width;
          }
        }
      }
      if (this.__pointer) {
        layer_pos_right = vp.layer_pos.left + vp.layer_pos.width;
        layer_pos_bottom = vp.layer_pos.top + vp.layer_pos.height;
        pointer_pos_right = vp.pointer_pos.left + vp.pointer_pos.width;
        pointer_pos_bottom = vp.pointer_pos.top + vp.pointer_pos.height;
        switch (vp.pointer_pos.direction) {
          case "n":
          case "s":
            marginLeft = vp.pointer_pos.left - vp.layer_pos.left;
            pushNeeded = marginLeft - vp.dim_pointer.marginLeft;
            if (pushNeeded < 0) {
              spaceAvailable = vp.layer_pos.left - vp.window_left;
              vp.push_left = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.left = vp.layer_pos.left - vp.push_left;
            }
            marginRight = layer_pos_right - pointer_pos_right;
            pushNeeded = marginRight - vp.dim_pointer.marginRight;
            if (pushNeeded < 0) {
              spaceAvailable = vp.window_right - layer_pos_right;
              vp.push_right = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.left = vp.layer_pos.left + vp.push_right;
            }
            break;
          case "e":
          case "w":
            marginTop = vp.pointer_pos.top - vp.layer_pos.top;
            pushNeeded = marginTop - vp.dim_pointer.marginTop;
            if (pushNeeded < 0) {
              spaceAvailable = vp.layer_pos.top - vp.window_top;
              vp.push_top = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.top = vp.layer_pos.top - vp.push_top;
            }
            marginBottom = layer_pos_bottom - pointer_pos_bottom;
            pushNeeded = marginBottom - vp.dim_pointer.marginBottom;
            if (pushNeeded < 0) {
              spaceAvailable = vp.window_bottom - layer_pos_bottom;
              vp.push_bottom = Math.min(spaceAvailable, -pushNeeded);
              vp.layer_pos.top = vp.layer_pos.top + vp.push_bottom;
            }
        }
      }
      if (this._onPosition) {
        if (typeof this._onPosition === "function") {
          this._onPosition(this, vp);
        }
      }
      vp.layer_pos.estate = vp.layer_pos.width * vp.layer_pos.height;
      vp.layer_pos.aspect_ratio = vp.layer_pos.width / vp.layer_pos.height;
      vp.dim_layer.aspect_ratio = vp.dim_layer.borderBoxWidth / vp.dim_layer.borderBoxHeight;
      wanted_rank = allowed_placements.length - idxInArray(placement, allowed_placements);
      if (wanted_placement === placement) {
        wanted_rank = allowed_placements.length + 1;
      }
      vp.ranking = wanted_rank * 10 + 1 - Math.abs(vp.layer_pos.aspect_ratio - vp.dim_layer.aspect_ratio) + vp.layer_pos.estate;
    }
    available_placements = [];
    for (placement in vp_pl) {
      vp = vp_pl[placement];
      available_placements.push(placement);
    }
    assert(available_placements.length > 0, "Layer.position", "No available placements found.", {
      vp_pl: vp_pl
    });
    available_placements.sort(function(pl1, pl2) {
      var value;
      value = function(pl) {
        return vp_pl[pl].ranking;
      };
      return compareIndex(value(pl1), value(pl2));
    });
    available_placements.reverse();
    placement = available_placements[0];
    if (ev != null ? ev.hasModifierKey() : void 0) {
      console.debug("layer", dim_layer);
      console.debug("element", dim_element);
      console.debug("pointer", dim_pointer);
      console.debug("window", dim_window);
      console.debug("placements", placement, vp_pl);
      show_dbg_div = (function(_this) {
        return function(placement) {
          var _vp, span, style1, style2, style3;
          _this.__removeDebugDivs();
          _vp = vp_pl[placement];
          console.info("Layer: Placement", placement, _vp);
          _this.__dbg_div1 = CUI.DOM.element("DIV");
          _this.__dbg_div2 = CUI.DOM.element("DIV");
          _this.__dbg_div3 = CUI.DOM.element("DIV");
          style1 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #ff0032",
            backgroundColor: "rgba(255, 0, 0, 0.4)",
            top: _vp.top,
            left: _vp.left,
            width: _vp.width,
            height: _vp.height
          };
          DOM.setStyle(_this.__dbg_div1, style1);
          style2 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #00ff32",
            backgroundColor: "rgba(0, 255, 0, 0.4)",
            top: _vp.layer_pos.top,
            left: _vp.layer_pos.left,
            width: _vp.layer_pos.width,
            height: _vp.layer_pos.height,
            alignItems: "center",
            justifyContent: "center",
            fontSize: 40,
            color: "rgb(0,255,50)"
          };
          span = CUI.DOM.element("SPAN");
          span.textContent = placement;
          _this.__dbg_div2.appendChild(span);
          DOM.setStyle(_this.__dbg_div2, style2);
          style3 = {
            position: "absolute",
            zIndex: 2,
            border: "2px solid #0032ff",
            backgroundColor: "rgba(0, 0, 255, 0.4)",
            top: _vp.pointer_pos.top,
            left: _vp.pointer_pos.left,
            width: _vp.pointer_pos.width,
            height: _vp.pointer_pos.height
          };
          DOM.setStyle(_this.__dbg_div3, style3);
          _this.__layer_root.DOM.appendChild(_this.__dbg_div1);
          _this.__layer_root.DOM.appendChild(_this.__dbg_div2);
          if (_this.__pointer) {
            return _this.__layer_root.DOM.appendChild(_this.__dbg_div3);
          }
        };
      })(this);
      dbg_pl = 0;
      listener = Events.listen({
        node: document,
        type: "keyup",
        call: (function(_this) {
          return function(ev, info) {
            var _placement;
            if (ev.keyCode() !== 32) {
              return;
            }
            while (true) {
              dbg_pl = dbg_pl + 1;
              if (dbg_pl === CUI.Layer.knownPlacements.length) {
                _this.__removeDebugDivs();
                listener.destroy();
                return;
              }
              _placement = CUI.Layer.knownPlacements[dbg_pl];
              if (vp_pl[_placement]) {
                show_dbg_div(_placement);
                return;
              }
              console.warn("Placement", _placement, "is unavailable.");
            }
          };
        })(this)
      });
    }
    vp = vp_pl[placement];
    if (vp.layer_pos.width < 10 || vp.layer_pos.height < 10) {
      console.warn("Layer: DIM is very small, layer might not be visible. Placement:", placement, "Dimensions:", vp, "Layer:", this.__layer.DOM);
    }
    if (this._element && this._use_element_width_as_min_width) {
      minWidth = dim_element.borderBoxWidth;
    } else {
      minWidth = void 0;
    }
    CUI.DOM.setStyle(this.__layer.DOM, {
      top: vp.layer_pos.top,
      left: vp.layer_pos.left,
      width: vp.layer_pos.width,
      height: vp.layer_pos.height,
      minWidth: minWidth,
      margin: 0
    });
    if (this.__pointer) {
      CUI.DOM.setStyle(this.__pointer, {
        top: vp.pointer_pos.top,
        left: vp.pointer_pos.left,
        margin: 0
      });
      CUI.DOM.addClass(this.__pointer, get_pointer_class(vp.pointer_pos.direction));
    }
    if (this.__backdrop_crop) {
      DOM.setStyle(this.__backdrop_crop, {
        top: vp.layer_pos.top,
        left: vp.layer_pos.left,
        width: vp.layer_pos.width,
        height: vp.layer_pos.height
      });
      DOM.setStyle(this.__backdrop_crop.firstChild, {
        width: dim_window.width,
        height: dim_window.height,
        top: -vp.layer_pos.top,
        left: -vp.layer_pos.left
      });
    }
  };

  Layer.prototype.__removeDebugDivs = function() {
    var ref, ref1, ref2;
    if ((ref = this.__dbg_div1) != null) {
      ref.remove();
    }
    if ((ref1 = this.__dbg_div2) != null) {
      ref1.remove();
    }
    if ((ref2 = this.__dbg_div3) != null) {
      ref2.remove();
    }
    this.__dbg_div1 = null;
    this.__dbg_div2 = null;
    return this.__dbg_div3 = null;
  };

  Layer.prototype.clearTimeout = function() {
    if (this.__timeout) {
      CUI.clearTimeout(this.__timeout);
    }
    this.__timeout = null;
    return this;
  };

  Layer.prototype.showTimeout = function(ms, ev) {
    var dfr;
    if (ms == null) {
      ms = this._show_ms;
    }
    this.clearTimeout();
    dfr = new CUI.Deferred();
    this.__timeout = CUI.setTimeout({
      ms: ms,
      track: false,
      onReset: (function(_this) {
        return function() {
          return dfr.reject();
        };
      })(this),
      onDone: (function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this),
      call: (function(_this) {
        return function() {
          if (_this.__element && !CUI.DOM.isInDOM(_this.__element)) {
            _this.destroy();
            return;
          }
          return _this.show(null, ev);
        };
      })(this)
    });
    return dfr.promise();
  };

  Layer.prototype.hideTimeout = function(ms, ev) {
    var dfr;
    if (ms == null) {
      ms = this._hide_ms;
    }
    this.clearTimeout();
    dfr = new CUI.Deferred();
    this.__timeout = CUI.setTimeout({
      ms: ms,
      track: false,
      onReset: (function(_this) {
        return function() {
          return dfr.reject();
        };
      })(this),
      onDone: (function(_this) {
        return function() {
          return dfr.resolve();
        };
      })(this),
      call: (function(_this) {
        return function() {
          return _this.hide(ev);
        };
      })(this)
    });
    return dfr.promise();
  };

  Layer.prototype.hide = function(ev) {
    var ref;
    this.clearTimeout();
    if (this.isDestroyed()) {
      return;
    }
    if (!this.isShown()) {
      return this;
    }
    this.__removeDebugDivs();
    if (this.__element) {
      if (this.__check_for_element) {
        CUI.clearInterval(this.__check_for_element);
      }
      this.__element.removeClass("cui-layer-active");
    }
    this.__layer_root.DOM.detach();
    CUI.DOM.setAttributeMap(this.__layer_root.DOM[0], {
      "cui-layer-stack-number": null,
      "cui-layer-stack-count": null
    });
    this.__updateLayerStackCounter();
    this.__shown = false;
    if (this._handle_focus) {
      this.focusOnHide(ev);
    }
    Events.ignore({
      instance: this
    });
    if ((ref = this.__clickThruListener) != null) {
      ref.destroy();
    }
    this.__clickThruListener = null;
    if (typeof this._onHide === "function") {
      this._onHide(this, ev);
    }
    return this;
  };

  Layer.prototype.__updateLayerStackCounter = function() {
    var el, i, idx, layer_elements, len, total;
    layer_elements = CUI.DOM.matchSelector(document.documentElement, "body > .cui-tmpl-layer-root");
    total = layer_elements.length;
    for (idx = i = 0, len = layer_elements.length; i < len; idx = ++i) {
      el = layer_elements[idx];
      CUI.DOM.setAttributeMap(el, {
        "cui-layer-stack-number": idx,
        "cui-layer-stack-count": total
      });
    }
    return this;
  };

  Layer.prototype.show = function(ev) {
    var i, len, ref, scroll_parent;
    assert(!this.isDestroyed(), this.__cls + ".show", "Unable to show, Layer #" + (this.getUniqueId()) + " is already destroyed", {
      layer: this
    });
    if (Tooltip.current && !(this instanceof Tooltip)) {
      Tooltip.current.hide();
    }
    this.clearTimeout();
    if (this.isShown()) {
      this.position();
      return this;
    }
    document.body.appendChild(this.__layer_root.DOM);
    if (this.__element) {
      this.__element.addClass("cui-layer-active");
      ref = CUI.DOM.parentsScrollable(this.__element);
      for (i = 0, len = ref.length; i < len; i++) {
        scroll_parent = ref[i];
        Events.listen({
          type: "scroll",
          instance: this,
          node: scroll_parent,
          call: (function(_this) {
            return function() {
              return _this.position();
            };
          })(this)
        });
      }
      if (this._check_for_element) {
        this.__check_for_element = CUI.setInterval((function(_this) {
          return function() {
            if (!CUI.DOM.isInDOM(_this.__element)) {
              return _this.destroy();
            }
          };
        })(this), 200);
      }
    }
    this.__updateLayerStackCounter();
    if (this._auto_size) {
      Events.listen({
        type: "content-resize",
        instance: this,
        node: this.__layer,
        call: (function(_this) {
          return function(ev) {
            return _this.position();
          };
        })(this)
      });
    }
    Events.listen({
      type: "viewport-resize",
      instance: this,
      node: this.__layer,
      call: (function(_this) {
        return function(ev) {
          if (_this.__element && !CUI.DOM.isInDOM(_this.__element)) {
            return;
          }
          _this.position();
        };
      })(this)
    });
    if (typeof this._onBeforeShow === "function") {
      this._onBeforeShow(this, ev);
    }
    this.__shown = true;
    this.position(ev);
    if (this._handle_focus) {
      this.focusOnShow(ev);
    }
    if (typeof this._onShow === "function") {
      this._onShow(this, ev);
    }
    return this;
  };

  Layer.prototype.isKeyboardCancellable = function(ev) {
    var ref;
    if ((ref = this.__bd_policy) === "click" || ref === "click-thru") {
      return true;
    } else {
      return false;
    }
  };

  Layer.prototype.doCancel = function(ev) {
    return this.hide(ev);
  };

  Layer.prototype.focusOnShow = function(ev) {
    if (ev === CUI.KeyboardEvent) {
      this.__focused_on_show = true;
    } else if (this.__element && DOM.matchSelector(document.documentElement, ":focus").length > 0) {

    } else {
      this.__focused_on_show = false;
    }
    if (this.__focused_on_show) {
      this.DOM[0].focus();
    }
    return this;
  };

  Layer.prototype.focusOnHide = function(ev) {
    var ref;
    if (!this.__element) {
      return this;
    }
    if (ev === CUI.KeyboardEvent || this.__focused_on_show) {
      if ((ref = DOM.findElement(this.__element[0], "[tabindex]")) != null) {
        ref.focus();
      }
    }
    return this;
  };

  Layer.prototype.getElement = function() {
    return this.__element;
  };

  Layer.prototype.isShown = function() {
    return this.__shown;
  };

  Layer.prototype.destroy = function() {
    var ref, ref1, ref2, ref3;
    this.clearTimeout();
    if (this.__shown) {
      this.hide();
    }
    Layer.__super__.destroy.call(this);
    if ((ref = this.__layer) != null) {
      ref.destroy();
    }
    if ((ref1 = this.__layer_root) != null) {
      ref1.destroy();
    }
    this.__layer = null;
    this.__layer_root = null;
    if ((ref2 = this.__pointer) != null) {
      ref2.remove();
    }
    this.__pointer = null;
    if ((ref3 = this.__backdrop) != null) {
      ref3.destroy();
    }
    return this.__backdrop = null;
  };

  return Layer;

})(CUI.DOM);

CUI.ready(function() {
  Events.listen({
    type: ["mousedown"],
    capture: true,
    node: document.body,
    call: function(ev) {
      var layer, layer_element, layer_elements, target;
      layer_elements = DOM.findElements(document.body, "body > .cui-tmpl-layer-root");
      target = ev.getTarget();
      while (layer_element = layer_elements.pop()) {
        if (!CUI.DOM.hasClass(layer_element, "cui-layer-backdrop-policy-click-thru")) {
          return;
        }
        if (CUI.DOM.closest(target, layer_element)) {
          return;
        }
        layer = DOM.data(CUI.DOM.children(layer_element, ".cui-layer")[0], "element");
        layer.hide(ev);
      }
    }
  });
  return Events.listen({
    type: ["keyup"],
    capture: true,
    node: document.body,
    call: function(ev) {
      var element, layer, layer_element, layer_elements;
      if (ev.keyCode() !== 27) {
        return;
      }
      layer_elements = DOM.findElements(document.body, "body > .cui-tmpl-layer-root > .cui-layer");
      layer_element = layer_elements[layer_elements.length - 1];
      element = CUI.DOM.closest(ev.getTarget(), "[tabindex],input,textarea");
      if ((element && element !== layer_element) || !layer_element) {
        return;
      }
      layer = DOM.data(layer_element, "element");
      ev.stopImmediatePropagation();
      ev.preventDefault();
      if (layer.isKeyboardCancellable(ev)) {
        layer.doCancel(ev);
        return false;
      }
    }
  });
});
// Generated by CoffeeScript 1.9.3
var DataField,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

CUI.DataField = (function(superClass) {
  extend(DataField, superClass);

  DataField.changed_marker_css_class = "cui-data-field-changed-marker";

  function DataField(opts) {
    var tt_opts;
    this.opts = opts != null ? opts : {};
    DataField.__super__.constructor.call(this, this.opts);
    assertImplements(this, ["render"]);
    if (this._name) {
      assertImplements(this, ["getDefaultValue"]);
    }
    this.__checkChangedValue = void 0;
    this.initTemplate();
    this.addClass("cui-data-field");
    Events.listen({
      type: "data-changed",
      node: this.DOM,
      call: (function(_this) {
        return function(ev, info) {
          if (!(info != null ? info.element : void 0)) {
            CUI.warn((getObjectClass(_this)) + "[DataField].listen[data-changed]: received event with element not set.", ev, info, _this);
            return;
          }
          if (typeof _this._onDataChanged === "function") {
            _this._onDataChanged(info.element.getData(), info.element, ev, info);
          }
        };
      })(this)
    });
    if (this.getName()) {
      this.DOM.attr("cui-data-field-name", this.getName());
    }
    this.init();
    if (this._data && !CUI.isFunction(this._data)) {
      this.setData(this._data);
    }
    this.__initDisabled();
    if (this._hidden) {
      this.hide();
    }
    if (this._tooltip) {
      tt_opts = copyObject(this._tooltip);
      tt_opts.element = this.DOM;
      this.__tooltip = new Tooltip(tt_opts);
    }
    this.__opacity = 1;
    if (typeof this._onInit === "function") {
      this._onInit(this);
    }
  }

  DataField.prototype.initOpts = function() {
    DataField.__super__.initOpts.call(this);
    return this.addOpts({
      name: this.getNameOpt(),
      data: {
        check: function(v) {
          return CUI.isFunction(v != null ? v.hasOwnProperty : void 0) || CUI.isFunction(v);
        }
      },
      data_not_for_others: {
        "default": false,
        check: Boolean
      },
      disabled: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      disabled_depends_on_data: {
        check: Function
      },
      tooltip: {
        check: "PlainObject"
      },
      hidden: {
        check: Boolean
      },
      form: {},
      undo_support: {
        "default": true,
        check: Boolean
      },
      undo_and_changed_support: {
        check: Boolean
      },
      mark_changed: {
        "default": true,
        check: Boolean
      },
      check_changed: {
        "default": true,
        check: Boolean
      },
      onDataChanged: {
        check: Function
      },
      onDataInit: {
        check: Function
      },
      onInit: {
        check: Function
      },
      onRender: {
        check: Function
      }
    });
  };

  DataField.prototype.readOpts = function() {
    var i, k, len, ref;
    if (this.opts.hasOwnProperty("undo_and_changed_support")) {
      ref = ["undo_support", "check_changed", "mark_changed"];
      for (i = 0, len = ref.length; i < len; i++) {
        k = ref[i];
        if (!this.opts.hasOwnProperty(k)) {
          this.opts[k] = this.opts.undo_and_changed_support;
        }
      }
    }
    return DataField.__super__.readOpts.call(this);
  };

  DataField.prototype.getUniqueIdForLabel = function() {
    return null;
  };

  DataField.prototype.initTemplate = function() {
    return this.registerTemplate(this.getTemplate());
  };

  DataField.prototype.getTemplate = function() {
    return new Template({
      name: "data-field"
    });
  };

  DataField.prototype.isResizable = function() {
    return false;
  };

  DataField.prototype.init = function() {};

  DataField.prototype.debug = function() {
    CUI.debug("----" + this + "----", this);
    if (this.__data) {
      CUI.debug("data:", this.getData());
      CUI.debug("value:", this.getValue());
      CUI.debug("init-value:", this.getInitValue());
      return CUI.debug("check-changed-value:", this.getCheckChangedValue());
    }
  };

  DataField.prototype.toString = function() {
    return "[" + this.__cls + "[" + this.__uniqueId + ", " + (this._name || '<no name>') + "]}";
  };

  DataField.prototype.reload = function() {
    this.remove();
    this.render();
    return this.displayValue();
  };

  DataField.prototype.remove = function(purge) {
    if (purge == null) {
      purge = false;
    }
    this.callOnOthers("remove");
    if (!this.isDestroyed()) {
      this.empty();
    }
    return this.__isRendered = false;
  };

  DataField.prototype.getNameOpt = function() {
    return {
      check: String
    };
  };

  DataField.prototype.getLabel = function() {
    return this._label;
  };

  DataField.prototype.setForm = function(form) {
    assertImplements(form, ["getFieldsByName", "getFieldByIdx", "getData", "getFields"]);
    this.__form = form;
    if (!this.getForm().getFormPath) {
      return this;
    }
    this.setFormDepth();
    return this;
  };

  DataField.prototype.setFormDepth = function() {
    var path;
    path = this.getFormPath();
    CUI.DOM.setAttribute(this.DOM, "cui-form-depth", path.length);
    this.callOnOthers("setFormDepth");
    return this;
  };

  DataField.prototype.getFormPath = function(include_self, path, call) {
    var ref;
    if (include_self == null) {
      include_self = false;
    }
    if (path == null) {
      path = [];
    }
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "CUI.DataField.getPath", "Recursion detected.");
    if ((ref = this.getForm()) != null ? ref.getFormPath : void 0) {
      this.getForm().getFormPath(true, path, call + 1);
    }
    if (include_self) {
      path.push(this);
    }
    return path;
  };

  DataField.prototype.getForm = function() {
    return this.__form;
  };

  DataField.prototype.getOtherField = function(name) {
    var ref, ref1;
    return (ref = this.__form) != null ? (ref1 = ref.getFieldsByName(name)) != null ? ref1[0] : void 0 : void 0;
  };

  DataField.prototype.getRootForm = function() {
    if (this.__form) {
      return this.__form.getRootForm();
    } else if (this instanceof Form) {
      return this;
    } else {
      return null;
    }
  };

  DataField.prototype.__initDisabled = function() {
    if (this._disabled && (this._disabled === true || this._disabled.call(this, this))) {
      this.disable();
    }
  };

  DataField.prototype.enable = function() {
    this.removeClass("cui-data-field-disabled");
    this.callOnOthers("enable");
    return this;
  };

  DataField.prototype.disable = function() {
    this.addClass("cui-data-field-disabled");
    this.callOnOthers("disable");
    return this;
  };

  DataField.prototype.isDisabled = function() {
    return this.hasClass("cui-data-field-disabled");
  };

  DataField.prototype.isHidden = function() {
    return this.hasClass("cui-data-field-hidden");
  };

  DataField.prototype.isShown = function() {
    return !this.isHidden();
  };

  DataField.prototype.setOpacity = function(opacity) {
    if (opacity === 1) {
      if (this.__opacity !== 1) {
        this.DOM.css("opacity", "");
      }
    } else {
      this.DOM.css("opacity", opacity);
    }
    this.__opacity = opacity;
    return this;
  };

  DataField.prototype.updateData = function(data) {
    if (CUI.isFunction(this._data)) {
      this.__data = this._data.call(this, data, this);
    } else {
      this.__data = data;
    }
    return this.displayValue();
  };

  DataField.prototype.setData = function(data, init_data) {
    var ref;
    if (init_data == null) {
      init_data = true;
    }
    if (this.__data && this._data && !CUI.isFunction(this._data)) {
      return;
    }
    assert(!this.__data, this + ".setData", "data is already set.", {
      opts: this.opts,
      data: this.__data
    });
    if (CUI.isFunction(this._data)) {
      this.__data = this._data.call(this, data, this);
    } else {
      this.__data = data;
    }
    assert(CUI.isPlainObject(this.__data) || ((ref = this.__data) != null ? typeof ref.hasOwnProperty === "function" ? ref.hasOwnProperty(this.getName()) : void 0 : void 0), this + ".setData", "data needs to be PlainObject or have a property \"" + (this.getName()) + "\".", {
      data: data,
      opts: this.opts
    });
    if (this.setDataOnOthers()) {
      this.callOnOthers("setData", this.__data, init_data);
    }
    if (init_data) {
      this.initData();
    }
    return this;
  };

  DataField.prototype.setDataOnOthers = function() {
    return !this._data_not_for_others;
  };

  DataField.prototype.hide = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.addClass("cui-data-field-hidden");
    this.callOnOthers("hide");
    if (trigger_event) {
      Events.trigger({
        type: "form-check-row-visibility",
        node: this.DOM,
        info: {
          element: this
        }
      });
    }
    return this;
  };

  DataField.prototype.show = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.removeClass("cui-data-field-hidden");
    this.callOnOthers("show");
    if (trigger_event) {
      Events.trigger({
        type: "form-check-row-visibility",
        node: this.DOM,
        info: {
          element: this
        }
      });
    }
    return this;
  };

  DataField.prototype.isRendered = function() {
    return this.__isRendered;
  };

  DataField.prototype.render = function() {
    assert(!this.__isRendered, this.__cls + ".render", "Cannot be called when already rendered.", {
      opts: this.opts,
      dataField: this
    });
    this.__isRendered = true;
    if (this.isDisabled()) {
      this.disable();
    }
    if (this.isHidden()) {
      this.hide();
    }
    this.setOpacity();
    this.callOnOthers("render");
    if (typeof this._onRender === "function") {
      this._onRender(this);
    }
    return this;
  };

  DataField.prototype.displayValue = function() {
    assert(!this.isDestroyed(), this.__cls + ".displayValue", "DataField already destroyed, cannot display value.", {
      data_field: this
    });
    assert(this.__isRendered, this.__cls + ".displayValue", "not rendered yet, cannot display.", {
      opts: this.opts,
      data: this.__data
    });
    this.checkChanged();
    return this.callOnOthers("displayValue");
  };

  DataField.prototype.start = function() {
    assert(!this.__isRendered, this.__cls + ".start", "Cannot be called when already rendered.", {
      opts: this.opts,
      dataField: this
    });
    this.__initDisabled();
    this.render();
    this.displayValue();
    return this;
  };

  DataField.prototype.getAllDataFields = function(all) {
    if (all == null) {
      all = false;
    }
    return this.getDataFields(true);
  };

  DataField.prototype.getDataFields = function(all, data_fields) {
    if (all == null) {
      all = false;
    }
    if (data_fields == null) {
      data_fields = [];
    }
    if (this.isDataField() || all) {
      data_fields.push(this);
    }
    this.callOnOthers("getDataFields", all, data_fields);
    return data_fields;
  };

  DataField.prototype.isDataField = function() {
    return this.hasData();
  };

  DataField.prototype.callOnOthers = function() {
    var args, df, func, i, len, other_fields;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (this.getFields) {
      other_fields = this.getFields(func).slice(0);
    } else {
      other_fields = [];
    }
    for (i = 0, len = other_fields.length; i < len; i++) {
      df = other_fields[i];
      if (!df || !CUI.isFunction(df[func])) {
        assert(false, "CUI.DataField.callOnOthers", "Field found in other fields has no Function \"" + func + "\".", {
          field: df,
          other_fields: other_fields
        });
        return this;
      }
      df[func].apply(df, args);
    }
    return this;
  };

  DataField.prototype.getData = function() {
    return this.__data;
  };

  DataField.prototype.hasData = function() {
    return !isEmpty(this._name) && this.__data;
  };

  DataField.prototype.getArrayFromOpt = function(opt, event, allowDeferred) {
    var arr, v;
    if (allowDeferred == null) {
      allowDeferred = false;
    }
    v = this["_" + opt];
    if (CUI.isFunction(v)) {
      arr = v.call(this, this, event);
      assert(CUI.isArray(arr) || (isPromise(arr) && allowDeferred), this.__cls + ".getArrayFromOpt", "opts." + opt + "(dataField) did not return Array or Promise.", {
        options: arr,
        opts: this.opts
      });
    } else {
      arr = v;
    }
    return arr;
  };

  DataField.prototype.getPromiseFromOpt = function(opt, event) {
    var ret;
    ret = this.getArrayFromOpt(opt, event, true);
    if (isPromise(ret)) {
      return ret;
    } else {
      return CUI.resolvedPromise(ret);
    }
  };

  DataField.prototype.getName = function() {
    return this._name;
  };

  DataField.prototype.getDefaultValue = function() {};

  DataField.prototype.getValue = function() {
    return this.__data[this._name];
  };

  DataField.prototype.checkValue = function() {
    throw new Error(this.__cls + ".checkValue is unimplemtented.");
    return this;
  };

  DataField.prototype.setValue = function(v, flags) {
    var e, ref;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      if (this.isRendered()) {
        this.displayValue();
      }
      return this;
    }
    if (v === this.getValue()) {
      return this;
    }
    try {
      this.checkValue(v, flags);
    } catch (_error) {
      e = _error;
      if (!(e instanceof CheckValueError)) {
        throw e;
      }
      throw new Error((this.__cls + ".setValue: ") + v + ", Error: " + e);
    }
    if ((ref = flags.no_trigger) !== false && ref !== true) {
      flags.no_trigger = true;
    }
    this.storeValue(v, flags);
    if (this.isRendered()) {
      this.displayValue();
    }
    return this;
  };

  DataField.prototype.getInitValue = function() {
    var undo;
    undo = this.getUndo();
    if (!undo) {
      return void 0;
    }
    return undo.values[0];
  };

  DataField.prototype.getLastValue = function() {
    var undo;
    undo = this.getUndo();
    if (!undo) {
      return void 0;
    }
    return undo.values[undo.idx - 1];
  };

  DataField.prototype.reset = function() {
    var undo;
    if (undo = this.getUndo()) {
      this.__data[this._name] = undo.values[0];
      undo.values.splice(1);
      undo.idx = 0;
      this.displayValue();
      this.triggerDataChanged({
        action: "reset",
        undo_idx: 0
      });
    }
    return this;
  };

  DataField.prototype.undo = function() {
    var undo;
    if (undo = this.getUndo()) {
      if (undo.idx === 0) {
        return false;
      }
      this.__data[this._name] = undo.values[--undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "undo",
        undo_idx: undo.idx
      });
      return true;
    }
    return null;
    return this;
  };

  DataField.prototype.redo = function() {
    var undo;
    if (undo = this.getUndo()) {
      if (undo.idx === undo.values.length - 1) {
        return false;
      }
      this.__data[this._name] = undo.values[++undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "redo",
        undo_idx: undo.idx
      });
      return true;
    }
    return null;
    return this;
  };

  DataField.prototype.goto = function(idx) {
    var undo;
    if (undo = this.getUndo()) {
      if (isUndef(undo.values[idx])) {
        return false;
      }
      undo.idx = idx;
      this.__data[this._name] = undo.values[undo.idx];
      this.displayValue();
      this.triggerDataChanged({
        action: "goto",
        undo_idx: idx
      });
      return true;
    }
    return null;
  };

  DataField.prototype.initData = function() {
    var undo;
    if (typeof this._onDataInit === "function") {
      this._onDataInit(this, this.__data);
    }
    if (!this.hasData()) {
      return;
    }
    this.initValue();
    undo = this.getUndo();
    if (CUI.isPlainObject(undo) && CUI.isEmptyObject(undo)) {
      undo.values = [this.getValue()];
      undo.idx = 0;
    }
    if (isUndef(this.getCheckChangedValue())) {
      this.setCheckChangedValue(undo ? this.getInitValue() : this.getValue());
    }
    if (this.setDataOnOthers()) {
      this.callOnOthers("initData");
    }
    return this;
  };

  DataField.prototype.initValue = function() {
    if (isUndef(this.__data[this._name])) {
      this.__data[this._name] = this.getDefaultValue();
    }
    return this;
  };

  DataField.prototype.setCheckChangedValue = function(value) {
    assert(this.hasData(), this.__cls + ".setCheckChangedValue", "Cannot set without data.", {
      opts: this.opts,
      value: value,
      dataField: this
    });
    if (this._check_changed === false) {
      return void 0;
    }
    return this.__checkChangedValue = JSON.stringify(value);
  };

  DataField.prototype.getCheckChangedValue = function() {
    if (this._check_changed === false) {
      return void 0;
    }
    assert(this.hasData(), this.__cls + ".getCheckChangedValue", "No data set.", {
      opts: this.opts
    });
    return this.__checkChangedValue;
  };

  DataField.prototype.getUndo = function() {
    var undo;
    if (!this.hasData() || this._undo_support === false) {
      return false;
    }
    if (isUndef(this.__data._undo)) {
      this.__data._undo = {};
    }
    if (isUndef(undo = this.__data._undo[this._name])) {
      undo = this.__data._undo[this._name] = {};
    }
    return undo;
  };

  DataField.prototype.storeValue = function(value, flags) {
    var store_last, undo;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      return false;
    }
    store_last = (!flags.prior_activate && flags.initial_activate !== true && flags.no_store !== true) || flags.force_store;
    if (store_last && (undo = this.getUndo())) {
      undo.values[++undo.idx] = value;
      undo.values.splice(undo.idx + 1);
    }
    this.__data[this._name] = value;
    this.checkChanged();
    if (store_last && !flags.no_trigger) {
      this.triggerDataChanged({
        action: "store",
        undo_idx: undo != null ? undo.idx : void 0
      });
    }
    return this;
  };

  DataField.prototype.triggerDataChanged = function(info) {
    if (info == null) {
      info = {};
    }
    info.element = this;
    return Events.trigger({
      type: "data-changed",
      node: this.DOM,
      info: info
    });
  };

  DataField.prototype.isChanged = function() {
    if (!this.hasData() || this._check_changed === false) {
      return void 0;
    }
    return this.getCheckChangedValue() !== JSON.stringify(this.getValue());
  };

  DataField.prototype.checkChanged = function() {
    if (this._check_changed === false) {
      return;
    }
    if (this.isChanged()) {
      this.addClass("changed");
    } else {
      this.removeClass("changed");
    }
    return this;
  };

  DataField.prototype.getChangedMarker = function() {
    if (this._mark_changed === false || this._check_changed === false) {
      return;
    }
    this.checkChanged();
    return $div(CUI.DataField.changed_marker_css_class);
  };

  DataField.prototype.destroy = function() {
    var ref;
    this.remove(true);
    if ((ref = this.__tooltip) != null) {
      ref.destroy();
    }
    return DataField.__super__.destroy.call(this);
  };

  DataField["new"] = function(field, delete_keys, default_data) {
    var _field, field_opts, k, type, v;
    if (delete_keys == null) {
      delete_keys = [];
    }
    if (default_data == null) {
      default_data = {};
    }
    if (field instanceof DataField) {
      return field;
    }
    assert(CUI.isPlainObject(field), "CUI.DataField.new", "field needs to be PlainObject.", {
      field: field,
      delete_keys: delete_keys,
      default_data: default_data
    });
    field_opts = {};
    for (k in field) {
      v = field[k];
      if (k === "type") {
        type = v;
        continue;
      }
      if (delete_keys.indexOf(k) > -1) {
        continue;
      }
      field_opts[k] = v;
    }
    for (k in default_data) {
      v = default_data[k];
      if (field_opts.hasOwnProperty(k)) {
        continue;
      }
      field_opts[k] = v;
    }
    assert(CUI.isFunction(type), "CUI.DataField.new", "type is unknown: \"" + type + "\".", {
      field: field
    });
    _field = new type(field_opts);
    assert(_field instanceof CUI.DataField, "CUI.DataField.new", "field.type needs to be of class DataField, but is " + (getObjectClass(_field)) + ".", {
      field: field
    });
    return _field;
  };

  return DataField;

})(CUI.DOM);

DataField = CUI.DataField;

CUI.Events.registerEvent({
  type: "data-changed",
  bubble: true
});
// Generated by CoffeeScript 1.9.3
var CheckValueError,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CheckValueError = (function(superClass) {
  extend(CheckValueError, superClass);

  function CheckValueError() {
    return CheckValueError.__super__.constructor.apply(this, arguments);
  }

  return CheckValueError;

})(Error);
// Generated by CoffeeScript 1.9.3
var DataFieldInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DataFieldInput = (function(superClass) {
  extend(DataFieldInput, superClass);

  function DataFieldInput(opts) {
    this.opts = opts != null ? opts : {};
    DataFieldInput.__super__.constructor.call(this, this.opts);
    DOM.setAttributeMap(this.DOM[0], this._attr);
    this.addClass("cui-data-field-input");
  }

  DataFieldInput.prototype.initOpts = function() {
    DataFieldInput.__super__.initOpts.call(this);
    return this.addOpts({
      group: {
        check: String
      },
      attr: {
        "default": {},
        check: "PlainObject"
      }
    });
  };

  DataFieldInput.prototype.getGroup = function() {
    return this._group;
  };

  DataFieldInput.prototype.isResizable = function() {
    return true;
  };

  return DataFieldInput;

})(CUI.DataField);

DataFieldInput = CUI.DataFieldInput;
// Generated by CoffeeScript 1.9.3
var Button,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Button = (function(superClass) {
  extend(Button, superClass);

  Button.defaults = {
    confirm_ok: "Ok",
    confirm_icon: "question",
    confirm_cancel: "Cancel",
    confirm_title: "Confirmation",
    pressed_css_class: "cui-pressed",
    disabled_css_class: "cui-disabled",
    active_css_class: "cui-active",
    menu_open_css_class: "cui-menu-open"
  };

  function Button(opts) {
    var icon_left, icon_right, itemList_opts, k, menu_start_hide, menu_stop_hide, ref, ref1, ref2, ref3, ref4, text, tname, v;
    this.opts = opts != null ? opts : {};
    Button.__super__.constructor.call(this, this.opts);
    tname = this.getTemplateName();
    this.__box = new Template({
      name: tname,
      map: {
        left: this.__has_left ? ".cui-button-left" : void 0,
        center: ".cui-button-center",
        right: this.__has_right ? ".cui-button-right" : void 0
      }
    });
    this.registerTemplate(this.__box);
    this.__active = null;
    this.__disabled = false;
    this.__hidden = false;
    this.__txt = null;
    if (this._role === "minor") {
      this._size = "mini";
    } else if (this._role === "menu-item") {
      this.addClass("cui-menu-item");
    }
    if (CUI.__ng__) {
      this.addClass("cui-button-button");
    }
    DOM.setAttributeMap(this.DOM, this._attr);
    DOM.setAttribute(this.DOM, "tabindex", this._tabindex);
    if (!((ref = this._attr) != null ? ref.role : void 0)) {
      DOM.setAttribute(this.DOM, "role", this._role);
    }
    if (!this._left || this._left === true) {
      if (this._icon) {
        assert(isUndef(this._icon_left), "new " + this.__cls, "opts.icon conflicts with opts.icon_left", {
          opts: this.opts
        });
        icon_left = this._icon;
      } else {
        icon_left = this._icon_left;
      }
      if (icon_left) {
        assert(!this._icon_active && !this._icon_inactive, "new Button", "opts.icon_active or opts.icon_inactive cannot be set together with opts.icon or opts.icon_left", {
          opts: this.opts
        });
        this.setIcon(icon_left);
      }
    } else {
      this.append(this._left, "left");
    }
    if (!this._right) {
      if (this._icon_right) {
        icon_right = this.__getIcon(this._icon_right);
      } else if (this._menu && this._icon_right !== false) {
        if (this._menu_parent) {
          icon_right = new Icon({
            "class": "fa-angle-right"
          });
        } else {
          icon_right = new Icon({
            "class": "fa-angle-down"
          });
        }
        this.addClass("cui-button--has-caret");
      }
      if (icon_right) {
        this.append(icon_right, "right");
      }
    } else if (this._right !== true) {
      this.append(this._right, "right");
    }
    if (!icon_right && !icon_left && isUndef(this._text) && !this._icon_active && !this._icon_inactive) {
      text = this.__cls;
    } else {
      text = this._text;
    }
    assert(this._size);
    if (this._size === "auto") {
      this.addClass("cui-button-size-normal");
    }
    this.addClass("cui-button-size-" + this._size);
    assert(this._appearance);
    if (this._appearance === "auto") {
      this.addClass("cui-button-appearance-normal");
    }
    this.addClass("cui-button-appearance-" + this._appearance);
    if (this._primary) {
      this.addClass("cui-button--primary");
    }
    if (this._center) {
      this.append(this._center, "center");
    } else {
      this.setText(text);
    }
    if (this._disabled && (this._disabled === true || this._disabled.call(this, this))) {
      this.disable();
    }
    if (this._hidden && (this._hidden === true || this._hidden.call(this, this))) {
      this.hide();
    }
    if (this._active === true) {
      this.activate({
        initial_activate: true
      });
    } else if (this._active === false || this._switch) {
      this.deactivate({
        initial_activate: true
      });
    } else {
      this.__setState();
    }
    this.__radio_allow_null = this._radio_allow_null;
    if (this._radio) {
      assert(isUndef(this._switch), "new Button", "opts.switch conflicts with opts.radio.", {
        opts: this.opts
      });
      if (this._radio === true) {
        this.__radio = "radio--" + this.getUniqueId();
      } else {
        this.__radio = this._radio;
      }
    } else if (!isNull(this._switch)) {
      this.__radio = "switch--" + this.getUniqueId();
      this.__radio_allow_null = true;
    }
    if (this.__radio) {
      assert(!((ref1 = this._attr) != null ? ref1.radio : void 0), "new Button", "opts.radio conflicts with opts.attr.radio", {
        opts: this.opts
      });
      DOM.setAttribute(this.DOM, "radio", this.__radio);
    }
    this.setGroup(this._group);
    if (this._menu) {
      this.__menu_opts = {};
      itemList_opts = {};
      ref2 = this._menu;
      for (k in ref2) {
        v = ref2[k];
        switch (k) {
          case "onShow":
          case "onHide":
            continue;
          case "class":
          case "backdrop":
          case "onPosition":
          case "placement":
          case "placements":
          case "pointer":
            this.__menu_opts[k] = v;
            break;
          default:
            itemList_opts[k] = v;
        }
      }
      if (!isEmpty(this._class)) {
        if (this.__menu_opts["class"]) {
          this.__menu_opts["class"] += " " + this._class;
        } else {
          this.__menu_opts["class"] = this._class;
        }
      }
      if (this._menu.itemList) {
        this.__menu_opts.itemList = this._menu.itemList;
      } else {
        this.__menu_opts.itemList = itemList_opts;
      }
      this.__menu_opts.element = this;
      if (!this.__menu_opts.hasOwnProperty("use_element_width_as_min_width")) {
        if (!this._menu_parent) {
          this.__menu_opts.use_element_width_as_min_width = true;
        }
      }
      this.__menu_opts.onHide = (function(_this) {
        return function() {
          var base;
          _this.removeClass(CUI.defaults["class"].Button.defaults.menu_open_css_class);
          return typeof (base = _this._menu).onHide === "function" ? base.onHide() : void 0;
        };
      })(this);
      this.__menu_opts.onShow = (function(_this) {
        return function() {
          var base;
          _this.addClass(CUI.defaults["class"].Button.defaults.menu_open_css_class);
          return typeof (base = _this._menu).onShow === "function" ? base.onShow() : void 0;
        };
      })(this);
      if (!this.__menu_opts.hasOwnProperty("backdrop")) {
        if (this._menu_on_hover) {
          this.__menu_opts.backdrop = false;
        } else {
          this.__menu_opts.backdrop = {
            policy: "click-thru"
          };
        }
      }
      if (!this.__menu_opts.backdrop.hasOwnProperty("blur") && ((ref3 = this._menu_parent) != null ? (ref4 = ref3.getOpt("backdrop")) != null ? ref4.blur : void 0 : void 0)) {
        if (this._menu_on_hover) {
          this.__menu_opts.backdrop = {
            policy: "click-thru",
            blur: true
          };
        } else {
          this.__menu_opts.backdrop.blur = true;
        }
      }
      if (this._menu_parent) {
        this.__menu_opts.parent_menu = this._menu_parent;
      }
    }
    Events.listen({
      type: "keydown",
      node: this.DOM,
      capture: true,
      call: (function(_this) {
        return function(ev) {
          var el, left, ref5, right;
          if (ev.hasModifierKey()) {
            return;
          }
          if ((ref5 = ev.keyCode()) === 13 || ref5 === 32) {
            _this.onClickAction(ev);
            ev.stop();
            return;
          }
          if (ev.keyCode() === 27) {
            _this.DOM.blur();
            ev.stop();
            return;
          }
          el = null;
          right = function() {
            return el = DOM.findNextVisibleElement(_this.DOM, "[tabindex]");
          };
          left = function() {
            return el = DOM.findPreviousVisibleElement(_this.DOM, "[tabindex]");
          };
          switch (ev.keyCode()) {
            case 39:
              right();
              break;
            case 40:
              right();
              break;
            case 37:
              left();
              break;
            case 38:
              left();
          }
          if (el) {
            el.focus();
            ev.stop();
          }
        };
      })(this)
    });
    Events.listen({
      type: "mousedown",
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          ev.preventDefault();
          if (window.globalDrag) {
            return;
          }
          if (!_this.__disabled && !CUI.__ng__) {
            CUI.DOM.addClass(_this.DOM, CUI.defaults["class"].Button.defaults.pressed_css_class);
          }
          ev.stopPropagation();
        };
      })(this)
    });
    Events.listen({
      type: ["mouseup", "click", "dblclick"],
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          if (ev.getType() !== _this._click_type) {
            ev.stopPropagation();
            return;
          }
          if (window.globalDrag) {
            ev.stop();
            return;
          }
          if (ev.getButton() !== 0) {
            ev.stop();
            return;
          }
          if (!CUI.__ng__) {
            _this.removeClass(CUI.defaults["class"].Button.defaults.pressed_css_class);
          }
          ev.stopPropagation();
          _this.onClickAction(ev);
        };
      })(this)
    });
    if (this._menu_on_hover) {
      CUI.Button.menu_timeout = null;
      CUI.Button.menu_shown = null;
      menu_stop_hide = (function(_this) {
        return function() {
          if (!CUI.Button.menu_timeout) {
            return;
          }
          CUI.clearTimeout(CUI.Button.menu_timeout);
          return CUI.Button.menu_timeout = null;
        };
      })(this);
      menu_start_hide = (function(_this) {
        return function(ev) {
          return CUI.Button.menu_timeout = CUI.setTimeout({
            ms: 700,
            call: function() {
              return _this.getMenu().hide(ev);
            }
          });
        };
      })(this);
    }
    if (this._menu_on_hover || this._tooltip) {
      Events.listen({
        type: "mouseenter",
        node: this.DOM,
        call: (function(_this) {
          return function(ev) {
            var menu;
            if (window.globalDrag) {
              return;
            }
            if (_this._tooltip) {
              _this.__initTooltip();
              _this.getTooltip().showTimeout(null, ev);
            }
            if (_this._menu_on_hover) {
              menu = _this.getMenu();
              menu_stop_hide();
              if (!_this.__disabled && menu.hasItems(ev)) {
                if (CUI.Button.menu_shown && CUI.Button.menu_shown !== menu) {
                  menu_stop_hide();
                  CUI.Button.menu_shown.hide(ev);
                }
                menu.show(ev);
                CUI.Button.menu_shown = menu;
                Events.ignore({
                  instance: _this,
                  node: menu
                });
                Events.listen({
                  type: "mouseenter",
                  node: menu,
                  instance: _this,
                  only_once: true,
                  call: function() {
                    return menu_stop_hide();
                  }
                });
                Events.listen({
                  type: "mouseleave",
                  node: menu,
                  instance: _this,
                  only_once: true,
                  call: function() {
                    return menu_start_hide(ev);
                  }
                });
              }
            }
          };
        })(this)
      });
    }
    Events.listen({
      type: "mouseleave",
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          var ref5;
          if (window.globalDrag) {
            return;
          }
          if (!CUI.__ng__) {
            _this.removeClass(CUI.defaults["class"].Button.defaults.pressed_css_class);
          }
          if ((ref5 = _this.getTooltip()) != null) {
            ref5.hideTimeout(ev);
          }
          if (_this._menu_on_hover) {
            menu_start_hide(ev);
          }
        };
      })(this)
    });
  }

  Button.prototype.onClickAction = function(ev) {
    var btns, dialog, do_click, ref, remove_click_class;
    if (this.__disabled) {
      return;
    }
    if ((ref = this.getTooltip()) != null) {
      ref.hide(ev);
    }
    if (this.__radio) {
      if (this.__radio_allow_null) {
        this.toggle({}, ev);
      } else {
        this.activate({}, ev);
      }
    }
    if (this.hasMenu() && !this._menu_on_hover && this.getMenu().hasItems(ev)) {
      this.getMenu().show(ev);
      ev.preventDefault();
      return;
    }
    if (ev.isImmediatePropagationStopped()) {
      return;
    }
    if (!CUI.__ng__) {
      this.addClass(CUI.defaults["class"].Button.defaults.pressed_css_class);
    }
    remove_click_class = (function(_this) {
      return function() {
        if (!CUI.__ng__) {
          _this.removeClass(CUI.defaults["class"].Button.defaults.pressed_css_class);
        }
      };
    })(this);
    do_click = (function(_this) {
      return function() {
        if (ev.isImmediatePropagationStopped()) {
          remove_click_class();
          return;
        }
        Events.trigger({
          type: "cui-button-click",
          node: _this,
          info: {
            event: ev
          }
        });
        if (ev.isImmediatePropagationStopped() || !_this._onClick) {
          remove_click_class();
          return;
        }
        CUI.decide(_this._onClick.call(_this, ev, _this)).always(function() {
          return remove_click_class();
        });
      };
    })(this);
    if (this._onClick && this._confirm_on_click && !ev.ctrlKey()) {
      btns = [];
      if (!isEmpty(CUI.defaults["class"].Button.defaults.confirm_cancel)) {
        btns.push({
          text: CUI.defaults["class"].Button.defaults.confirm_cancel,
          onClick: (function(_this) {
            return function() {
              dialog.destroy();
              return remove_click_class();
            };
          })(this)
        });
      }
      btns.push({
        text: CUI.defaults["class"].Button.defaults.confirm_ok,
        onClick: (function(_this) {
          return function() {
            dialog.destroy();
            return do_click();
          };
        })(this)
      });
      dialog = new CUI.ConfirmationDialog({
        text: this._confirm_on_click,
        icon: CUI.defaults["class"].Button.defaults.confirm_icon,
        title: CUI.defaults["class"].Button.defaults.confirm_title,
        header_right: {
          icon: "close",
          onClick: function() {
            return dialog.destroy();
          }
        },
        buttons: btns
      });
      dialog.show();
    } else {
      do_click();
    }
    return this;
  };

  Button.prototype.initOpts = function() {
    Button.__super__.initOpts.call(this);
    return this.addOpts({
      tabindex: {
        "default": 0,
        check: function(v) {
          return isInteger(v) || v === false;
        }
      },
      role: {
        "default": "button",
        check: String
      },
      size: {
        mandatory: true,
        "default": "auto",
        check: ["auto", "mini", "normal", "big", "bigger"]
      },
      appearance: {
        mandatory: true,
        "default": "auto",
        check: ["auto", "link", "flat", "normal", "important"]
      },
      primary: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      onClick: {
        check: Function
      },
      confirm_on_click: {
        check: String
      },
      click_type: {
        "default": "click",
        mandatory: true,
        check: ["click", "mouseup", "dblclick"]
      },
      text: {
        check: String
      },
      tooltip: {
        check: "PlainObject"
      },
      disabled: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      active_css_class: {
        check: String
      },
      left: {
        check: function(v) {
          if (v === true) {
            return true;
          }
          return (isElement(v) || v instanceof CUI.Element || isString(v)) && !this._icon && !this._icon_left && !this._icon_active && !this._icon_inactive;
        }
      },
      right: {
        check: function(v) {
          return (v === true || isContent(v)) && !this._icon_right;
        }
      },
      center: {
        check: function(v) {
          return isElement(v) || isString(v) || v instanceof CUI.Element;
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_left: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_right: {
        check: function(v) {
          return v instanceof Icon || isString(v) || v === false;
        }
      },
      icon_active: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      icon_inactive: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      text_active: {
        check: String
      },
      text_inactive: {
        check: String
      },
      value: {},
      attr: {
        "default": {},
        check: "PlainObject"
      },
      name: {
        check: String
      },
      hidden: {
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      },
      menu: {
        check: "PlainObject"
      },
      menu_on_hover: {
        check: Boolean
      },
      menu_parent: {
        check: Menu
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      radio: {
        check: function(v) {
          return isString(v) || v === true;
        }
      },
      radio_allow_null: {
        check: Boolean
      },
      "switch": {
        check: Boolean
      },
      active: {
        check: Boolean
      },
      activate_initial: {
        "default": true,
        check: Boolean
      },
      group: {
        check: String
      }
    });
  };

  Button.prototype.__getIcon = function(icon) {
    if (!icon) {
      return null;
    } else if (icon instanceof Icon) {
      return icon;
    } else {
      return new Icon({
        icon: icon
      });
    }
  };

  Button.prototype.readOpts = function() {
    if (this.opts["switch"]) {
      assert(isUndef(this.opts.radio_allow_null), "new Button", "opts.switch cannot be used together with opts.radio_allow_null", {
        opts: this.opts
      });
    }
    Button.__super__.readOpts.call(this);
    if (this._left) {
      assert(this._left === true || !(this._icon_active || this._icon_inactive || this._icon), "new Button", "opts.left != true cannot be used togeter with opts.icon*", {
        opts: this.opts
      });
    }
    if (!isNull(this._active_css_class)) {
      return this.__active_css_class = this._active_css_class;
    } else {
      return this.__active_css_class = CUI.defaults["class"].Button.defaults.active_css_class;
    }
  };

  Button.prototype.getCenter = function() {
    return this.__box.map.center;
  };

  Button.prototype.__getTemplateName = function() {
    if (this._icon || this._icon_left || this._icon_active || this._icon_inactive || this._left) {
      this.__has_left = true;
    } else {
      this.__has_left = false;
    }
    if (this._icon_right || (this._menu && this._icon_right !== false) || this._right) {
      this.__has_right = true;
    } else {
      this.__has_right = false;
    }
    if (this.__has_left && this.__has_right) {
      return "button";
    } else if (this.__has_left) {
      return "button-left-center";
    } else if (this.__has_right) {
      return "button-center-right";
    } else {
      return "button-center";
    }
  };

  Button.prototype.getTemplateName = function() {
    if (CUI.__ng__) {
      return this.__getTemplateName() + "-ng";
    } else {
      return this.__getTemplateName();
    }
  };

  Button.prototype.getValue = function() {
    return this._value;
  };

  Button.prototype.getRadioButtons = function() {
    if (!this.__radio) {
      return [];
    }
    return this.__getButtons("radio", this.__radio);
  };

  Button.prototype.getGroupButtons = function() {
    if (!this.getGroup()) {
      return [];
    }
    return this.__getButtons("button-group", this.getGroup());
  };

  Button.prototype.__getButtons = function(key, value) {
    var all_parents, c, docElem, i, len, parents, ref, results;
    parents = this.DOM.parents(".cui-buttonbar,.cui-form-table,.cui-tmpl-item-list-body,.cui-layer");
    if (parents.length === 0) {
      all_parents = this.DOM.parents();
      docElem = all_parents[all_parents.length - 1];
    } else {
      docElem = parents[parents.length - 1];
    }
    ref = DOM.matchSelector(docElem, ".cui-button[" + key + "=\"" + value + "\"]");
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      results.push(DOM.data(c, "element"));
    }
    return results;
  };

  Button.prototype.hasMenu = function() {
    return !!this.__menu_opts;
  };

  Button.prototype.hasLeft = function() {
    return this.__has_left;
  };

  Button.prototype.getMenu = function() {
    if (!this.hasMenu()) {
      return;
    }
    if (this.__menu) {
      return this.__menu;
    } else {
      return this.__menu = new Menu(this.__menu_opts);
    }
  };

  Button.prototype.menuSetActiveIdx = function(idx) {
    if (this.__menu) {
      this.__menu.setActiveIdx(idx);
    } else {
      this.__menu_opts.itemList.active_item_idx = idx;
    }
    return this;
  };

  Button.prototype.getMenuRootButton = function() {
    var ref;
    if (this._menu_parent) {
      return (ref = this._menu_parent.getButton()) != null ? ref.getMenuRootButton() : void 0;
    } else if (this.hasMenu()) {
      return this;
    } else {
      return null;
    }
  };

  Button.prototype.toggle = function(flags, event) {
    if (flags == null) {
      flags = {};
    }
    return this.setActive(!this.__active, flags, event);
  };

  Button.prototype.setActive = function(active, flags, event) {
    if (flags == null) {
      flags = {};
    }
    if (active) {
      return this.activate(flags, event);
    } else {
      return this.deactivate(flags, event);
    }
  };

  Button.prototype.activate = function(flags, event) {
    var activate, btn, i, idx, len, ref, ret;
    if (flags == null) {
      flags = {};
    }
    activate = (function(_this) {
      return function() {
        var btn, group, i, len, ref;
        _this.addClass(_this.__active_css_class);
        _this.__setState();
        group = _this.getGroup();
        if (!group || !(event != null ? event.ctrlKey() : void 0) || flags.ignore_ctrl) {
          return;
        }
        flags.ignore_ctrl = true;
        ref = _this.getGroupButtons();
        for (i = 0, len = ref.length; i < len; i++) {
          btn = ref[i];
          if (btn === _this) {
            continue;
          }
          btn.activate(flags, event);
        }
      };
    })(this);
    if (this._activate_initial === false && flags.initial_activate) {
      this.__active = true;
      activate();
      return this;
    }
    if (this.__active === true && CUI.isEmptyObject(flags)) {
      return this;
    }
    if (this.__radio) {
      ref = this.getRadioButtons();
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        btn = ref[idx];
        if (btn === this) {
          continue;
        }
        btn.deactivate({
          prior_activate: true,
          initial_activate: flags.initial_activate
        });
      }
    }
    this.__active = true;
    ret = typeof this._onActivate === "function" ? this._onActivate(this, flags, event) : void 0;
    if (isPromise(ret)) {
      ret.done(activate).fail((function(_this) {
        return function() {
          return _this.__active = false;
        };
      })(this));
      return ret;
    }
    activate();
    return this;
  };

  Button.prototype.deactivate = function(flags, event) {
    var deactivate, ret;
    if (flags == null) {
      flags = {};
    }
    deactivate = (function(_this) {
      return function() {
        var btn, group, i, len, ref, results;
        _this.removeClass(_this.__active_css_class);
        _this.__setState();
        group = _this.getGroup();
        if (!group || !(event != null ? event.ctrlKey() : void 0) || flags.ignore_ctrl) {
          return;
        }
        flags.ignore_ctrl = true;
        ref = _this.getGroupButtons();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          btn = ref[i];
          if (btn === _this) {
            continue;
          }
          results.push(btn.deactivate(flags, event));
        }
        return results;
      };
    })(this);
    if (this._activate_initial === false && flags.initial_activate) {
      this.__active = false;
      deactivate();
      return this;
    }
    if (this.__active === false && CUI.isEmptyObject(flags)) {
      return this;
    }
    this.__active = false;
    ret = typeof this._onDeactivate === "function" ? this._onDeactivate(this, flags, event) : void 0;
    if (isPromise(ret)) {
      ret.done(deactivate).fail((function(_this) {
        return function() {
          return _this.__active = true;
        };
      })(this));
      return ret;
    }
    deactivate();
    return this;
  };

  Button.prototype.setIcon = function(icon) {
    if (icon == null) {
      icon = null;
    }
    this.__icon = this.__getIcon(icon);
    assert(this.__icon === null || this.__icon instanceof Icon, "CUI.Button.setIcon", "icon needs to be instance of Icon", {
      icon: icon
    });
    if (this.__icon === null) {
      this.empty("left");
    } else {
      this.replace(this.__icon, "left");
    }
    return this;
  };

  Button.prototype.startSpinner = function() {
    assert(this.__has_left, "CUI.Button.startSpinner", "No space for Icon found, make sure the Button was created with opts.left set.", {
      opts: this.opts
    });
    if (this.__hasSpinner) {
      return;
    }
    this.__iconBeforeSpinner = this.getIcon();
    this.__hasSpinner = true;
    this.setIcon("spinner");
    return this;
  };

  Button.prototype.stopSpinner = function() {
    this.setIcon(this.__iconBeforeSpinner);
    this.__hasSpinner = false;
    this.__iconBeforeSpinner = null;
    return this;
  };

  Button.prototype.getIcon = function() {
    return this.__icon;
  };

  Button.prototype.__setState = function() {
    this.__setIconState();
    return this.__setTextState();
  };

  Button.prototype.__setIconState = function() {
    if (!(this._icon_active || this._icon_inactive)) {
      return this;
    }
    if (this.isActive()) {
      if (!this._icon_active) {
        this.replace(DOM.element("SPAN"), "left");
        this.__icon = null;
      } else {
        this.setIcon(this._icon_active, "left");
      }
    } else {
      if (!this._icon_inactive) {
        this.replace(DOM.element("SPAN"), "left");
        this.__icon = null;
      } else {
        this.setIcon(this._icon_inactive, "left");
      }
    }
    return this;
  };

  Button.prototype.__setTextState = function() {
    if (!(this._text_active || this._text_inactive)) {
      return this;
    }
    if (this.isActive()) {
      if (!isNull(this._text_active)) {
        this.setText(this._text_active);
      }
    } else {
      if (!isNull(this._text_inactive)) {
        this.setText(this._text_inactive);
      }
    }
    return this;
  };

  Button.prototype.isActive = function() {
    return !!this.__active;
  };

  Button.prototype.isDisabled = function() {
    return this.__disabled;
  };

  Button.prototype.isEnabled = function() {
    return !this.__disabled;
  };

  Button.prototype.setEnabled = function(enabled) {
    if (enabled) {
      return this.enable();
    } else {
      return this.disable();
    }
  };

  Button.prototype.disable = function() {
    this.DOM.addClass(CUI.defaults["class"].Button.defaults.disabled_css_class);
    DOM.removeAttribute(this.DOM, "tabindex");
    this.__disabled = true;
    return this;
  };

  Button.prototype.enable = function() {
    this.DOM.removeClass(CUI.defaults["class"].Button.defaults.disabled_css_class);
    DOM.setAttribute(this.DOM, "tabindex", this._tabindex);
    this.__disabled = false;
    return this;
  };

  Button.prototype.setText = function(__txt) {
    this.__txt = __txt;
    if (isEmpty(this.__txt)) {
      return this.empty("center");
    } else {
      return this.replace($text(this.__txt), "center");
    }
  };

  Button.prototype.setTextMaxChars = function(max_chars) {
    return CUI.DOM.setAttribute(this.getCenter().firstChild, "max-chars", max_chars);
  };

  Button.prototype.getText = function() {
    return this.__txt;
  };

  Button.prototype.getGroup = function() {
    return this.__group;
  };

  Button.prototype.setGroup = function(__group) {
    this.__group = __group;
    if (this.__group) {
      return DOM.setAttribute(this.DOM, "button-group", this.__group);
    } else {
      return DOM.removeAttribute(this.DOM, "button-group");
    }
  };

  Button.prototype.__initTooltip = function() {
    var i, k, len, ref, tt_opts;
    if (this.__tooltip) {
      return this;
    }
    tt_opts = copyObject(this._tooltip);
    if (tt_opts.element == null) {
      tt_opts.element = this.DOM;
    }
    ref = ["on_hover", "on_click"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      assert(!tt_opts.hasOwnProperty(k), "CUI.Button.__initTooltip", "opts.tooltip cannot contain " + k + ".", {
        opts: this.opts
      });
      tt_opts[k] = false;
    }
    this.__tooltip = new Tooltip(tt_opts);
    return this;
  };

  Button.prototype.getTooltip = function() {
    return this.__tooltip;
  };

  Button.prototype.isShown = function() {
    return !this.isHidden();
  };

  Button.prototype.isHidden = function() {
    return this.__hidden;
  };

  Button.prototype.destroy = function() {
    var ref, ref1;
    if ((ref = this.__menu) != null) {
      ref.destroy();
    }
    if ((ref1 = this.__tooltip) != null) {
      ref1.destroy();
    }
    return Button.__super__.destroy.call(this);
  };

  Button.prototype.show = function() {
    this.__hidden = false;
    DOM.removeClass(this.DOM, "cui-button-hidden");
    DOM.showElement(this.DOM);
    return Events.trigger({
      type: "show",
      node: this.DOM
    });
  };

  Button.prototype.hide = function() {
    this.__hidden = true;
    DOM.addClass(this.DOM, "cui-button-hidden");
    DOM.hideElement(this.DOM);
    return Events.trigger({
      type: "hide",
      node: this.DOM
    });
  };

  return Button;

})(CUI.DOM);

CUI.defaults["class"].Button = CUI.Button;

CUI.Events.registerEvent({
  type: ["show", "hide", "cui-button-click"],
  bubble: true
});

Button = CUI.Button;
// Generated by CoffeeScript 1.9.3
var Icon,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Icon = (function(superClass) {
  extend(Icon, superClass);

  function Icon(opts) {
    this.opts = opts != null ? opts : {};
    Icon.__super__.constructor.call(this, this.opts);
    if (this._icon) {
      this.__class = this.icon_map()[this._icon];
      if (isEmpty(this.__class)) {
        this.__class = this._icon;
      }
      if (!isEmpty(this._class)) {
        this.__class += " " + this._class;
      }
    } else if (!isEmpty(this._class)) {
      this.__class = this._class;
    } else {
      this.__class = "";
    }
    if (this._fixed_width || isEmpty(this.__class)) {
      this.__class = this.__class + " cui-icon-fixed-width";
    }
    this.DOM = $i("fa " + this.__class);
    if (this._tooltip) {
      this._tooltip.element = this.DOM;
      new Tooltip(this._tooltip);
    }
  }

  Icon.prototype.initOpts = function() {
    Icon.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        check: String
      },
      icon: {
        check: String
      },
      fixed_width: {
        check: Boolean
      },
      tooltip: {
        check: "PlainObject"
      }
    });
  };

  Icon.prototype.copy = function() {
    return new Icon(this.opts);
  };

  Icon.prototype.hide = function() {
    return CUI.DOM.hideElement(this.DOM);
  };

  Icon.prototype.show = function() {
    return CUI.DOM.showElement(this.DOM);
  };

  Icon.prototype.icon_map = function() {
    return {
      crop: "fa-crop",
      fullscreen: "fa-arrows-alt",
      trash: "fa-trash-o",
      failed: "fa-warning",
      no_right: "fa-slack",
      file: "fa-file-o",
      refresh: "fa-refresh",
      zip: "fa fa-file-archive-o",
      rotate_right: "fa-rotate-right",
      rotate_left: "fa-rotate-left",
      rotate_vertical: "fa-arrows-v",
      rotate_horizontal: "fa-arrows-h",
      calendar: "fa-calendar",
      show: "fa-question",
      help: "fa-question",
      question: "fa-question",
      settings: CUI.__ng__ ? "fa-cog" : "fa-cogs",
      download: "fa-download",
      "export": "fa-download",
      spinner: "fa-spinner cui-spin-stepped",
      list: "fa-question",
      upload: "fa-upload",
      envelope: "fa-envelope-o",
      envelope_active: "fa-envelope",
      save: "fa-floppy-o",
      heart: "fa-heart",
      remove: "fa-times-thin",
      user: "fa-user",
      clock: "fa-clock-o",
      plus: "fa-plus",
      edit: "fa-pencil",
      copy: "fa-files-o",
      search: "fa-search",
      share: "fa-share",
      play: "fa-play",
      audio: "fa-music",
      start: "fa-play",
      stop: "fa-stop",
      print: "fa-print",
      minus: "fa-minus",
      tree_open: "fa-caret-right",
      tree_close: "fa-caret-down",
      ellipsis_h: "fa-ellipsis-h",
      ellipsis_v: "fa-ellipsis-v",
      close: "fa-times-thin",
      menu: "fa-bars",
      info: "fa-info-circle",
      bolt: "fa-bolt",
      check: "fa-check",
      warning: "fa-warning",
      legal: "fa-legal",
      cloud: "fa-cloud",
      left: CUI.__ng__ ? "fa-angle-left" : "fa-chevron-left",
      right: CUI.__ng__ ? "fa-angle-right" : "fa-chevron-right",
      dive: CUI.__ng__ ? "fa-angle-right" : "fa-chevron-right",
      zoom_in: "fa-search-plus",
      zoom_out: "fa-search-minus",
      resize_small: "fa-compress",
      resize_full: "fa-expand",
      email: "fa-envelope-o",
      file_text_active: "fa-file-text",
      file_text: "fa-file-text-o",
      required: "fa-bullhorn",
      west: "fa-angle-left",
      east: "fa-angle-right",
      south: "fa-angle-down",
      north: "fa-angle-up",
      up: "fa-caret-up",
      down: "fa-caret-down",
      camera: "fa-camera",
      expert_search: "fa-list-ul",
      image: "fa-picture-o"
    };
  };

  return Icon;

})(CUI.Element);

CUI.proxyMethods(Icon, Button, ["hide", "show", "isShown", "isHidden"]);
// Generated by CoffeeScript 1.9.3
var ButtonHref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ButtonHref = (function(superClass) {
  extend(ButtonHref, superClass);

  function ButtonHref(opts) {
    var attr;
    this.opts = opts != null ? opts : {};
    ButtonHref.__super__.constructor.call(this, this.opts);
    attr = {
      href: this._href,
      tabindex: "0",
      target: this._target
    };
    if (this._download) {
      attr.download = "download";
    }
    this.DOM.attr(attr);
  }

  ButtonHref.prototype.initOpts = function() {
    ButtonHref.__super__.initOpts.call(this);
    return this.addOpts({
      href: {
        check: String
      },
      download: {
        check: Boolean
      },
      target: {
        check: String
      }
    });
  };

  ButtonHref.prototype.setHref = function(href) {
    return this.DOM.attr("href", href);
  };

  ButtonHref.prototype.getTemplateName = function() {
    ButtonHref.__super__.getTemplateName.call(this);
    if (CUI.__ng__) {
      return "buttonHref-ng";
    } else {
      return "buttonHref";
    }
  };

  return ButtonHref;

})(Button);
// Generated by CoffeeScript 1.9.3
var Buttonbar,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Buttonbar = (function(superClass) {
  extend(Buttonbar, superClass);

  function Buttonbar(opts) {
    var btn, i, idx, len, ref, tt_opts;
    this.opts = opts != null ? opts : {};
    Buttonbar.__super__.constructor.call(this, this.opts);
    this.__box = new Template({
      name: "buttonbar"
    });
    this.registerTemplate(this.__box);
    this.__buttons = this.__box.DOM;
    this.__groupDivs = {};
    if (this._tooltip) {
      tt_opts = copyObject(this._tooltip);
      tt_opts.element = this.__buttons;
      this.__tooltip = new Tooltip(tt_opts);
    }
    ref = this._buttons;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      btn = ref[idx];
      this.addButton(btn, false);
    }
    this.__checkVisibility();
  }

  Buttonbar.prototype.initOpts = function() {
    Buttonbar.__super__.initOpts.call(this);
    return this.addOpts({
      buttons: {
        mandatory: true,
        "default": [],
        check: Array
      },
      tooltip: {
        check: "PlainObject"
      }
    });
  };

  Buttonbar.prototype.__proxy = function() {
    var args, el, ele, func, i, len, ref;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    ref = DOM.matchSelector(this.__buttons, ".cui-button,.cui-select");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      ele = DOM.data(el, "element");
      ele[func].apply(ele, args);
    }
    return this;
  };

  Buttonbar.prototype.disable = function() {
    return this.__proxy("disable");
  };

  Buttonbar.prototype.enable = function() {
    return this.__proxy("enable");
  };

  Buttonbar.prototype.__checkVisibility = function() {
    var c, count, d, el, grp, i, idx, j, len, len1, ref, ref1, ref2, visible;
    DOM.showElement(this.__buttons);
    for (grp in this.__groupDivs) {
      d = this.__groupDivs[grp];
      count = 0;
      ref = d.children;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        c = ref[idx];
        c.classList.remove("cui-first-visible-child");
        if (CUI.DOM.isVisible(c)) {
          count = count + 1;
        }
        if (count === 1) {
          c.classList.add("cui-first-visible-child");
        }
      }
      if (count > 0) {
        DOM.showElement(d);
      } else {
        DOM.hideElement(d);
      }
    }
    visible = 0;
    ref1 = CUI.DOM.children(this.__buttons);
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      el = ref1[j];
      el.classList.remove("cui-first-visible-child");
      if (!DOM.isVisible(el)) {
        continue;
      }
      visible++;
      if (visible === 1) {
        el.classList.add("cui-first-visible-child");
      }
    }
    if (visible > 0) {
      if ((ref2 = this.__tooltip) != null ? ref2.isShown() : void 0) {
        this.__tooltip.position();
      }
    } else {
      DOM.showElement(this.__buttons);
    }
    return this;
  };

  Buttonbar.prototype.removeButtons = function() {
    return DOM.empty(this.__buttons);
  };

  Buttonbar.prototype.prependButton = function(btn, check_visibility) {
    if (check_visibility == null) {
      check_visibility = true;
    }
    return this.addButton(btn, check_visibility, true);
  };

  Buttonbar.prototype.addButton = function(btn, check_visibility, prepend) {
    var btn_dom, div, func, grp, ref;
    if (check_visibility == null) {
      check_visibility = true;
    }
    if (prepend == null) {
      prepend = false;
    }
    if (isNull(btn)) {
      return;
    }
    if (CUI.isPlainObject(btn)) {
      btn = new CUI.defaults["class"].Button(btn);
    }
    if (btn instanceof Button || btn instanceof DataFieldInput) {
      btn_dom = btn.DOM;
      grp = btn.getGroup();
    } else if (btn instanceof Label) {
      btn_dom = btn.DOM;
    } else if (btn != null ? (ref = btn.classList) != null ? ref.contains("cui-button") : void 0 : void 0) {
      btn_dom = btn;
      grp = btn.group || null;
    } else {
      assert(false, "new " + this.__cls, "button must be instance of Button or have class \".cui-button\" but is " + (getObjectClass(btn)) + ".", {
        button: btn,
        opts: this.opts
      });
    }
    Events.listen({
      type: ["show", "hide"],
      node: btn,
      call: (function(_this) {
        return function(ev) {
          return _this.__checkVisibility();
        };
      })(this)
    });
    if (prepend) {
      func = "prepend";
    } else {
      func = "append";
    }
    if (grp) {
      if (!this.__groupDivs[grp]) {
        div = $div("cui-buttonbar-group cui-buttonbar-group-" + grp);
        DOM.append(this.__buttons, div);
        this.__groupDivs[grp] = div;
      }
      CUI.DOM[func](this.__groupDivs[grp], btn_dom);
    } else {
      CUI.DOM[func](this.__buttons, btn_dom);
    }
    if (check_visibility) {
      this.__checkVisibility();
    }
    return btn;
  };

  return Buttonbar;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var Label,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Label = (function(superClass) {
  extend(Label, superClass);

  Label.defaults = {
    manage_overflow: {
      icon_inactive: "down",
      icon_active: "up",
      active_css_class: ""
    }
  };

  function Label(opts) {
    var tt_opts;
    this.opts = opts != null ? opts : {};
    Label.__super__.constructor.call(this, this.opts);
    this.__label = new Template({
      name: this._rotate_90 ? "label-rotate-90" : "label",
      map_prefix: "label",
      map: {
        icon: true,
        content: true
      }
    });
    this.registerTemplate(this.__label);
    if (this._icon) {
      this.setIcon(this._icon);
    }
    if (!isEmpty(this._text)) {
      this.setText(this._text);
    } else {
      this.setContent(this._content);
    }
    if (this._tooltip) {
      tt_opts = copyObject(this._tooltip);
      if (tt_opts.element == null) {
        tt_opts.element = this.DOM;
      }
      this.__tooltip = new Tooltip(tt_opts);
    }
    if (this._multiline) {
      this.addClass("cui-label-multiline");
    }
    if (this._centered) {
      this.addClass("cui-label-centered");
    }
    if (this._markdown) {
      this.addClass("cui-label-markdown");
    }
    if (this._manage_overflow) {
      this.addClass("cui-label-manage-overflow");
    }
    if (this._size === "auto") {
      this.addClass("cui-label-size-normal");
    }
    this.addClass("cui-label-size-" + this._size);
    if (this._appearance === "auto") {
      this.addClass("cui-label-appearance-normal");
    }
    this.addClass("cui-label-appearance-" + this._appearance);
  }

  Label.prototype.initOpts = function() {
    Label.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        check: function(v) {
          return isString(v) || isNumber(v);
        }
      },
      content: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      size: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "mini", "normal", "big", "bigger"]
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      appearance: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "normal", "important", "title"]
      },
      tooltip: {
        check: "PlainObject"
      },
      rotate_90: {
        "default": false,
        check: Boolean
      },
      centered: {
        "default": false,
        check: Boolean
      },
      multiline: {
        "default": false,
        check: Boolean
      },
      manage_overflow: {
        check: function(v) {
          return CUI.isPlainObject(v) || v === true || v === false;
        }
      }
    });
  };

  Label.prototype.readOpts = function() {
    Label.__super__.readOpts.call(this);
    if (isNull(this._text) && isNull(this._content)) {
      this._text = "";
    }
    if (this._markdown) {
      assert(!this._content, "new " + this.__cls, "opts.markdown cannot be combined with opts.content, use opts.text instead.", {
        opts: this.opts
      });
      if (!marked) {
        CUI.error("new Label: Could not find markdown renderer 'marked'. Disabling markedown option.", {
          opts: this.opts
        });
        this.__markdown = false;
      } else {
        this.__markdown = true;
      }
    }
    this.__currentText = null;
    assert(xor(isNull(this._text), isNull(this._content)), "new Label", "opts.text and opts.content cannot both be set.", {
      opts: this.opts
    });
    if (this._manage_overflow) {
      assert(this._multiline, "new Label", "opts.multiline needs to be set for opts.manage_overflow", {
        opts: this.opts
      });
    }
    return this;
  };

  Label.prototype.setText = function(__currentText, markdown) {
    this.__currentText = __currentText;
    if (markdown == null) {
      markdown = this.__markdown;
    }
    if (isEmpty(this.__currentText)) {
      this.empty("content");
    } else if (markdown) {
      this.setContent(CUI.DOM.htmlToNodes(marked(this.__currentText)));
    } else {
      this.setContent($text(this.__currentText));
    }
    return this;
  };

  Label.prototype.getText = function() {
    return this.__currentText;
  };

  Label.prototype.setContent = function(content) {
    var btn_opts, k, overflow_button, ref, v;
    if (this._manage_overflow) {
      this.__overflow_content_div = $div("cui-label-manage-overflow-content-container").append(content);
      this.replace(this.__overflow_content_div, "content");
      this.__overflow_button_div = $div("cui-label-manage-overflow-button-container", {
        style: "display: none;"
      });
      if (this._manage_overflow === true) {
        btn_opts = CUI.defaults["class"].Label.defaults.manage_overflow;
      } else {
        btn_opts = this._manage_overflow;
      }
      ref = {
        "class": "cui-label-manage-overflow-button",
        appearance: "flat",
        "switch": true,
        activate_initial: false,
        onActivate: (function(_this) {
          return function() {
            return _this.setOverflowSize(true);
          };
        })(this),
        onDeactivate: (function(_this) {
          return function() {
            return _this.setOverflowSize(false);
          };
        })(this)
      };
      for (k in ref) {
        v = ref[k];
        if (!btn_opts.hasOwnProperty(k) || (k !== "class")) {
          btn_opts[k] = v;
          continue;
        }
        btn_opts[k] += " " + v;
      }
      overflow_button = new CUI.defaults["class"].Button(btn_opts);
      this.__overflow_button_div.append(overflow_button.DOM[0]);
      this.append(this.__overflow_button_div, "content");
      CUI.DOM.waitForDOMInsert({
        node: this.DOM[0]
      }).done((function(_this) {
        return function() {
          return _this.initOverflowSize();
        };
      })(this));
      return Events.listen({
        node: this.DOM[0],
        type: "viewport-resize",
        call: (function(_this) {
          return function() {
            return _this.initOverflowSize();
          };
        })(this)
      });
    } else {
      return this.replace(content, "content");
    }
  };

  Label.prototype.initOverflowSize = function() {
    var dim_btn, dim_content, dim_div;
    CUI.DOM.setStyle(this.__overflow_content_div[0], {
      height: ""
    });
    CUI.DOM.setStyle(this.__label.map.content[0], {
      height: "",
      maxHeight: ""
    });
    DOM.hideElement(this.__overflow_button_div[0]);
    dim_div = DOM.getDimensions(this.__label.map.content[0]);
    if (!(dim_div.scrollHeight > dim_div.clientHeight)) {
      return;
    }
    DOM.showElement(this.__overflow_button_div[0]);
    dim_content = DOM.getDimensions(this.__overflow_content_div[0]);
    dim_btn = DOM.getDimensions(this.__overflow_button_div[0]);
    this.__overflow_heights = {
      content_hide: dim_div.clientHeight - dim_btn.marginBoxHeight,
      content_show: dim_content.scrollHeight,
      button: dim_btn.marginBoxHeight
    };
    this.setOverflowSize();
    return this;
  };

  Label.prototype.setOverflowSize = function(showOverflow) {
    var content_height;
    if (showOverflow == null) {
      showOverflow = false;
    }
    if (showOverflow) {
      content_height = this.__overflow_heights.content_show;
    } else {
      content_height = this.__overflow_heights.content_hide;
    }
    CUI.DOM.setDimensions(this.__overflow_content_div[0], {
      marginBoxHeight: content_height
    });
    CUI.DOM.setDimensions(this.__label.map.content[0], {
      height: content_height + this.__overflow_heights.button
    });
    CUI.DOM.setStyle(this.__label.map.content[0], {
      maxHeight: content_height + this.__overflow_heights.button
    });
    Events.wait({
      type: "transitionend",
      node: this.__label.map.content
    }).always((function(_this) {
      return function() {
        return Events.trigger({
          type: "content-resize",
          node: _this.__label.map.content
        });
      };
    })(this));
    return this;
  };

  Label.prototype.setIcon = function(icon) {
    var __icon;
    if (icon instanceof Icon) {
      __icon = icon;
    } else if (!isEmpty(icon)) {
      __icon = new Icon({
        icon: icon
      });
    } else {
      __icon = null;
    }
    this.replace(__icon, "icon");
    return this;
  };

  Label.prototype.destroy = function() {
    var ref;
    if ((ref = this.__tooltip) != null) {
      ref.destroy();
    }
    return Label.__super__.destroy.call(this);
  };

  return Label;

})(CUI.DOM);

CUI.defaults["class"].Label = CUI.Label;

Label = CUI.Label;
// Generated by CoffeeScript 1.9.3
var MultilineLabel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultilineLabel = (function(superClass) {
  extend(MultilineLabel, superClass);

  function MultilineLabel(opts) {
    this.opts = opts != null ? opts : {};
    MultilineLabel.__super__.constructor.call(this, this.opts);
    this.addClass("cui-label");
  }

  MultilineLabel.prototype.initOpts = function() {
    MultilineLabel.__super__.initOpts.call(this);
    return this.mergeOpt("multiline", {
      "default": true
    });
  };

  return MultilineLabel;

})(Label);
// Generated by CoffeeScript 1.9.3
var EmptyLabel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EmptyLabel = (function(superClass) {
  extend(EmptyLabel, superClass);

  function EmptyLabel(opts) {
    this.opts = opts != null ? opts : {};
    EmptyLabel.__super__.constructor.call(this, this.opts);
    this.addClass("cui-empty-label");
  }

  EmptyLabel.prototype.readOpts = function() {
    if (isUndef(this.opts.appearance) && this.opts.centered) {
      this.opts.size = "big";
    }
    return EmptyLabel.__super__.readOpts.call(this);
  };

  return EmptyLabel;

})(MultilineLabel);
// Generated by CoffeeScript 1.9.3
var ProgressMeter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ProgressMeter = (function(superClass) {
  extend(ProgressMeter, superClass);

  function ProgressMeter(opts) {
    this.opts = opts != null ? opts : {};
    ProgressMeter.__super__.constructor.call(this, this.opts);
    this.__meter = new Template({
      name: "progress-meter",
      map: {
        icon: true,
        text: true,
        fill: true
      }
    });
    this.registerTemplate(this.__meter);
    if (this._state) {
      this.setState(this._state);
    } else if (this._states.length) {
      this.setState(this._states[0]);
    }
  }

  ProgressMeter.prototype.__checkState = function(state) {
    return indexOf.call(this._states, state) >= 0 || (typeof state === "number" && state >= 0 && state <= 100);
  };

  ProgressMeter.prototype.initOpts = function() {
    var i, len, ref, results, state;
    ProgressMeter.__super__.initOpts.call(this);
    if (!this.opts.states) {
      this.opts.states = Object.keys(CUI.defaults.ProgressMeter.states);
    }
    this.addOpts({
      states: {
        check: Array
      },
      state: {
        check: (function(_this) {
          return function(v) {
            return _this.__checkState(v);
          };
        })(this)
      },
      css_property_percent: {
        "default": "width",
        check: String
      },
      size: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "mini", "normal", "big"]
      },
      appearance: {
        "default": "auto",
        mandatory: true,
        check: ["auto", "normal", "important"]
      },
      onUpdate: {
        check: Function
      }
    });
    ref = this.opts.states;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      state = ref[i];
      results.push(this.addOpt("icon_" + state, {
        "default": CUI.defaults.ProgressMeter.states[state],
        check: (function(_this) {
          return function(v) {
            return v instanceof Icon || isString(v);
          };
        })(this)
      }));
    }
    return results;
  };

  ProgressMeter.prototype.getState = function() {
    return this.__state;
  };

  ProgressMeter.prototype.getMeter = function() {
    return this.__meter;
  };

  ProgressMeter.prototype.setState = function(state) {
    var fill_css, icon, ref, ref1;
    assert(this.__checkState(state), "ProgressMeter.setState", "state needs to be " + this._states.join(",") + " or between 0 and 100.", {
      state: state
    });
    if (typeof state === "number") {
      state = Math.round(state * 100) / 100;
    }
    if (this.__state === state) {
      return;
    }
    this.__state = state;
    if (ref = this.__state, indexOf.call(this._states, ref) >= 0) {
      icon = this["_icon_" + this.__state];
      if (icon instanceof Icon) {
        this.__meter.replace(icon, "icon");
      } else if (!isEmpty(icon)) {
        this.__meter.replace(new Icon({
          icon: icon
        }), "icon");
      } else {
        this.__meter.empty("icon");
      }
      this.__meter.DOM.attr("state", this.__state);
      this.__meter.empty("text");
      fill_css = {};
      fill_css[this._css_property_percent] = "";
    } else {
      this.__meter.DOM.attr("state", "percent");
      this.__meter.empty("icon");
      this.__meter.replace(Math.round(this.__state) + "%", "text");
      fill_css = {};
      fill_css[this._css_property_percent] = this.__state + "%";
    }
    this.__meter.map.fill.css(fill_css);
    if ((ref1 = this._onUpdate) != null) {
      ref1.call(this, this);
    }
    return this;
  };

  return ProgressMeter;

})(CUI.DOM);

CUI.defaults.ProgressMeter = {
  states: {
    waiting: "fa-hourglass",
    spinning: "fa-spinner cui-spin-stepped"
  }
};
// Generated by CoffeeScript 1.9.3
var Block,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Block = (function(superClass) {
  extend(Block, superClass);

  function Block(opts) {
    this.opts = opts != null ? opts : {};
    Block.__super__.constructor.call(this, this.opts);
    this.__block = new Template({
      name: this.getTemplateName(),
      map: {
        header: true,
        content: true
      }
    });
    this.registerTemplate(this.__block);
    if (this._header) {
      this.setHeader(this._header);
    } else {
      this.__label = new Label({
        text: this._text,
        icon: this._icon,
        multiline: true
      });
      this.setHeader(this.__label);
    }
    if (this._content) {
      this.setContent(this._content);
    }
    this.addClass("appearance-" + this._appearance);
    this.addClass("cui-block-level-" + this._level);
  }

  Block.prototype.initOpts = function() {
    Block.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        check: String
      },
      header: {
        check: function(v) {
          return !!(isContent(v) || isString(v) || (v != null ? v.DOM : void 0));
        }
      },
      icon: {
        check: Icon
      },
      content: {
        check: function(v) {
          return !!(isContent(v) || isString(v) || (v != null ? v.DOM : void 0));
        }
      },
      level: {
        mandatory: true,
        "default": 1,
        check: [1, 2, 3]
      },
      appearance: {
        deprectated: true,
        "default": "normal",
        mandatory: true,
        check: ["title", "subtitle", "normal"]
      }
    });
  };

  Block.prototype.readOpts = function() {
    Block.__super__.readOpts.call(this);
    assert(!((this._text || this._icon) && this._header), "new Block", "opts.text and opts.header are mutually exclusive.", {
      opts: this.opts
    });
    return this;
  };

  Block.prototype.getTemplateName = function() {
    return "block";
  };

  Block.prototype.setText = function(txt) {
    assert(this.__label, "Block.setText", "Block must not be called with opts.header.", {
      opts: this.opts
    });
    return this.__label.setText(txt);
  };

  Block.prototype.setIcon = function(icon) {
    assert(this.__label, "Block.setText", "Block must not be called with opts.header.", {
      opts: this.opts
    });
    return this.__label.setIcon(icon);
  };

  Block.prototype.setHeader = function(header) {
    return this.__block.replace(header, "header");
  };

  Block.prototype.setContent = function(content) {
    return this.__block.replace(content, "content");
  };

  Block.prototype.appendContent = function(content) {
    return this.__block.append(content, "content");
  };

  return Block;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var WaitBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

WaitBlock = (function(superClass) {
  extend(WaitBlock, superClass);

  function WaitBlock(opts) {
    this.opts = opts != null ? opts : {};
    WaitBlock.__super__.constructor.call(this, this.opts);
    if (this._inactive) {
      this.DOM.addClass("cui-wait-block-inactive");
    }
    if (this._fullscreen) {
      this.DOM.addClass("cui-wait-block-fullscreen");
    }
  }

  WaitBlock.prototype.initOpts = function() {
    WaitBlock.__super__.initOpts.call(this);
    this.mergeOpt("icon", {
      check: function(v) {
        return v instanceof Icon || isString(v);
      }
    });
    this.removeOpt("header");
    this.removeOpt("content");
    return this.addOpts({
      inactive: {
        check: Boolean
      },
      element: {
        check: function(v) {
          return isElement(v) || isElement(v.DOM);
        }
      },
      fullscreen: {
        check: Boolean
      }
    });
  };

  WaitBlock.prototype.readOpts = function() {
    WaitBlock.__super__.readOpts.call(this);
    assert(xor(this._element, this._fullscreen), "new WaitBlock", "opts.element or opt.fullscreen needs to be set.", {
      opts: this.opts
    });
    if (this._fullscreen) {
      this.__element = $(document.body);
    } else if (this._element.DOM) {
      this.__element = this._element.DOM;
    } else {
      this.__element = this._element;
    }
    if (!this._inactive && !this.opts.hasOwnProperty("icon")) {
      this._icon = "spinner";
    }
    this.__shown = false;
    this.__savedPosition = null;
    return this;
  };

  WaitBlock.prototype.getTemplateName = function() {
    return "wait-block";
  };

  WaitBlock.prototype.show = function() {
    var position;
    position = this.__element[0].style.position;
    if (!DOM.isPositioned(this.__element[0])) {
      this.__savedPosition = this.__element[0].style.position;
      this.__element[0].style.position = "relative";
    } else {
      this.__savedPosition = null;
    }
    this.__element.addClass("cui-wait-block-active");
    if (this._fullscreen) {
      this.DOM.appendTo(this.__element);
    } else {
      this.__element.append(this.DOM);
    }
    this.__shown = true;
    return this;
  };

  WaitBlock.prototype.isShown = function() {
    return !!this.__shown;
  };

  WaitBlock.prototype.hide = function() {
    if (!this.isShown()) {
      return this;
    }
    this.DOM.detach();
    if (this.__savedPosition !== null) {
      this.__element[0].style.position = this.__savedPosition;
    }
    this.__element.removeClass("cui-wait-block-active");
    this.__shown = false;
    this.__savedPosition = null;
    return this;
  };

  WaitBlock.prototype.destroy = function() {
    this.hide();
    return WaitBlock.__super__.destroy.call(this);
  };

  return WaitBlock;

})(Block);
// Generated by CoffeeScript 1.9.3
var BorderLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

BorderLayout = (function(superClass) {
  extend(BorderLayout, superClass);

  function BorderLayout() {
    return BorderLayout.__super__.constructor.apply(this, arguments);
  }

  BorderLayout.prototype.getName = function() {
    return "border-layout";
  };

  BorderLayout.prototype.getPanes = function() {
    return ["north", "west", "east", "south"];
  };

  BorderLayout.prototype.getSupportedPanes = function() {
    return this.getPanes();
  };

  BorderLayout.prototype.getTemplateMap = function() {
    var map;
    map = BorderLayout.__super__.getTemplateMap.call(this);
    map.row = true;
    return map;
  };

  BorderLayout.prototype.__init = function() {
    BorderLayout.__super__.__init.call(this);
    if (this._absolute) {
      this.getLayout().map.row.addClass("cui-absolute");
      Events.listen({
        type: "viewport-resize",
        node: this.getLayout().map.row,
        call: (function(_this) {
          return function(ev) {
            ev.stopPropagation();
            return Layout.setAbsolute(_this.getLayout().map.row);
          };
        })(this)
      });
    }
    return this;
  };

  return BorderLayout;

})(Layout);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Console = (function(superClass) {
  extend(Console, superClass);

  function Console(opts) {
    this.opts = opts != null ? opts : {};
    Console.__super__.constructor.call(this, this.opts);
    this.__console = CUI.DOM.element("DIV", {
      "class": "cui-console"
    });
    this.registerDOMElement(this.__console);
  }

  Console.prototype.initOpts = function() {
    Console.__super__.initOpts.call(this);
    console.debug("init opts console");
    return this.addOpts({
      markdown: {
        mandatory: true,
        "default": true,
        check: Boolean
      }
    });
  };

  Console.prototype.clear = function() {
    return this.__console.innerHTML = "";
  };

  Console.prototype.log = function(txt, markdown) {
    var lbl;
    if (markdown == null) {
      markdown = this._markdown;
    }
    lbl = new CUI.defaults["class"].Label({
      text: txt,
      multiline: true,
      markdown: markdown
    });
    this.__console.appendChild(lbl.DOM[0]);
    return this.__console.scrollTop = this.__console.scrollHeight;
  };

  return Console;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var HorizontalLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.HorizontalLayout = (function(superClass) {
  extend(HorizontalLayout, superClass);

  function HorizontalLayout() {
    return HorizontalLayout.__super__.constructor.apply(this, arguments);
  }

  HorizontalLayout.prototype.getName = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return "horizontal-layout";
    }
    panes = this.getPanes();
    if (panes.length === 2) {
      return "horizontal-layout-left-center-right";
    } else if (indexOf.call(panes, "left") >= 0) {
      return "horizontal-layout-left-center";
    } else if (indexOf.call(panes, "right") >= 0) {
      return "horizontal-layout-center-right";
    } else {
      return "horizontal-layout-center";
    }
  };

  HorizontalLayout.prototype.getMapPrefix = function() {
    return "horizontal-layout";
  };

  HorizontalLayout.prototype.hasFlexHandles = function() {
    var ref, ref1;
    if (((ref = this._left) != null ? ref.flexHandle : void 0) || ((ref1 = this._right) != null ? ref1.flexHandle : void 0)) {
      return true;
    }
    return false;
  };

  HorizontalLayout.prototype.getPanes = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return ["left", "right"];
    }
    panes = [];
    if (this._left) {
      panes.push("left");
    }
    if (this._right) {
      panes.push("right");
    }
    return panes;
  };

  HorizontalLayout.prototype.getSupportedPanes = function() {
    return ["left", "right"];
  };

  return HorizontalLayout;

})(CUI.Layout);

HorizontalLayout = CUI.HorizontalLayout;
// Generated by CoffeeScript 1.9.3
var VerticalLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.VerticalLayout = (function(superClass) {
  extend(VerticalLayout, superClass);

  function VerticalLayout() {
    return VerticalLayout.__super__.constructor.apply(this, arguments);
  }

  VerticalLayout.prototype.getName = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return "vertical-layout";
    }
    panes = this.getPanes();
    if (panes.length === 2) {
      return "vertical-layout-top-center-bottom";
    } else if (indexOf.call(panes, "top") >= 0) {
      return "vertical-layout-top-center";
    } else if (indexOf.call(panes, "bottom") >= 0) {
      return "vertical-layout-center-bottom";
    } else {
      return "vertical-layout-center";
    }
  };

  VerticalLayout.prototype.getMapPrefix = function() {
    return "vertical-layout";
  };

  VerticalLayout.prototype.hasFlexHandles = function() {
    var ref, ref1;
    if (((ref = this._top) != null ? ref.flexHandle : void 0) || ((ref1 = this._bottom) != null ? ref1.flexHandle : void 0)) {
      return true;
    }
    return false;
  };

  VerticalLayout.prototype.getPanes = function() {
    var panes;
    if (this.hasFlexHandles()) {
      return ["top", "bottom"];
    }
    panes = [];
    if (this._top) {
      panes.push("top");
    }
    if (this._bottom) {
      panes.push("bottom");
    }
    return panes;
  };

  VerticalLayout.prototype.getSupportedPanes = function() {
    return ["top", "bottom"];
  };

  return VerticalLayout;

})(CUI.Layout);

VerticalLayout = CUI.VerticalLayout;
// Generated by CoffeeScript 1.9.3
var VerticalList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.VerticalList = (function(superClass) {
  extend(VerticalList, superClass);

  function VerticalList() {
    return VerticalList.__super__.constructor.apply(this, arguments);
  }

  VerticalList.prototype.initOpts = function() {
    VerticalList.__super__.initOpts.call(this);
    this.mergeOpt("maximize", {
      "default": false
    });
    this.removeOpt("center");
    return this.addOpts({
      content: {}
    });
  };

  VerticalList.prototype.readOpts = function() {
    VerticalList.__super__.readOpts.call(this);
    return this._center = {
      content: this._content
    };
  };

  VerticalList.prototype.getSupportedPanes = function() {
    return [];
  };

  return VerticalList;

})(CUI.VerticalLayout);

VerticalList = CUI.VerticalList;
// Generated by CoffeeScript 1.9.3
var HorizontalList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.HorizontalList = (function(superClass) {
  extend(HorizontalList, superClass);

  function HorizontalList() {
    return HorizontalList.__super__.constructor.apply(this, arguments);
  }

  HorizontalList.prototype.initOpts = function() {
    HorizontalList.__super__.initOpts.call(this);
    this.mergeOpt("maximize", {
      "default": false
    });
    this.removeOpt("center");
    return this.addOpts({
      content: {}
    });
  };

  HorizontalList.prototype.readOpts = function() {
    HorizontalList.__super__.readOpts.call(this);
    return this._center = {
      content: this._content
    };
  };

  HorizontalList.prototype.getSupportedPanes = function() {
    return [];
  };

  return HorizontalList;

})(CUI.HorizontalLayout);

HorizontalList = CUI.HorizontalList;
// Generated by CoffeeScript 1.9.3
var Toolbar,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Toolbar = (function(superClass) {
  extend(Toolbar, superClass);

  function Toolbar() {
    return Toolbar.__super__.constructor.apply(this, arguments);
  }

  Toolbar.prototype.init = function() {
    Toolbar.__super__.init.call(this);
    return this.addClass("cui-toolbar");
  };

  Toolbar.prototype.initOpts = function() {
    Toolbar.__super__.initOpts.call(this);
    if (CUI.__ng__) {
      this.removeOpt("maximize");
      this.removeOpt("maximize_horizontal");
      this.removeOpt("maximize_vertical");
      return this.addOpts({
        maximize_horizontal: {
          "default": true,
          mandatory: true,
          check: Boolean
        }
      });
    }
  };

  Toolbar.prototype.hasFlexHandles = function() {
    return false;
  };

  Toolbar.prototype.getPanes = function() {
    return ["left", "right"];
  };

  return Toolbar;

})(HorizontalLayout);
// Generated by CoffeeScript 1.9.3
var Pane,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Pane = (function(superClass) {
  extend(Pane, superClass);

  function Pane() {
    return Pane.__super__.constructor.apply(this, arguments);
  }

  Pane.prototype.__init = function() {
    Pane.__super__.__init.call(this);
    this.addClass("cui-pane");
    return this.__fill_screen_is_on = false;
  };

  Pane.prototype.readOpts = function() {
    this.initDefaultPanes();
    return Pane.__super__.readOpts.call(this);
  };

  Pane.prototype.getFillScreenState = function() {
    return this.__fill_screen_is_on;
  };

  Pane.prototype.endFillScreen = function(transition) {
    var end_fill_screen;
    if (transition == null) {
      transition = true;
    }
    if (!this.getFillScreenState()) {
      return;
    }
    this.__fill_screen_is_on = false;
    if (!$elementIsInDOM(this.__placeholder)) {
      this.__fillscreenTmpl.destroy();
      this.__placeholder = null;
    } else {
      end_fill_screen = (function(_this) {
        return function() {
          _this.__placeholder.before(_this.DOM);
          _this.__placeholder.remove();
          _this.__fillscreenTmpl.destroy();
          delete _this.__fillscreenTmpl;
          Events.trigger({
            type: "end-fill-screen",
            node: _this.DOM
          });
          return Events.trigger({
            type: "viewport-resize",
            node: _this.DOM
          });
        };
      })(this);
      if (transition) {
        Events.wait({
          type: "transitionend",
          node: this.__fillscreenTmpl
        }).always((function(_this) {
          return function() {
            return end_fill_screen();
          };
        })(this));
        this.__fillscreenTmpl.removeClass("cui-pane-fill-screen-is-on");
      } else {
        end_fill_screen();
      }
    }
    return this;
  };

  Pane.prototype.startFillScreen = function() {
    var adjust, checkToggle, el, i, inner, j, key_copy, len, len1, rect, rect_fill, rect_fill_inner, ref, ref1, start_rect, vp;
    if (this.getFillScreenState()) {
      return;
    }
    this.__fillscreenTmpl = new Template({
      name: "pane-fill-screen",
      map: {
        inner: true
      }
    });
    rect = this.DOM.rect();
    vp = CUI.DOM.getDimensions(window);
    this.__placeholderTmpl = new Template({
      name: "pane-fill-screen-placeholder"
    });
    this.__placeholder = this.__placeholderTmpl.DOM;
    inner = this.__fillscreenTmpl.map.inner;
    ref = this.DOM.parents(".cui-dom-element");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      inner.addClass(DOM.data(el, "element").getDOMElementClasses());
    }
    this.__fillscreenTmpl.DOM.appendTo(document.body);
    rect_fill = this.__fillscreenTmpl.DOM.rect();
    rect_fill_inner = inner.rect();
    adjust = {
      left: (rect_fill_inner.left - rect_fill.left) + inner.cssEdgeSpace("left"),
      top: (rect_fill_inner.top - rect_fill.top) + inner.cssEdgeSpace("top"),
      right: (rect_fill.right - rect_fill_inner.right) + inner.cssEdgeSpace("right"),
      bottom: (rect_fill.bottom - rect_fill_inner.bottom) + inner.cssEdgeSpace("bottom")
    };
    start_rect = {
      top: rect.top - adjust.top,
      left: rect.left - adjust.left,
      bottom: vp.height - rect.bottom - adjust.bottom,
      right: vp.width - rect.right - adjust.right
    };
    this.__fillscreenTmpl.DOM.detach();
    this.__fillscreenTmpl.DOM.css(start_rect);
    this.__fillscreenTmpl.DOM.appendTo(document.body);
    this.__placeholder.css({
      width: this.DOM.outerWidth(true),
      height: this.DOM.outerHeight(true)
    });
    ref1 = ["position", "top", "left", "right", "bottom"];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      key_copy = ref1[j];
      this.__placeholder.css(key_copy, this.DOM.css(key_copy));
    }
    this.DOM.after(this.__placeholder);
    this.__fillscreenTmpl.replace(this.DOM, "inner");
    Events.wait({
      type: "transitionend",
      node: this.__fillscreenTmpl
    }).always((function(_this) {
      return function() {
        Events.trigger({
          type: "start-fill-screen",
          node: _this.DOM
        });
        return Events.trigger({
          type: "viewport-resize",
          node: _this.DOM
        });
      };
    })(this));
    this.__fillscreenTmpl.addClass("cui-pane-fill-screen-is-on");
    this.__fill_screen_is_on = true;
    checkToggle = (function(_this) {
      return function() {
        if (!_this.getFillScreenState()) {
          return;
        }
        if (!$elementIsInDOM(_this.__placeholder)) {
          _this.endFillScreen();
        }
        return CUI.setTimeout(checkToggle, 50);
      };
    })(this);
    checkToggle();
    return this.__fill_screen_is_on;
  };

  Pane.prototype.toggleFillScreen = function() {
    if (this.getFillScreenState()) {
      return this.endFillScreen();
    } else {
      return this.startFillScreen();
    }
  };

  Pane.getToggleFillScreenButton = function(opts) {
    var k, ref, v;
    if (opts == null) {
      opts = {};
    }
    ref = {
      icon_inactive: new Icon({
        "class": "fa-expand"
      }),
      icon_active: new Icon({
        "class": "fa-compress"
      }),
      "switch": true,
      onClick: (function(_this) {
        return function(ev, btn) {
          return DOM.data(btn.DOM.closest(".cui-pane")[0], "element").toggleFillScreen();
        };
      })(this)
    };
    for (k in ref) {
      v = ref[k];
      opts[k] = v;
    }
    return new CUI.defaults["class"].Button(opts);
  };

  return Pane;

})(CUI.VerticalLayout);

CUI.Events.registerEvent({
  type: ["start-fill-screen", "end-fill-screen"],
  sink: true
});

Pane = CUI.Pane;
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.LayerPane = (function(superClass) {
  extend(LayerPane, superClass);

  function LayerPane(opts) {
    this.opts = opts != null ? opts : {};
    LayerPane.__super__.constructor.call(this, this.opts);
    this.setPane(this._pane);
  }

  LayerPane.prototype.initOpts = function() {
    LayerPane.__super__.initOpts.call(this);
    return this.addOpts({
      pane: {
        mandatory: true,
        "default": new SimplePane(),
        check: function(v) {
          return v instanceof Pane || CUI.isPlainObject(v);
        }
      }
    });
  };

  LayerPane.prototype.getPane = function() {
    return this.__pane;
  };

  LayerPane.prototype.setPane = function(pane) {
    if (CUI.isPlainObject(pane)) {
      this.__pane = new SimplePane(pane);
    } else {
      this.__pane = pane;
    }
    this.__pane.addClass("cui-layer-pane");
    return CUI.Layer.prototype.replace.call(this, this.__pane);
  };

  LayerPane.prototype.destroy = function() {
    this.__pane.destroy();
    return LayerPane.__super__.destroy.call(this);
  };

  return LayerPane;

})(CUI.Layer);
// Generated by CoffeeScript 1.9.3
var SimplePane,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.SimplePane = (function(superClass) {
  extend(SimplePane, superClass);

  function SimplePane() {
    return SimplePane.__super__.constructor.apply(this, arguments);
  }

  SimplePane.prototype.__init = function() {
    var i, k, len, ref;
    SimplePane.__super__.__init.call(this);
    ref = ["header_left", "header_center", "header_right", "footer_left", "footer_right"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this.append(this["_" + k], k);
    }
    if (this._title) {
      this.append(new Label({
        text: this._title
      }), "header_left");
    }
    return this.addClass("cui-simple-pane");
  };

  SimplePane.prototype.initOpts = function() {
    SimplePane.__super__.initOpts.call(this);
    this.addOpts({
      title: {},
      header_right: {},
      header_center: {},
      header_left: {},
      footer_left: {},
      footer_right: {},
      content: {}
    });
    this.removeOpt("top");
    this.removeOpt("bottom");
    this.removeOpt("center");
    this.mergeOpt("padding", {
      "default": "normal"
    });
    return this;
  };

  SimplePane.prototype.readOpts = function() {
    VerticalLayout.prototype.readOpts.call(this);
    if (this._title) {
      assert(!this._header_left, "new SimplePane", "opts.header_left conflicts with opts.title", {
        opts: this.opts
      });
    }
    this.__pane_header = new PaneHeader();
    this.__pane_footer = new PaneFooter();
    this._top = {
      content: this.__pane_header
    };
    this._bottom = {
      content: this.__pane_footer
    };
    this._center = {
      content: this._content
    };
    return this;
  };

  SimplePane.prototype.destroy = function() {
    this.__pane_header.destroy();
    this.__pane_footer.destroy();
    return SimplePane.__super__.destroy.call(this);
  };

  SimplePane.prototype.getPaneAndKey = function(key) {
    var m, pane, pn;
    if (key === "center" || key === "top" || key === "bottom") {
      return [this.getLayout(), key];
    } else if (key === "content") {
      return [this.getLayout(), "center"];
    } else {
      m = key.match(/^(.*?)_(.*)$/);
      assert((m != null ? m.length : void 0) === 3, "SimplePane.getPaneAndKey", "key " + key + " not matched.", {
        matched: m
      });
      pn = "__pane_" + (m != null ? m[1] : void 0);
      pane = this[pn];
      assert(pane, "SimplePane.getPaneAndKey", "pane " + pn + " not found.");
      return [pane, m[2]];
    }
  };

  SimplePane.prototype.empty = function(key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.empty(_key);
    return this;
  };

  SimplePane.prototype.append = function(content, key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.append(content, _key);
    return this;
  };

  SimplePane.prototype.replace = function(content, key) {
    var _key, pane, ref;
    if (key == null) {
      key = "center";
    }
    ref = this.getPaneAndKey(key), pane = ref[0], _key = ref[1];
    pane.replace(content, _key);
    return this;
  };

  return SimplePane;

})(CUI.Pane);

SimplePane = CUI.SimplePane;
// Generated by CoffeeScript 1.9.3
var PaneToolbar,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneToolbar = (function(superClass) {
  extend(PaneToolbar, superClass);

  function PaneToolbar() {
    return PaneToolbar.__super__.constructor.apply(this, arguments);
  }

  PaneToolbar.prototype.init = function() {
    PaneToolbar.__super__.init.call(this);
    return this.addClass("cui-pane-toolbar");
  };

  return PaneToolbar;

})(Toolbar);
// Generated by CoffeeScript 1.9.3
var PaneHeader,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneHeader = (function(superClass) {
  extend(PaneHeader, superClass);

  function PaneHeader() {
    return PaneHeader.__super__.constructor.apply(this, arguments);
  }

  PaneHeader.prototype.init = function() {
    PaneHeader.__super__.init.call(this);
    return this.addClass("cui-pane-header");
  };

  return PaneHeader;

})(Toolbar);
// Generated by CoffeeScript 1.9.3
var PaneFooter,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

PaneFooter = (function(superClass) {
  extend(PaneFooter, superClass);

  function PaneFooter() {
    return PaneFooter.__super__.constructor.apply(this, arguments);
  }

  PaneFooter.prototype.init = function() {
    PaneFooter.__super__.init.call(this);
    return this.addClass("cui-pane-footer");
  };

  return PaneFooter;

})(Toolbar);
// Generated by CoffeeScript 1.9.3
var Tab,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tab = (function(superClass) {
  extend(Tab, superClass);

  function Tab(opts) {
    var cls;
    this.opts = opts != null ? opts : {};
    Tab.__super__.constructor.call(this, this.opts);
    if (!isEmpty(this._name)) {
      cls = "ez-tab-" + (toClass(this._name));
    } else {
      cls = null;
    }
    this.__body = new Template({
      name: "tab-body",
      "class": cls
    });
    this.registerTemplate(this.__body);
    if (this._content_placeholder) {
      this.append(this._content_placeholder);
      this.__has_placeholder = true;
    }
    if (CUI.isFunction(this._content)) {
      if (!this._load_on_show) {
        this.loadContent();
      }
    } else if (this._content) {
      this.append(this._content);
    }
    this.__activations = 0;
  }

  Tab.prototype.initButton = function(tabs) {
    assert(tabs instanceof CUI.Tabs, "Tab.initButton", "Parameter #1 need to be instance of Tabs.", {
      tabs: tabs
    });
    this.__button = new Button({
      role: "tab-header",
      radio: "tabs--" + tabs.getUniqueId(),
      "class": "cui-tab-header-button",
      size: "big",
      group: CUI.__ng__ ? "tabs" : null,
      text: this._text,
      attr: {
        tab: this._name
      },
      active: false,
      onActivate: (function(_this) {
        return function(btn) {
          _this.__activations++;
          if (_this._load_on_show && !_this.__content_loaded) {
            _this.loadContent();
          }
          _this.show();
          if (_this.__activations === 1) {
            if (typeof _this._onFirstActivate === "function") {
              _this._onFirstActivate(_this);
            }
          }
          if (typeof _this._onActivate === "function") {
            _this._onActivate(_this);
          }
          return Events.trigger({
            type: "tab_activate",
            node: _this.DOM
          });
        };
      })(this),
      onDeactivate: (function(_this) {
        return function(btn) {
          _this.hide();
          if (typeof _this._onDeactivate === "function") {
            _this._onDeactivate(_this);
          }
          return Events.trigger({
            type: "tab_deactivate",
            node: _this.DOM
          });
        };
      })(this)
    });
    return this;
  };

  Tab.prototype.initOpts = function() {
    Tab.__super__.initOpts.call(this);
    return this.addOpts({
      name: {
        check: String
      },
      text: {
        mandatory: true,
        check: String
      },
      content: {
        mandatory: true,
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      onFirstActivate: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      content_placeholder: {
        check: function(v) {
          return isContent(v);
        }
      },
      load_on_show: {
        check: Boolean
      }
    });
  };

  Tab.prototype.loadContent = function() {
    return Panel.prototype.loadContent.call(this);
  };

  Tab.prototype.setContent = function(content) {
    return Panel.prototype.setContent.call(this, content, false);
  };

  Tab.prototype.appendContent = function(content) {
    return Panel.prototype.appendContent.call(this, content, false);
  };

  Tab.prototype.getText = function() {
    return this._text;
  };

  Tab.prototype.hide = function() {
    this.DOM.addClass("cui-tab-hidden");
    return this;
  };

  Tab.prototype.show = function() {
    this.DOM.removeClass("cui-tab-hidden");
    if (CUI.__ng__) {
      Events.trigger({
        type: "viewport-resize",
        node: this.DOM,
        info: {
          tab: true
        }
      });
    }
    return this;
  };

  Tab.prototype.destroy = function() {
    Events.trigger({
      type: "tab_destroy",
      node: this.DOM
    });
    this.__button.destroy();
    return Tab.__super__.destroy.call(this);
  };

  Tab.prototype.activate = function() {
    this.__button.activate();
    return this;
  };

  Tab.prototype.deactivate = function() {
    this.__button.deactivate();
    return this;
  };

  Tab.prototype.getButton = function() {
    return this.__button;
  };

  Tab.prototype.getBody = function() {
    return this.DOM;
  };

  return Tab;

})(CUI.DOM);

CUI.ready((function(_this) {
  return function() {
    Events.registerEvent({
      type: "tab_destroy"
    });
    Events.registerEvent({
      type: "tab_deactivate"
    });
    return Events.registerEvent({
      type: "tab_activate"
    });
  };
})(this));

Tab = CUI.Tab;
// Generated by CoffeeScript 1.9.3
var Tabs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tabs = (function(superClass) {
  extend(Tabs, superClass);

  function Tabs() {
    return Tabs.__super__.constructor.apply(this, arguments);
  }

  Tabs.prototype.initOpts = function() {
    Tabs.__super__.initOpts.call(this);
    this.removeOpt("header_right");
    this.removeOpt("header_center");
    this.removeOpt("content");
    return this.addOpts({
      tabs: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) && v.length > 0;
        }
      },
      active_idx: {
        check: "Integer"
      }
    });
  };

  Tabs.prototype.__checkOverflowButton = function() {
    var header_dim;
    if (!this.__maximize_horizontal) {
      return;
    }
    header_dim = DOM.getDimensions(this.__header);
    if (header_dim.scrollWidth > header_dim.clientWidth) {
      this.__overflowBtn.show();
      CUI.DOM.addClass(this.__pane_header.DOM, "cui-tabs-pane-header--overflow");
    } else {
      this.__overflowBtn.hide();
      CUI.DOM.removeClass(this.__pane_header.DOM, "cui-tabs-pane-header--overflow");
    }
    return this;
  };

  Tabs.prototype.__setActiveMarker = function() {
    var btn, btn_dim, ref;
    btn = (ref = this.getActiveTab()) != null ? ref.getButton().DOM[0] : void 0;
    if (!btn) {
      CUI.DOM.hideElement(this.__tabs_marker);
      return;
    }
    CUI.DOM.showElement(this.__tabs_marker);
    btn_dim = DOM.getDimensions(btn);
    DOM.setStyle(this.__tabs_marker, {
      left: btn_dim.offsetLeft,
      width: btn_dim.borderBoxWidth
    });
    return this;
  };

  Tabs.prototype.init = function() {
    var i, idx, len, pane_key, ref, startScrollLeft, tab;
    Tabs.__super__.init.call(this);
    this.__tabs_marker = CUI.DOM.element("DIV", {
      "class": "cui-tabs-active-marker"
    });
    this.__tabs_bodies = new Template({
      name: "tabs-bodies"
    });
    this.__buttonbar = new Buttonbar();
    startScrollLeft = null;
    new Draggable({
      element: this.__buttonbar.DOM,
      ms: 0,
      axis: "x",
      dragstart: (function(_this) {
        return function() {
          return startScrollLeft = _this.__header.scrollLeft;
        };
      })(this),
      dragging: (function(_this) {
        return function(ev, $target, diff) {
          return _this.__header.scrollLeft = startScrollLeft - diff.x;
        };
      })(this),
      helper: null
    });
    if (CUI.__ng__) {
      pane_key = "center";
    } else {
      pane_key = "left";
    }
    this.__pane_header.append(this.__buttonbar, pane_key);
    this.__pane_header.append(this.__tabs_marker, pane_key);
    this.__header = this.__pane_header[pane_key]()[0];
    Events.listen({
      type: "scroll",
      node: this.__header,
      call: (function(_this) {
        return function(ev) {
          var dim;
          dim = CUI.DOM.getDimensions(_this.__header);
          CUI.DOM.setClass(_this.__pane_header.DOM, "cui-tabs-pane-header--scroll-at-end", dim.horizontalScrollbarAtEnd);
          return CUI.DOM.setClass(_this.__pane_header.DOM, "cui-tabs-pane-header--scroll-at-start", dim.horizontalScrollbarAtStart);
        };
      })(this)
    });
    this.__overflowBtn = new Button({
      icon: "ellipsis_h",
      "class": "cui-tab-header-button-overflow",
      icon_right: false,
      menu: {
        items: (function(_this) {
          return function() {
            var btns, fn, i, len, ref, tab;
            btns = [];
            ref = _this.__tabs;
            fn = function(tab) {
              return btns.push({
                text: tab.getText(),
                active: tab === _this.getActiveTab(),
                onClick: function() {
                  return tab.activate();
                }
              });
            };
            for (i = 0, len = ref.length; i < len; i++) {
              tab = ref[i];
              fn(tab);
            }
            return btns;
          };
        })(this)
      }
    });
    this.__overflowBtn.hide();
    this.__pane_header.append(this.__overflowBtn, "right", false);
    this.getLayout().append(this.__tabs_bodies, "center");
    if (!CUI.__ng__) {
      if (!this.__maximize_horizontal || !this.__maximize_vertical) {
        Events.listen({
          node: this.getLayout(),
          type: "content-resize",
          call: (function(_this) {
            return function(event, info) {
              event.stopPropagation();
              return _this.__doLayout();
            };
          })(this)
        });
      }
    }
    this.__tabs = [];
    ref = this._tabs;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      tab = ref[idx];
      if (!tab) {
        continue;
      }
      if (tab instanceof Tab) {
        this.addTab(tab);
      } else if (CUI.isPlainObject(tab)) {
        this.addTab(new Tab(tab));
      } else {
        assert(false, "new " + this.__cls, "opts.tabs[" + idx + "] must be PlainObject or Tab but is " + (getObjectClass(tab)), {
          opts: this.opts
        });
      }
    }
    this.__tabs[this._active_idx || 0].activate();
    DOM.waitForDOMInsert({
      node: this.getLayout()
    }).done((function(_this) {
      return function() {
        if (_this.isDestroyed()) {
          return;
        }
        Events.listen({
          node: _this.getLayout(),
          type: "viewport-resize",
          call: function() {
            _this.__checkOverflowButton();
            return _this.__setActiveMarker();
          }
        });
        assert(DOM.isInDOM(_this.getLayout().DOM[0]), "Tabs getting DOM insert event without being in DOM.");
        _this.__checkOverflowButton();
        _this.__setActiveMarker();
        if (!CUI.__ng__) {
          return _this.__doLayout();
        }
      };
    })(this));
    this.addClass("cui-tabs");
    this.__max_width = -1;
    this.__max_height = -1;
    return this;
  };

  Tabs.prototype.setFooterRight = function(content) {
    return this.replace(content, "footer_right");
  };

  Tabs.prototype.setFooterLeft = function(content) {
    return this.replace(content, "footer_left");
  };

  Tabs.prototype.__doLayout = function() {
    if (this.__maximize_horizontal && this.__maximize_vertical) {
      return;
    }
    if (this.__measureAndSetBodyWidth()) {
      Events.trigger({
        type: "content-resize",
        node: this.DOM.parentNode
      });
    }
    return this;
  };

  Tabs.prototype.addTab = function(tab) {
    assert(tab instanceof Tab, this.__cls + ".addTab", "Tab must be instance of Tab but is " + (getObjectClass(tab)), {
      tab: tab
    });
    if (!this.hasTab(tab)) {
      this.__tabs.push(tab);
      Events.listen({
        node: tab,
        type: "tab_activate",
        call: (function(_this) {
          return function() {
            if (_this.__overflowBtn.isShown()) {
              DOM.scrollIntoView(tab.getButton().DOM[0]);
            }
            if (CUI.__ng__) {
              if (!_this._maximize_vertical) {
                DOM.setStyle(_this.__tabs[0].DOM[0], {
                  marginLeft: -100 * idxInArray(tab, _this.__tabs) + "%"
                });
              }
            }
            _this.__active_tab = tab;
            _this.__setActiveMarker();
            return DOM.setAttribute(_this.DOM[0], "active-tab-idx", idxInArray(tab, _this.__tabs));
          };
        })(this)
      });
      Events.listen({
        node: tab,
        type: "tab_deactivate",
        call: (function(_this) {
          return function() {
            _this.__active_tab = null;
            return DOM.setAttribute(_this.DOM[0], "active-tab-idx", "");
          };
        })(this)
      });
      Events.listen({
        node: tab,
        type: "tab_destroy",
        call: (function(_this) {
          return function() {
            var idx, ref;
            idx = _this.__tabs.indexOf(tab);
            removeFromArray(tab, _this.__tabs);
            idx--;
            return (ref = _this.__tabs[idx]) != null ? ref.activate() : void 0;
          };
        })(this)
      });
    }
    tab.hide();
    tab.initButton(this);
    this.__buttonbar.addButton(tab.getButton());
    this.__tabs_bodies.append(tab);
    return tab;
  };

  Tabs.prototype.__measureAndSetBodyWidth = function() {
    var dim, i, j, k, l, len, len1, len2, len3, max_height, max_width, parent, ref, ref1, ref2, ref3, scrollSaveParent, size_has_changed, tab;
    ref = this.DOM.parents();
    for (i = 0, len = ref.length; i < len; i++) {
      parent = ref[i];
      if (parent.scrollTop || parent.scrollLeft) {
        scrollSaveParent = {
          node: parent,
          top: parent.scrollTop,
          left: parent.scrollLeft
        };
        break;
      }
    }
    ref1 = this.__tabs;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      tab = ref1[j];
      tab.getBody().css({
        "min-width": "",
        height: ""
      });
    }
    this.__tabs_bodies.DOM.css({
      "min-width": "",
      height: ""
    });
    max_width = -1;
    max_height = -1;
    ref2 = this.__tabs;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      tab = ref2[k];
      dim = {
        width: tab.getBody().outerWidth(true),
        height: tab.getBody().outerHeight(true)
      };
      if (dim.width > max_width) {
        max_width = dim.width;
      }
      if (dim.height > max_height) {
        max_height = dim.height;
      }
    }
    this.__tabs_bodies.DOM.css({
      "min-width": max_width,
      height: max_height
    });
    ref3 = this.__tabs;
    for (l = 0, len3 = ref3.length; l < len3; l++) {
      tab = ref3[l];
      tab.getBody().css({
        "min-width": max_width,
        height: max_height
      });
    }
    if (this.max_width !== this.__max_width || this.max_height !== this.__max_height) {
      this.__max_width = max_width;
      this.__max_height = max_height;
      size_has_changed = true;
    } else {
      size_has_changed = false;
    }
    if (scrollSaveParent) {
      scrollSaveParent.node.scrollTop = scrollSaveParent.top;
      scrollSaveParent.node.scrollLeft = scrollSaveParent.left;
    }
    return size_has_changed;
  };

  Tabs.prototype.hasTab = function(tab_or_idx_or_name) {
    return this.getTab(tab_or_idx_or_name);
  };

  Tabs.prototype.getTab = function(tab_or_idx_or_name) {
    var found_tab, i, len, ref, tab;
    found_tab = null;
    if (isString(tab_or_idx_or_name)) {
      ref = this.__tabs;
      for (i = 0, len = ref.length; i < len; i++) {
        tab = ref[i];
        if (tab._name === tab_or_idx_or_name) {
          found_tab = tab;
          break;
        }
      }
    } else if (tab_or_idx_or_name instanceof Tab) {
      if (this.__tabs.indexOf(tab_or_idx_or_name) > -1) {
        found_tab = tab_or_idx_or_name;
      }
    } else {
      found_tab = this.__tabs[tab_or_idx_or_name];
    }
    return found_tab;
  };

  Tabs.prototype.getActiveTab = function() {
    return this.__active_tab;
  };

  Tabs.prototype.activate = function(tab_or_idx_or_name) {
    var tab;
    tab = this.getTab(tab_or_idx_or_name);
    tab.activate();
    return this;
  };

  return Tabs;

})(CUI.SimplePane);

Tabs = CUI.Tabs;
// Generated by CoffeeScript 1.9.3
var Modal,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Modal = (function(superClass) {
  extend(Modal, superClass);

  function Modal(opts) {
    this.opts = opts != null ? opts : {};
    Modal.__super__.constructor.call(this, this.opts);
    this.__defer_auto_size = false;
    this.__addHeaderButton("fill_screen_button", Pane.getToggleFillScreenButton());
    Events.listen({
      type: "end-fill-screen",
      node: this.getPane().DOM,
      call: (function(_this) {
        return function(ev) {
          if (_this.__defer_auto_size) {
            _this.autoSize(false);
            _this.__defer_auto_size = false;
          }
        };
      })(this)
    });
    this.__addHeaderButton("cancel", {
      "class": "ez5-modal-close-button",
      icon: "close",
      appearance: "flat",
      onClick: (function(_this) {
        return function(ev) {
          return _this.doCancel(ev);
        };
      })(this)
    });
  }

  Modal.prototype.initOpts = function() {
    Modal.__super__.initOpts.call(this);
    this.mergeOpt("backdrop", {
      "default": {
        policy: "modal",
        add_bounce_class: true,
        content: null
      }
    });
    this.addOpts({
      cancel: {
        check: Boolean
      },
      cancel_action: {
        "default": "destroy",
        check: ["destroy", "hide"]
      },
      onCancel: {
        check: Function
      },
      fill_screen_button: {
        check: Boolean
      },
      onToggleFillScreen: {
        check: Function
      }
    });
    return this.mergeOpt("placement", {
      "default": "c"
    });
  };

  Modal.prototype.__addHeaderButton = function(pname, _btn) {
    var btn;
    if (!this["_" + pname]) {
      return;
    }
    if (CUI.isPlainObject(_btn)) {
      btn = new Button(_btn);
    } else {
      btn = _btn;
    }
    assert(btn instanceof Button, "Modal.__addHeaderButton", "Button needs to be instance of Button", {
      btn: btn
    });
    assert(this.__pane instanceof SimplePane, "new " + this.__cls, "opts." + pname + " can only be used if opts.pane is instance of SimplePane.", {
      pane: this.__pane,
      opts: this.opts
    });
    this.append(btn, "header_right");
    return this;
  };

  Modal.prototype.__runOnAllButtons = function(func) {
    var btn, el, i, len, ref;
    ref = this.__layer.DOM.find(".cui-button");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      btn = DOM.data(el, "element");
      if (btn instanceof Button) {
        btn[func]();
      }
    }
  };

  Modal.prototype.disableAllButtons = function() {
    return this.__runOnAllButtons("disable");
  };

  Modal.prototype.enableAllButtons = function() {
    return this.__runOnAllButtons("enable");
  };

  Modal.prototype.isKeyboardCancellable = function(ev) {
    if (this._cancel) {
      return true;
    } else {
      return Modal.__super__.isKeyboardCancellable.call(this, ev);
    }
  };

  Modal.prototype.doCancel = function(ev) {
    var ret;
    if (!this._cancel) {
      Modal.__super__.doCancel.call(this, ev);
    } else {
      ret = typeof this._onCancel === "function" ? this._onCancel(ev, this) : void 0;
      if (isPromise(ret)) {
        ret.done((function(_this) {
          return function(value) {
            return _this[_this._cancel_action](ev, value);
          };
        })(this));
      } else if (ret !== false) {
        this[this._cancel_action](ev, ret);
      }
    }
  };

  Modal.prototype.empty = function(key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().empty(key);
    this.position();
    return this;
  };

  Modal.prototype.append = function(content, key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().append(content, key);
    this.position();
    return this;
  };

  Modal.prototype.replace = function(content, key) {
    if (key == null) {
      key = "center";
    }
    this.getPane().replace(content, key);
    this.position();
    return this;
  };

  Modal.prototype.hide = function(ev) {
    this.getPane().endFillScreen(false);
    return Modal.__super__.hide.call(this, ev);
  };

  Modal.prototype.autoSize = function(immediate) {
    if (immediate == null) {
      immediate = false;
    }
    if (this.getPane().getFillScreenState()) {
      return this.__defer_auto_size = true;
    } else {
      return Modal.__super__.autoSize.call(this, immediate);
    }
  };

  return Modal;

})(CUI.LayerPane);

Modal = CUI.Modal;
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ConfirmationDialog = (function(superClass) {
  extend(ConfirmationDialog, superClass);

  function ConfirmationDialog(opts) {
    this.opts = opts;
    ConfirmationDialog.__super__.constructor.call(this, this.opts);
    this.__layer_root.addClass("cui-confirmation-dialog");
    this.init();
  }

  ConfirmationDialog.prototype.initOpts = function() {
    ConfirmationDialog.__super__.initOpts.call(this);
    this.addOpts({
      title: {
        "default": "",
        check: String
      },
      text: {
        check: String
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      html: {
        check: String
      },
      content: {
        check: function(v) {
          return isContent(v) || (v != null ? v.DOM : void 0);
        }
      },
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      buttons: {
        check: function(v) {
          return (CUI.isArray(v) && v.length > 0) || CUI.isFunction(v);
        }
      },
      footer_left: {},
      header_right: {}
    });
    return this.removeOpt("pane");
  };

  ConfirmationDialog.prototype.readOpts = function() {
    ConfirmationDialog.__super__.readOpts.call(this);
    return this._pane = {};
  };

  ConfirmationDialog.prototype.init = function() {
    var c, content, key, l, pane, ref;
    assert(xor(this._html, xor(this._content, this._text)), this.__cls + ".readOpts", "only opts.content, opts.text, or opts.html can be set", {
      opts: this.opts
    });
    if (!isEmpty(this._text)) {
      c = new MultilineLabel({
        markdown: this._markdown,
        text: this._text
      });
    } else if (!isEmpty(this._html)) {
      c = new MultilineLabel({
        content: this._html
      });
    } else {
      c = this._content;
    }
    if (!isEmpty(this._title) || !isNull(this._icon)) {
      l = new Label({
        text: this._title,
        icon: this._icon
      });
    }
    pane = this.getPane();
    ref = {
      header_left: l,
      header_right: this._header_right,
      content: c,
      footer_right: this._buttons,
      footer_left: this._footer_left
    };
    for (key in ref) {
      content = ref[key];
      pane.append(content, key);
    }
  };

  ConfirmationDialog.prototype.setText = function(text, markdown) {
    var c;
    if (markdown == null) {
      markdown = this._markdown;
    }
    c = new MultilineLabel({
      markdown: markdown,
      text: text
    });
    return this.getPane().replace(c, "content");
  };

  ConfirmationDialog.prototype.getButtons = function() {
    var buttons, el, els, i, key, len, pane, ref;
    ref = this.getPane().getPaneAndKey("footer_right"), pane = ref[0], key = ref[1];
    els = DOM.findElements(pane[key]()[0], ".cui-button");
    buttons = [];
    for (i = 0, len = els.length; i < len; i++) {
      el = els[i];
      buttons.push(DOM.data(el, "element"));
    }
    return buttons;
  };

  return ConfirmationDialog;

})(CUI.Modal);
// Generated by CoffeeScript 1.9.3
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ConfirmationChoice = (function(superClass) {
  extend(ConfirmationChoice, superClass);

  function ConfirmationChoice(opts) {
    this.opts = opts;
    this.__getResolveValue = bind(this.__getResolveValue, this);
    ConfirmationChoice.__super__.constructor.call(this, this.opts);
    this.__layer_root.addClass("cui-confirmation-choice");
  }

  ConfirmationChoice.defaults = {
    ok: "Ok",
    cancel: "Cancel",
    alert_title: "...",
    confirm_title: "Confirmation",
    prompt_title: "???"
  };

  ConfirmationChoice.prototype.initOpts = function() {
    ConfirmationChoice.__super__.initOpts.call(this);
    this.removeOpt("buttons");
    this.removeOpt("header_right");
    this.removeOpt("cancel_action");
    return this.addOpts({
      onChoice: {
        check: Function
      },
      choices: {
        mandatory: true,
        "default": [],
        check: function(v) {
          var choice, i, len;
          if (!CUI.isArray(v)) {
            return false;
          }
          for (i = 0, len = v.length; i < len; i++) {
            choice = v[i];
            CUI.Element.readOpts(choice, "new ConfirmationChoice", this.choiceOpts);
          }
          return true;
        }
      }
    });
  };

  ConfirmationChoice.prototype.choiceOpts = {
    text: {
      mandatory: true,
      check: String
    },
    onClick: {
      check: Function
    },
    icon: {
      check: Icon
    },
    cancel: {
      "default": false,
      check: Boolean
    },
    primary: {
      mandatory: true,
      "default": false,
      check: Boolean
    }
  };

  ConfirmationChoice.prototype.readOpts = function() {
    ConfirmationChoice.__super__.readOpts.call(this);
    return this._cancel_action = "cancel";
  };

  ConfirmationChoice.prototype.init = function() {
    var btn_opts, choice, i, key, len, ref;
    this._buttons = [];
    ref = this._choices;
    for (i = 0, len = ref.length; i < len; i++) {
      choice = ref[i];
      btn_opts = {
        left: true,
        value: choice,
        onClick: (function(_this) {
          return function(ev, btn) {
            _this.__choice = btn.getValue();
            CUI.chainedCall(function() {
              var ref1, ret;
              return ret = (ref1 = _this.__choice.onClick) != null ? ref1.call(_this, ev, btn) : void 0;
            }, function() {
              var ref1;
              if (_this.__choice.cancel) {
                _this.doCancel(ev, true);
                return false;
              } else {
                return (ref1 = _this._onChoice) != null ? ref1.call(_this, ev, _this.__choice) : void 0;
              }
            }).done(function(ret1, ret2) {
              if (ev.isImmediatePropagationStopped() || ret1 === false || ret2 === false) {
                return;
              }
              _this.destroy();
              return _this.__deferred.resolve(_this.__getResolveValue(), btn);
            });
          };
        })(this)
      };
      for (key in this.choiceOpts) {
        if (key !== "onClick" && key !== "cancel") {
          btn_opts[key] = choice[key];
        }
      }
      this._buttons.push(btn_opts);
    }
    ConfirmationChoice.__super__.init.call(this);
  };

  ConfirmationChoice.prototype.__getResolveValue = function() {
    return this.__choice;
  };

  ConfirmationChoice.prototype.show = function() {
    return assert(false, "ConfirmationChoice.show", "Use .open to open the ConfirmationChoice");
  };

  ConfirmationChoice.prototype.cancel = function(ev, ret) {
    this.hide(ev);
    return this.__deferred.reject(this.__choice, ret);
  };

  ConfirmationChoice.prototype.open = function() {
    this.__deferred = new CUI.Deferred();
    CUI.ConfirmationDialog.prototype.show.call(this);
    return this.__deferred.promise();
  };

  return ConfirmationChoice;

})(CUI.ConfirmationDialog);

CUI.defaults["class"].ConfirmationChoice = CUI.ConfirmationChoice;
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Alert = (function(superClass) {
  extend(Alert, superClass);

  function Alert() {
    return Alert.__super__.constructor.apply(this, arguments);
  }

  Alert.prototype.initOpts = function() {
    Alert.__super__.initOpts.call(this);
    this.removeOpt("choices");
    this.mergeOpt("text", {
      mandatory: true
    });
    return this.addOpts({
      button_text_ok: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.ok,
        check: String
      }
    });
  };

  Alert.prototype.readOpts = function() {
    if (isEmpty(this.opts.title)) {
      this.opts.title = CUI.defaults["class"].ConfirmationChoice.defaults.alert_title;
    }
    Alert.__super__.readOpts.call(this);
    return this._choices = [
      {
        text: this._button_text_ok
      }
    ];
  };

  return Alert;

})(CUI.ConfirmationChoice);

CUI.alert = function(opts) {
  if (opts == null) {
    opts = {
      text: "CUI.alert"
    };
  }
  return new CUI.Alert(opts).open();
};

CUI.problem = function(opts) {
  if (opts == null) {
    opts = {
      text: "CUI.problem"
    };
  }
  if (!opts["class"]) {
    opts["class"] = "";
  }
  opts["class"] += " cui-alert-problem";
  return CUI.alert(opts);
};
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Toaster = (function(superClass) {
  extend(Toaster, superClass);

  function Toaster() {
    return Toaster.__super__.constructor.apply(this, arguments);
  }

  Toaster.prototype.initOpts = function() {
    Toaster.__super__.initOpts.call(this);
    this.removeOpt("choices");
    return this.removeOpt("backdrop");
  };

  Toaster.prototype.readOpts = function() {
    Toaster.__super__.readOpts.call(this);
    this._backdrop = false;
    return this._choices = [];
  };

  Toaster.prototype.open = function() {
    Toaster.__super__.open.call(this);
    if (this._show_ms > 0) {
      CUI.setTimeout({
        ms: this._show_ms,
        call: (function(_this) {
          return function() {
            _this.hide();
            return _this.__deferred.resolve();
          };
        })(this)
      });
    }
    return this.__deferred.promise();
  };

  return Toaster;

})(CUI.ConfirmationChoice);

CUI.toaster = function(opts) {
  var toaster;
  if (opts == null) {
    opts = {
      text: "CUI.toaster"
    };
  }
  toaster = new CUI.Toaster(opts);
  toaster.open();
  return toaster;
};
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Confirm = (function(superClass) {
  extend(Confirm, superClass);

  function Confirm() {
    return Confirm.__super__.constructor.apply(this, arguments);
  }

  Confirm.prototype.initOpts = function() {
    Confirm.__super__.initOpts.call(this);
    this.removeOpt("choices");
    this.mergeOpt("text", {
      mandatory: true
    });
    return this.addOpts({
      button_text_ok: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.ok,
        check: String
      },
      button_text_cancel: {
        mandatory: true,
        "default": CUI.defaults["class"].ConfirmationChoice.defaults.cancel,
        check: String
      },
      button_primary: {
        mandatory: true,
        "default": "ok",
        check: ["ok", "cancel"]
      }
    });
  };

  Confirm.prototype.readOpts = function() {
    if (isEmpty(this.opts.title)) {
      this.opts.title = CUI.defaults["class"].ConfirmationChoice.defaults.confirm_title;
    }
    if (!this.opts.hasOwnProperty("cancel")) {
      this.opts.cancel = true;
    }
    Confirm.__super__.readOpts.call(this);
    return this._choices = [
      {
        text: this._button_text_cancel,
        cancel: true,
        primary: this._button_primary === "cancel"
      }, {
        text: this._button_text_ok,
        primary: this._button_primary === "ok"
      }
    ];
  };

  return Confirm;

})(CUI.ConfirmationChoice);

CUI.confirm = function(opts) {
  return new CUI.Confirm(opts).open();
};
// Generated by CoffeeScript 1.9.3
var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Prompt = (function(superClass) {
  extend(Prompt, superClass);

  function Prompt() {
    this.__checkOkBtn = bind(this.__checkOkBtn, this);
    return Prompt.__super__.constructor.apply(this, arguments);
  }

  Prompt.prototype.initOpts = function() {
    Prompt.__super__.initOpts.call(this);
    this.removeOpt("choices");
    return this.addOpts({
      "default": {
        "default": "",
        check: String
      }
    });
  };

  Prompt.prototype.readOpts = function() {
    var text;
    if (isEmpty(this.opts.title)) {
      this.opts.title = CUI.defaults["class"].ConfirmationChoice.defaults.prompt_title;
    }
    if (!this.opts.hasOwnProperty("cancel")) {
      this.opts.cancel = true;
    }
    Prompt.__super__.readOpts.call(this);
    text = this._text;
    delete this._text;
    this.__data = {
      input: this._default + ""
    };
    this._content = new Form({
      fields: [
        {
          type: Output,
          multiline: true,
          text: text
        }, {
          type: Input,
          name: "input",
          data: this.__data,
          onKeyup: (function(_this) {
            return function(inp, ev) {
              if (ev.keyCode() === 13) {
                return _this.getButtons()[1].onClickAction(ev);
              }
            };
          })(this),
          onDataChanged: (function(_this) {
            return function() {
              return _this.__checkOkBtn();
            };
          })(this)
        }
      ]
    }).start();
    return this._choices = [
      {
        text: this._button_text_cancel,
        cancel: true,
        primary: this._button_primary === "cancel"
      }, {
        text: this._button_text_ok,
        primary: this._button_primary === "ok"
      }
    ];
  };

  Prompt.prototype.open = function() {
    var dfr;
    this.__checkOkBtn();
    dfr = new CUI.Deferred();
    Prompt.__super__.open.call(this).done((function(_this) {
      return function(choice) {
        return dfr.resolve(_this.__data.input);
      };
    })(this)).fail(dfr.reject);
    return dfr.promise();
  };

  Prompt.prototype.__checkOkBtn = function() {
    var buttons;
    buttons = this.getButtons();
    if (this.__data.input.trim().length > 0) {
      return buttons[1].enable();
    } else {
      return buttons[1].disable();
    }
  };

  Prompt.prototype.getForm = function() {};

  return Prompt;

})(CUI.Confirm);

CUI.prompt = function(opts) {
  return new CUI.Prompt(opts).open();
};
// Generated by CoffeeScript 1.9.3
var Popover,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Popover = (function(superClass) {
  extend(Popover, superClass);

  function Popover() {
    return Popover.__super__.constructor.apply(this, arguments);
  }

  Popover.prototype.initOpts = function() {
    Popover.__super__.initOpts.call(this);
    this.mergeOpt("placement", {
      "default": null
    });
    return this.mergeOpt("pointer", {
      "default": "arrow"
    });
  };

  Popover.prototype.readOpts = function() {
    var ref;
    Popover.__super__.readOpts.call(this);
    if (!((ref = this.opts.backdrop) != null ? ref.policy : void 0)) {
      return this._backdrop.policy = "click-thru";
    }
  };

  return Popover;

})(Modal);
// Generated by CoffeeScript 1.9.3
var Tooltip,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Tooltip = (function(superClass) {
  extend(Tooltip, superClass);

  function Tooltip(opts) {
    this.opts = opts != null ? opts : {};
    Tooltip.__super__.constructor.call(this, this.opts);
    assert(xor(this._text, this._content), "new " + this.__cls, "One of opts.text or opts.content must be set.", {
      opts: this.opts
    });
    if (!CUI.isFunction(this._text) && !CUI.isFunction(this._content)) {
      this.__static = true;
      this.fillContent();
    } else {
      this.__static = false;
    }
    this.__dummyInst = new CUI.Dummy();
    if (this._on_hover) {
      assert(this.__element, "Element not set in Tooltip.");
      Events.listen({
        type: "mouseenter",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (window.globalDrag) {
              return;
            }
            if (_this._on_hover === true || _this._on_hover(_this)) {
              _this.showTimeout(null, ev);
            }
          };
        })(this)
      });
      Events.listen({
        type: "mouseleave",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (window.globalDrag) {
              _this.hide(ev);
            } else {
              _this.hideTimeout(null, ev);
            }
          };
        })(this)
      });
      this.__element.addClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-hover");
      return;
    }
    if (this._on_click) {
      this.__element.addClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-click");
      Events.listen({
        type: "click",
        instance: this.__dummyInst,
        node: this.__element,
        call: (function(_this) {
          return function(ev) {
            if (ev.hasModifierKey()) {
              return;
            }
            _this.show();
          };
        })(this)
      });
    }
  }

  Tooltip.prototype.initOpts = function() {
    Tooltip.__super__.initOpts.call(this);
    this.addOpts({
      text: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v);
        }
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      content: {
        check: function(v) {
          return isString(v) || CUI.isFunction(v) || isElement(v) || CUI.isArray(v) || isElement(v != null ? v.DOM : void 0);
        }
      },
      on_click: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      on_hover: {
        check: function(v) {
          return isBoolean(v) || CUI.isFunction(v);
        }
      }
    });
  };

  Tooltip.prototype.readOpts = function() {
    if (!this.opts.hasOwnProperty("on_hover")) {
      this.opts.on_hover = !this.opts.on_click;
    }
    if (this.opts.on_click) {
      if (!this.opts.backdrop) {
        this.opts.backdrop = {};
      }
      if (!this.opts.backdrop.policy) {
        this.opts.backdrop.policy = "click";
      }
    }
    if (isUndef(this.opts.backdrop)) {
      this.opts.backdrop = false;
    }
    this.opts.pointer = "arrow";
    this.opts.check_for_element = true;
    this.opts.placement = this.opts.placement || "n";
    Tooltip.__super__.readOpts.call(this);
    assert(!(this._on_click && this._on_hover), "new Tooltip", "opts.on_click and opts.on_hover cannot be used together.", {
      opts: this.opts
    });
    return this;
  };

  Tooltip.current = null;

  Tooltip.prototype.focusOnHide = function(ev) {};

  Tooltip.prototype.focusOnShow = function(ev) {};

  Tooltip.prototype.showTimeout = function(ms, ev) {
    if (ms == null) {
      ms = this._show_ms;
    }
    if (CUI.Tooltip.current) {
      if (CUI.Tooltip.current !== this) {
        CUI.Tooltip.current.hide(ev);
      }
      this.show(ev);
      return CUI.resolvedPromise();
    } else {
      CUI.Tooltip.current = this;
      return Tooltip.__super__.showTimeout.call(this, ms, ev);
    }
  };

  Tooltip.prototype.hideTimeout = function(ms, ev) {
    if (ms == null) {
      ms = this._show_ms;
    }
    CUI.Tooltip.current = null;
    return Tooltip.__super__.hideTimeout.call(this, ev);
  };

  Tooltip.prototype.hide = function(ev) {
    CUI.Tooltip.current = null;
    return Tooltip.__super__.hide.call(this, ev);
  };

  Tooltip.prototype.show = function(ev) {
    CUI.Tooltip.current = this;
    if (this.__static) {
      Tooltip.__super__.show.call(this, ev);
    } else {
      this.fillContent().done((function(_this) {
        return function() {
          return Tooltip.__super__.show.call(_this, ev);
        };
      })(this));
    }
    return this;
  };

  Tooltip.prototype.fillContent = function() {
    var dfr, fill_content, fill_text, ret;
    dfr = new CUI.Deferred();
    dfr.fail((function(_this) {
      return function() {
        if (!_this.__pane.isDestroyed()) {
          return _this.__pane.empty("center");
        }
      };
    })(this));
    fill_text = (function(_this) {
      return function(text) {
        if (isEmpty(text)) {
          return dfr.reject();
        }
        return fill_content(new Label({
          markdown: _this._markdown,
          text: text,
          multiline: true
        }));
      };
    })(this);
    fill_content = (function(_this) {
      return function(content) {
        if (!content || _this.__pane.isDestroyed()) {
          return dfr.reject();
        }
        _this.__pane.replace(content, "center");
        return dfr.resolve();
      };
    })(this);
    if (CUI.isFunction(this._text)) {
      ret = this._text.call(this, this);
      if (isPromise(ret)) {
        ret.done(function(text) {
          return fill_text(text);
        });
        ret.fail(function() {
          return dfr.reject();
        });
      } else {
        fill_text(ret);
      }
    } else if (CUI.isFunction(this._content)) {
      ret = this._content.call(this, this);
      if (isPromise(ret)) {
        ret.done(function(text) {
          return fill_content(text);
        });
        ret.fail(function(xhr) {
          return dfr.reject(xhr);
        });
      } else {
        fill_content(ret);
      }
    } else if (!isEmpty(this._text)) {
      fill_text(this._text);
    } else {
      fill_content(this._content);
    }
    return dfr.promise();
  };

  Tooltip.prototype.preventOverflow = function() {
    Tooltip.__super__.preventOverflow.call(this);
    return this.DOM.width(this.__layer_dim._css_width);
  };

  Tooltip.prototype.resetLayer = function() {
    Tooltip.__super__.resetLayer.call(this);
    return this.DOM.css("max-width", this.__viewport.width / 2);
  };

  Tooltip.prototype.destroy = function() {
    Events.ignore({
      instance: this.__dummyInst
    });
    Tooltip.__super__.destroy.call(this);
    return this.__element.removeClass("cui-dom-element-has-tooltip cui-dom-element-has-tooltip-on-hover cui-dom-element-has-tooltip-on-click");
  };

  return Tooltip;

})(CUI.LayerPane);

Tooltip = CUI.Tooltip;
// Generated by CoffeeScript 1.9.3
var ListView,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.ListView = (function(superClass) {
  extend(ListView, superClass);

  function ListView(opts1) {
    var col_i, j, ref;
    this.opts = opts1 != null ? opts1 : {};
    ListView.__super__.constructor.call(this, this.opts);
    this.rowsCount = 0;
    this.colsCount = this.__cols.length;
    this.listViewCounter = ListView.counter++;
    this.__manualColWidths = [];
    this.__colspanRows = {};
    this.colsOrder = [];
    for (col_i = j = 0, ref = this.colsCount; 0 <= ref ? j < ref : j > ref; col_i = 0 <= ref ? ++j : --j) {
      this.colsOrder.push(col_i);
    }
    this.rowsOrder = [];
    this.__maxRowIdx = -1;
    this.__resetCellDims();
    this.__cells = [];
    this.__rows = [];
    this.__lvClass = "cui-list-view-grid-" + this.listViewCounter;
    this.__deferredRows = [];
    this.__isInDOM = false;
    if (CUI.__ng__) {
      this._autoLayout = 2;
    }
    switch (this._autoLayout) {
      case true:
        this.addClass("cui-list-view cui-padding-reset cui-list-view-div-layout");
        break;
      case 2:
        this.addClass("cui-list-view");
        break;
      default:
        this.addClass("cui-list-view cui-padding-reset cui-list-view-table-layout");
    }
  }

  ListView.prototype.initOpts = function() {
    ListView.__super__.initOpts.call(this);
    return this.addOpts({
      colClasses: {
        check: "Array"
      },
      cols: {
        mandatory: true,
        check: "Array"
      },
      fixedCols: {
        "default": 0,
        check: "Integer"
      },
      fixedRows: {
        "default": 0,
        check: "Integer"
      },
      rowMove: {
        "default": false,
        check: Boolean
      },
      rowMoveFixedRows: {
        "default": 0,
        check: "Integer"
      },
      rowMovePlaceholder: {
        "default": false,
        check: Boolean
      },
      colResize: {
        check: Boolean
      },
      selectableRows: {
        "default": false,
        check: function(v) {
          return v === false || v === true || v === "multiple";
        }
      },
      onSelect: {
        check: Function
      },
      onDeselect: {
        check: Function
      },
      onRowMove: {
        check: Function
      },
      onScroll: {
        check: Function
      },
      tools: {
        check: "Array"
      },
      header: {
        deprecated: true
      },
      footer: {
        deprecated: true
      },
      autoLayout: {
        "default": true,
        check: function(v) {
          if (v === true || v === false || v === 2) {
            return true;
          } else {
            return false;
          }
        }
      },
      setOpacity: {
        "default": true,
        check: Boolean
      }
    });
  };

  ListView.prototype.readOpts = function() {
    var col, col_i, j, len, ref;
    if (this.opts.header) {
      this.opts.header_center = this.opts.header;
    }
    if (this.opts.footer) {
      this.opts.footer_left = this.opts.footer;
    }
    ListView.__super__.readOpts.call(this);
    this.tools = [];
    this.fixedColsCount = this._fixedCols;
    this.fixedRowsCount = this._fixedRows;
    this.__cols = this._cols.slice(0);
    if (this._colClasses) {
      this.__colClasses = this._colClasses.slice(0);
    }
    if (this._rowMove) {
      assert(!this._rowMovePlaceholder, "new ListView", "opts.rowMove cannot be used with opts.rowMovePlaceholder", {
        opts: this.opts
      });
      this.tools.push(new ListViewRowMoveTool());
    }
    if (this._rowMove || this._rowMovePlaceholder) {
      this.__cols.splice(0, 0, "fixed");
      if (!this.__colClasses) {
        this.__colClasses = [];
      }
      this.__colClasses.splice(0, 0, "cui-list-view-row-move-handle-column");
    }
    assert(this.fixedColsCount < this.__cols.length, "new ListView", "opts.fixedCols must be less than column count.", {
      opts: this.opts
    });
    if (this._colResize || (this.fixedRowsCount > 0 && this._colResize !== false)) {
      assert(this.fixedRowsCount > 0, "new ListView", "Cannot enable col resize with no fixed rows.", {
        opts: this.opts
      });
      this.tools.push(new ListViewColResizeTool());
    }
    this.__maxCols = [];
    ref = this.__cols;
    for (col_i = j = 0, len = ref.length; j < len; col_i = ++j) {
      col = ref[col_i];
      assert(col === "auto" || col === "maximize" || col === "fixed" || col === "manual", "new " + this.__cls, "Unkown type of col: \"" + col + "\". opts.cols can only contain \"auto\" and \"maximize\" elements.");
      if (col === "maximize") {
        assert(col_i >= this.fixedColsCount, "new ListView", "maximized columns can only be in the non-fixed side of the ListView.", {
          opts: this.opts
        });
        assert(this.__maximize_horizontal, "new ListView", "maximized columns need the ListView to be set to opts.maximize_horizontal == true", {
          opts: this.opts
        });
        this.__maxCols.push(col_i);
      }
    }
    return this;
  };

  ListView.prototype.destroy = function() {
    var ref, ref1;
    delete this.colsOrder;
    delete this.rowsOrder;
    delete this.__fillRowQ3;
    this.hideWaitBlock();
    this.__isInDOM = null;
    if ((ref = this.__cssElement) != null) {
      ref.remove();
    }
    this.__cssElement = null;
    if (this.__scheduleLayoutTimeout) {
      CUI.clearTimeout(this.__scheduleLayoutTimeout);
    }
    if ((ref1 = this.listViewTemplate) != null) {
      ref1.destroy();
    }
    this.__layoutIsStopped = false;
    ListView.__super__.destroy.call(this);
    return this;
  };

  ListView.prototype.getListViewClass = function() {
    return this.__lvClass;
  };

  ListView.prototype.getGrid = function() {
    return this.grid;
  };

  ListView.prototype.hasMovableRows = function() {
    return this._rowMove;
  };

  ListView.prototype.isInactive = function() {
    return !!this.__inactive;
  };

  ListView.prototype.setInactive = function(inactive, addClass) {
    var ref;
    if (addClass == null) {
      addClass = "inactive";
    }
    this.__inactive = !!inactive;
    if (this.grid) {
      if (this.__inactive) {
        this.grid.addClass(addClass);
        this.__inactiveWaitBlock = new WaitBlock({
          element: this.grid,
          inactive: true
        }).show();
      } else {
        if ((ref = this.__inactiveWaitBlock) != null) {
          ref.destroy();
        }
        this.__inactiveWaitBlock = null;
        this.grid.removeClass(addClass);
      }
    }
    return this;
  };

  ListView.prototype.render = function() {
    var add_quadrant, cls, col, html, j, on_scroll, outer, ref, selector;
    assert(!this.grid, "ListView.render", "ListView already rendered", {
      opts: this.opts
    });
    html = [];
    cls = ["cui-list-view-grid", this.__lvClass];
    if (this._fixedCols === 1 && (this._rowMove || this._rowMovePlaceholder)) {
      cls.push("cui-list-view-grid-fixed-col-has-only-row-move-handle");
    }
    if (this._rowMovePlaceholder) {
      cls.push("cui-list-view-has-row-move-placeholder");
    }
    if (this._rowMove) {
      cls.push("cui-list-view-has-row-move");
    }
    if (this.__maxCols.length > 0) {
      cls.push("cui-list-view-grid-has-maximized-columns");
    }
    if (this.fixedColsCount > 0) {
      cls.push("cui-list-view-grid-has-fixed-cols");
    }
    if (this.fixedRowsCount > 0) {
      cls.push("cui-list-view-grid-has-fixed-rows");
    }
    html.push("<div class=\"");
    html.push(cls.join(" "));
    html.push("\">");
    switch (this._autoLayout) {
      case false:
      case 2:
        html.push("<style></style>");
    }
    add_quadrant = (function(_this) {
      return function(qi) {
        var col_i, ft, j, ref, ref1;
        html.push("<div cui-lv-quadrant=\"" + qi + "\" class=\"cui-list-view-grid-quadrant cui-lv-tbody cui-list-view-grid-quadrant-" + qi + "\">");
        if (_this._autoLayout === false) {
          html.push("<table class=\"cui-list-view-grid-quadrant-table\"><tbody></tbody></table>");
        }
        if (qi === 2 || qi === 3) {
          switch (_this._autoLayout) {
            case 2:
              html.push("<div class=\"cui-lv-tr-fill-outer\"><div class=\"cui-lv-tr\">");
              break;
            default:
              html.push("<div class=\"cui-list-view-grid-fills cui-list-view-grid-fills-" + qi + " cui-list-view-grid-row\">");
          }
          ft = _this.__getColsFromAndTo(qi);
          for (col_i = j = ref = ft.from, ref1 = ft.to; j <= ref1; col_i = j += 1) {
            cls = _this.__getColClass(col_i);
            switch (_this._autoLayout) {
              case 2:
                html.push("<div class=\"" + cls + " cui-lv-td cui-lv-td-fill cui-list-view-grid-fill-col-" + col_i + "\"></div>");
                break;
              default:
                html.push("<div class=\"cui-list-view-grid-cell-fill " + cls + " cui-lv-td cui-lv-td-fill cui-list-view-grid-cell-col cui-list-view-grid-cell-col-" + col_i + " cui-list-view-grid-fill-col-" + col_i + "\"></div>");
            }
          }
          switch (_this._autoLayout) {
            case 2:
              html.push("</div></div>");
              break;
            default:
              html.push("</div>");
          }
        }
        html.push("</div>");
      };
    })(this);
    html.push("<div class=\"cui-list-view-grid-inner-top\">");
    add_quadrant(0);
    add_quadrant(1);
    html.push("</div>");
    html.push("<div class=\"cui-list-view-grid-inner-bottom\">");
    add_quadrant(2);
    add_quadrant(3);
    html.push("</div>");
    html.push("</div>");
    outer = this.center()[0];
    outer.innerHTML = html.join("");
    this.grid = $(outer.firstChild);
    this.quadrant = [CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-0")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-1")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-2")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-3")[0]];
    if (this._autoLayout) {
      this.quadrantRows = this.quadrant;
      if (this._autoLayout === 2) {
        this.styleElement = CUI.DOM.matchSelector(outer, "style")[0];
      }
    } else {
      this.quadrantRows = [CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-0 > table > tbody")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-1 > table > tbody")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-2 > table > tbody")[0], CUI.DOM.matchSelector(outer, ".cui-list-view-grid-quadrant-3 > table > tbody")[0]];
      this.styleElement = CUI.DOM.matchSelector(outer, "style")[0];
    }
    this.__fillRowQ3 = CUI.DOM.matchSelector(this.grid[0], ".cui-list-view-grid-fills-3")[0];
    this.__topQuadrants = $(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-inner-top")[0]);
    this.__bottomQuadrants = $(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-inner-bottom")[0]);
    this.__fillCells = [];
    for (col = j = 0, ref = this.colsCount - 1; j <= ref; col = j += 1) {
      this.__fillCells.push(CUI.DOM.matchSelector(outer, ".cui-list-view-grid-fill-col-" + col)[0]);
    }
    on_scroll = (function(_this) {
      return function() {
        _this.__syncScrolling();
        return typeof _this._onScroll === "function" ? _this._onScroll() : void 0;
      };
    })(this);
    Events.listen({
      node: $(this.quadrant[3]),
      type: "scroll",
      call: on_scroll
    });
    this.__currentScroll = {
      top: 0,
      left: 0
    };
    if (this._selectableRows) {
      if (this._autoLayout) {
        selector = "." + this.__lvClass + " > div > .cui-list-view-grid-quadrant > .cui-list-view-grid-row";
      } else {
        selector = "." + this.__lvClass + " > div > .cui-list-view-grid-quadrant > table > tbody > .cui-list-view-grid-row";
      }
      Events.listen({
        type: "click",
        node: this.DOM,
        selector: selector,
        call: (function(_this) {
          return function(ev) {
            var row;
            ev.stopPropagation();
            row = DOM.data(ev.getCurrentTarget(), "listViewRow");
            _this.selectRow(ev, row);
          };
        })(this)
      });
    }
    Events.listen({
      type: "wheel",
      node: $(this.quadrant[2]),
      call: (function(_this) {
        return function(ev) {
          ev.preventDefault();
          if (ev.wheelDeltaY() > 0) {
            _this.quadrant[3].scrollTop += 100;
          }
          if (ev.wheelDeltaY() < 0) {
            _this.quadrant[3].scrollTop -= 100;
          }
          return on_scroll();
        };
      })(this)
    });
    Events.listen({
      type: "viewport-resize",
      node: this.grid,
      call: (function(_this) {
        return function(ev, info) {
          if (!_this.__hasLayout) {
            return;
          }
          if (_this._autoLayout === 2) {
            _this.__doNextGenLayout({
              resetRows: !!(info.css_load || info.tab)
            });
          } else {
            _this.__scheduleLayout();
          }
        };
      })(this)
    });
    Events.listen({
      type: "content-resize",
      node: this.DOM,
      call: (function(_this) {
        return function(ev, info) {
          var cell, row;
          if (!_this._autoLayout) {
            return;
          }
          if (!_this.__isInDOM) {
            return;
          }
          cell = DOM.closest(ev.getNode(), ".cui-list-view-grid-cell");
          if (!cell) {
            return;
          }
          ev.stopPropagation();
          row = parseInt(cell.getAttribute("row"));
          col = parseInt(cell.getAttribute("col"));
          if (_this._autoLayout === 2) {
            if (DOM.getAttribute(cell.parentNode, "cui-lv-tr-unmeasured")) {
              return;
            }
            _this.__resetRowDim(row);
            _this.__doLayout();
            return;
          }
          if (!_this.__cellDims.hasOwnProperty(row)) {
            return;
          }
          _this.__resetRowDim(row);
          _this.__resetColWidth(col);
          if (_this.layoutIsStopped()) {
            return _this.__scheduleLayout();
          } else {
            return _this.__doLayout();
          }
        };
      })(this)
    });
    this.__registerTools();
    if (CUI.defaults.debug) {
      this.__addDebugControl();
    }
    if (this.isInactive()) {
      this.setInactive(true);
    }
    if (this.__showWaitBlock) {
      this.showWaitBlock();
    }
    this.appendDeferredRows();
    if (this._setOpacity && this._autoLayout !== 2) {
      this.grid[0].style.opacity = "0";
    }
    DOM.waitForDOMInsert({
      node: this.DOM
    }).done((function(_this) {
      return function() {
        _this.__isInDOM = true;
        if (_this.rowsCount === 0) {
          _this.showWaitBlock(true);
        }
        _this.__doLayout();
        if (_this._setOpacity && _this._autoLayout !== 2) {
          return _this.grid[0].style.opacity = "1";
        }
      };
    })(this));
    return this.DOM;
  };

  ListView.prototype.__getScrolling = function() {
    var dim;
    dim = {
      top: this.quadrant[3].scrollTop,
      left: this.quadrant[3].scrollLeft,
      height: this.quadrant[3].scrollHeight
    };
    return dim;
  };

  ListView.prototype.getScrollingContainer = function() {
    return this.quadrant[3];
  };

  ListView.prototype.__setScrolling = function(scroll) {
    this.quadrant[3].scrollTop = scroll.top;
    return this.quadrant[3].scrollLeft = scroll.left;
  };

  ListView.prototype.__syncScrolling = function() {
    this.__currentScroll = this.__getScrolling();
    if (this.fixedColsCount > 0) {
      this.quadrant[2].scrollTop = this.__currentScroll.top;
    }
    if (this.fixedRowsCount > 0) {
      this.quadrant[1].scrollLeft = this.__currentScroll.left;
    }
    if (this.__fillRowQ3) {
      this.__fillRowQ3.style.width = "";
      this.__fillRowQ3.style.width = this.__getValue(this.__fillRowQ3.scrollWidth);
    }
    return this;
  };

  ListView.prototype.__setMargins = function() {
    var height, width;
    width = this.quadrant[3].offsetWidth - this.quadrant[3].clientWidth;
    height = this.quadrant[3].offsetHeight - this.quadrant[3].clientHeight;
    this.quadrant[1].style.marginRight = this.__getValue(width);
    this.quadrant[2].style.marginBottom = this.__getValue(height);
    return this;
  };

  ListView.prototype.getSelectedRows = function() {
    var j, len, listViewRow, ref, row_i, sel_rows;
    sel_rows = [];
    ref = this.rowsOrder;
    for (j = 0, len = ref.length; j < len; j++) {
      row_i = ref[j];
      listViewRow = this.getListViewRow(row_i);
      if (listViewRow.isSelected()) {
        sel_rows.push(listViewRow);
      }
    }
    return sel_rows;
  };

  ListView.prototype.hasSelectableRows = function() {
    return this._selectableRows !== false;
  };

  ListView.prototype.selectRowById = function(row_id) {
    return this.selectRow(null, this.getListViewRow(row_id), true);
  };

  ListView.prototype.selectRowByDisplayIdx = function(row_display_idx) {
    return this.selectRowById(this.getRowIdx(row_display_idx));
  };

  ListView.prototype.selectRow = function(ev, row, no_deselect) {
    var _row, j, len, ref;
    if (no_deselect == null) {
      no_deselect = false;
    }
    assert(isNull(row) || row instanceof ListViewRow, this.__cls + ".setSelectedRow", "Parameter needs to be instance of ListViewRow.", {
      selectedRow: row
    });
    if (this._selectableRows === true) {
      ref = this.getSelectedRows();
      for (j = 0, len = ref.length; j < len; j++) {
        _row = ref[j];
        if (row === _row) {
          continue;
        }
        _row.deselect(ev);
      }
    }
    if (row.isSelected()) {
      if (!no_deselect) {
        return row.deselect(ev);
      } else {
        return row;
      }
    } else {
      return row.select(ev);
    }
  };

  ListView.prototype.getCellByTarget = function($target) {
    var cell;
    if ($target.is(".cui-list-view-grid-cell")) {
      cell = {
        col_i: parseInt($target.attr("col")),
        row_i: parseInt($target.attr("row"))
      };
      cell.display_col_i = this.getDisplayColIdx(cell.col_i);
      cell.display_row_i = this.getDisplayRowIdx(cell.row_i);
      return cell;
    } else {
      return null;
    }
  };

  ListView.prototype.toolCellSelector = function() {
    return "." + this.__lvClass + "-cell";
  };

  ListView.prototype.__registerTools = function() {
    var j, len, ref, t;
    if (this.tools.length === 0) {
      return;
    }
    Events.listen({
      node: this.grid,
      type: "mousemove",
      selector: this.toolCellSelector(),
      call: (function(_this) {
        return function(ev) {
          var info, j, len, ref, results, t;
          if (window.globalDrag) {
            return;
          }
          info = {
            $target: $(ev.getCurrentTarget())
          };
          info.cell = _this.getCellByTarget(info.$target);
          if (!info.cell) {
            return;
          }
          info.cell.pos = elementGetPosition(getCoordinatesFromEvent(ev), info.$target);
          ref = _this.tools;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            t = ref[j];
            t.mousemoveEvent(ev, info);
            if (ev.isImmediatePropagationStopped()) {
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this)
    });
    ref = this.tools;
    for (j = 0, len = ref.length; j < len; j++) {
      t = ref[j];
      t.registerListView(this);
    }
    return this;
  };

  ListView.prototype.getListViewRow = function(row_i) {
    return DOM.data(this.getRow(row_i)[0], "listViewRow");
  };

  ListView.prototype.getDisplayColIdx = function(col_i) {
    return this.colsOrder.indexOf(parseInt(col_i));
  };

  ListView.prototype.getDisplayRowIdx = function(row_i) {
    return this.rowsOrder.indexOf(parseInt(row_i));
  };

  ListView.prototype.getColIdx = function(display_col_i) {
    assert(CUI.isArray(this.colsOrder), "ListView[" + this.listViewCounter + "].getColIdx", "colsOrder Array is missing", {
      "this": this,
      display_col_i: display_col_i
    });
    return this.colsOrder[display_col_i];
  };

  ListView.prototype.getRowIdx = function(display_row_i) {
    return this.rowsOrder[display_row_i];
  };

  ListView.prototype.moveInOrderArray = function(from_i, to_i, array, after) {
    var display_from_i, display_to_i;
    display_from_i = array.indexOf(from_i);
    display_to_i = array.indexOf(to_i);
    moveInArray(display_from_i, display_to_i, array, after);
    return null;
  };

  ListView.prototype.moveRow = function(from_i, to_i, after, trigger_row_moved) {
    var display_from_i, display_to_i, func, idx, j, len, ref, row;
    if (after == null) {
      after = false;
    }
    if (trigger_row_moved == null) {
      trigger_row_moved = true;
    }
    assert(from_i >= this.fixedRowsCount && to_i >= this.fixedRowsCount, "ListView.moveRow", "from_i and to_i must not be in flexible area of the list view", {
      from_i: from_i,
      to_i: to_i,
      fixed_i: this.fixedRowsCount
    });
    if (after) {
      func = "after";
    } else {
      func = "before";
    }
    ref = this.getRow(from_i);
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      row = ref[idx];
      $(this.getRow(to_i)[idx])[func](row);
    }
    display_from_i = this.getDisplayRowIdx(from_i);
    display_to_i = this.getDisplayRowIdx(to_i);
    this.moveInOrderArray(from_i, to_i, this.rowsOrder, after);
    if (typeof this._onRowMove === "function") {
      this._onRowMove(display_from_i, display_to_i, after);
    }
    if (trigger_row_moved) {
      Events.trigger({
        type: "row_moved",
        node: this.grid,
        info: {
          from_i: from_i,
          to_i: to_i,
          display_from_i: display_from_i,
          display_to_i: display_to_i,
          after: after
        }
      });
    }
    return this;
  };

  ListView.prototype.rowAddClass = function(row_i, cls) {
    var j, len, ref, row;
    ref = this.getRow(row_i);
    for (j = 0, len = ref.length; j < len; j++) {
      row = ref[j];
      DOM.addClass(row, cls);
    }
    return this;
  };

  ListView.prototype.rowRemoveClass = function(row_i, cls) {
    var j, len, ref, row;
    ref = this.getRow(row_i);
    for (j = 0, len = ref.length; j < len; j++) {
      row = ref[j];
      DOM.removeClass(row, cls);
    }
    return this;
  };

  ListView.prototype.getColdef = function(col_i) {
    return this.__cols[col_i];
  };

  ListView.prototype.getColsCount = function() {
    return this.colsCount;
  };

  ListView.prototype.resetColWidth = function(col_i) {
    delete this.__manualColWidths[col_i];
    this.__resetColWidth(col_i);
    this.__doLayout({
      resetRows: true
    });
    return this;
  };

  ListView.prototype.setColWidth = function(col_i, width) {
    this.__manualColWidths[col_i] = width;
    delete this.__colWidths[col_i];
    this.__doLayout({
      resetRows: true
    });
    return this;
  };

  ListView.prototype.getRowHeight = function(row_i) {
    return this.__rowHeights[row_i];
  };

  ListView.prototype.getColWidth = function(col_i) {
    return this.__colWidths[col_i];
  };

  ListView.prototype.getCellGridRect = function(col_i, row_i) {
    var _col_i, _rect, _row_i, cell, display_col_i, display_row_i, get_cell, j, k, rect, ref, ref1;
    get_cell = (function(_this) {
      return function(_row_i, _col_i) {
        var ref;
        if (((ref = _this.__colspanRows[_row_i]) != null ? ref[_col_i] : void 0) > 1) {
          return null;
        } else {
          return _this.__cells[_row_i][_col_i];
        }
      };
    })(this);
    cell = get_cell(row_i, col_i);
    if (cell) {
      return this.getCellGridRectByNode(cell);
    }
    rect = {};
    for (display_col_i = j = 0, ref = this.colsCount; 0 <= ref ? j < ref : j > ref; display_col_i = 0 <= ref ? ++j : --j) {
      _col_i = this.getColIdx(display_col_i);
      cell = get_cell(row_i, _col_i);
      if (!cell) {
        continue;
      }
      _rect = this.getCellGridRectByNode(cell);
      rect.top = _rect.top;
      rect.height = _rect.height;
      break;
    }
    for (display_row_i = k = 0, ref1 = this.rowsCount; 0 <= ref1 ? k < ref1 : k > ref1; display_row_i = 0 <= ref1 ? ++k : --k) {
      _row_i = this.getRowIdx(display_row_i);
      cell = get_cell(_row_i, col_i);
      if (!cell) {
        continue;
      }
      _rect = this.getCellGridRectByNode(cell);
      rect.left = _rect.left;
      rect.width = _rect.width;
      break;
    }
    if (CUI.isEmptyObject(rect)) {
      return null;
    }
    return rect;
  };

  ListView.prototype.getCellGridRectByNode = function(_cell) {
    var _pos_grid, _rect, cell, rect;
    assert(isElement(_cell), "ListView.getCellGridRectByNode", "Cell node needs to be instance of HTMLElement.", {
      cell: _cell
    });
    if (!this._autoLayout) {
      cell = _cell.parent();
    } else {
      cell = _cell;
    }
    _pos_grid = this.grid.offset();
    _rect = cell.rect();
    rect = {
      left_abs: _rect.left,
      top_abs: _rect.top,
      left: _rect.left - _pos_grid.left,
      top: _rect.top - _pos_grid.top
    };
    rect.width = cell.outerWidth(true);
    rect.height = cell.outerHeight(true);
    return rect;
  };

  ListView.prototype.getRowGridRect = function(row_i) {
    var rect;
    rect = this.getCellGridRect(0, row_i);
    rect.width = this.getGrid().width();
    return rect;
  };

  ListView.prototype.appendRow = function(row, _defer) {
    if (_defer == null) {
      _defer = !this.grid;
    }
    if (_defer) {
      return this.__deferRow(row);
    } else {
      return this.__appendRows([row]);
    }
  };

  ListView.prototype.prependRow = function(row) {
    var row_i;
    assert(!this.isDestroyed(), "ListView.prependRow", "ListView " + this.listViewCounter + " is already destroyed.");
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(0, 0, row_i);
    return this.__addRow(row_i, row, "prepend");
  };

  ListView.prototype.replaceRow = function(row_i, row) {
    return this.__addRow(row_i, row, "replace");
  };

  ListView.prototype.insertRowAt = function(display_row_i, row) {
    assert(!this.isDestroyed(), "ListView.insertRowAfter", "ListView " + this.listViewCounter + " is already destroyed.");
    if (display_row_i === this.rowsCount || this.rowsCount === 0) {
      return this.appendRow(row);
    } else if (display_row_i === 0) {
      return this.prependRow(row);
    } else {
      return this.insertRowBefore(this.getRowIdx(display_row_i), row);
    }
  };

  ListView.prototype.insertRowAfter = function(sibling_row_i, row) {
    var row_i, sibling_display_row_i;
    assert(!this.isDestroyed(), "ListView.insertRowAfter", "ListView #" + this.listViewCounter + " is already destroyed.");
    sibling_display_row_i = this.getDisplayRowIdx(sibling_row_i);
    assert(sibling_display_row_i > -1, "ListView.insertRowAfter", "ListView #" + this.listViewCounter + ": Row " + sibling_row_i + " not found.", {
      row_i: sibling_row_i,
      row: row,
      rowsCount: this.rowsCount
    });
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(sibling_display_row_i + 1, 0, row_i);
    return this.__addRow(row_i, row, "after", sibling_row_i);
  };

  ListView.prototype.insertRowBefore = function(sibling_row_i, row) {
    var before_row_i, row_i, sibling_display_row_i;
    assert(!this.isDestroyed(), "ListView.insertRowBefore", "ListView #" + this.listViewCounter + " is already destroyed.");
    sibling_display_row_i = this.getDisplayRowIdx(sibling_row_i);
    if (sibling_display_row_i === 0) {
      return this.prependRow(row);
    }
    before_row_i = this.getRowIdx(sibling_display_row_i - 1);
    row_i = ++this.__maxRowIdx;
    this.rowsCount++;
    this.rowsOrder.splice(sibling_display_row_i, 0, row_i);
    return this.__addRow(row_i, row, "after", before_row_i);
  };

  ListView.prototype.removeAllRows = function() {
    var j, len, ref, row_i;
    ref = this.rowsOrder.slice(0);
    for (j = 0, len = ref.length; j < len; j++) {
      row_i = ref[j];
      this.removeRow(row_i);
    }
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.removeDeferredRow = function(listViewRow) {
    var count;
    count = removeFromArray(listViewRow, this.__deferredRows);
    assert(count === 1, "ListView.removeListViewRow", "row not found", {
      listViewRow: listViewRow
    });
    return this;
  };

  ListView.prototype.removeRow = function(row_i) {
    var display_row_i, j, len, ref, row;
    assert(row_i !== null && row_i >= 0, "ListView.removeRow", "row_i must be >= 0", {
      row_i: row_i
    });
    display_row_i = this.getDisplayRowIdx(row_i);
    assert(display_row_i > -1, "ListView.removeRow", "display_row_id not found for row_i", {
      row_i: row_i
    });
    this.rowsOrder.splice(display_row_i, 1);
    this.rowsCount--;
    delete this.__colspanRows[row_i];
    ref = this.getRow(row_i);
    for (j = 0, len = ref.length; j < len; j++) {
      row = ref[j];
      DOM.remove(jQuery(row));
    }
    delete this.__rows[row_i];
    this.__resetRowDim(row_i);
    delete this.__cells[row_i];
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.appendDeferredRows = function() {
    if (this.__deferredRows.length) {
      this.__appendRows(this.__deferredRows);
      this.__deferredRows = [];
    }
    return this;
  };

  ListView.prototype.getRow = function(row_i) {
    return this.__rows[row_i];
  };

  ListView.prototype.getBottom = function() {
    return this.__bottomQuadrants;
  };

  ListView.prototype.getTop = function() {
    return this.__topQuadrants;
  };

  ListView.prototype.__scheduleLayout = function() {
    if (!this.__isInDOM) {
      return;
    }
    if (this.layoutIsStopped()) {
      this.__layoutAfterStart = true;
      return;
    }
    if (this.__scheduleLayoutTimeout) {
      return;
    }
    this.__scheduleLayoutTimeout = CUI.setTimeout((function(_this) {
      return function() {
        var r;
        _this.__scheduleLayoutTimeout = null;
        if (!_this.__hasLayout && _this.rowsCount > 0) {
          r = _this.grid.rect();
          if (r.width === 0 || r.height === 0) {
            CUI.error("ListView.__scheduleLayout, size of 0 x 0, not layouting.");
            return;
          }
        }
        return _this.__doLayout();
      };
    })(this));
    return this;
  };

  ListView.prototype.layoutIsStopped = function() {
    return this.__layoutIsStopped;
  };

  ListView.prototype.stopLayout = function() {
    if (this.__layoutIsStopped) {
      return false;
    } else {
      this.__layoutIsStopped = true;
      return true;
    }
  };

  ListView.prototype.startLayout = function() {
    if (this.__layoutAfterStart) {
      this.__layoutAfterStart = false;
      this.__doLayout();
    }
    this.__layoutIsStopped = null;
    return this;
  };

  ListView.prototype.__doLayout = function(opts) {
    var dim, el, j, len, ref;
    if (opts == null) {
      opts = {};
    }
    ref = DOM.findElements(this.getGrid()[0], ".list-view-row-new");
    for (j = 0, len = ref.length; j < len; j++) {
      el = ref[j];
      el.classList.remove("list-view-row-new");
    }
    switch (this._autoLayout) {
      case true:
        this.__doAutoLayout();
        break;
      case 2:
        this.__doNextGenLayout(opts);
        break;
      default:
        this.__doManualLayout();
    }
    this.hideWaitBlock(true);
    if (!this.__maximize_horizontal || !this.__maximize_vertical) {
      dim = DOM.getDimensions(this.DOM[0]);
      if (this.__layoutDim) {
        if (this.__layoutDim.clientWidth !== dim.clientWidth || this.__layoutDim.clientHeight !== dim.clientHeight) {
          Events.trigger({
            type: "content-resize",
            exclude_self: true,
            node: this.DOM[0]
          });
        }
      }
      this.__layoutDim = dim;
    }
    this.__hasLayout = true;
    return this;
  };

  ListView.prototype.__doNextGenLayout = function(opts) {
    var add_css, cell, col_i, col_width, colspan, css, display_col_i, fc, i, idx, j, k, l, len, len1, len2, len3, m, manual_col_width, n, qi, ref, ref1, ref2, ref3, ref4, ref5, row, row_i, row_i2, row_info, rows, sel, width;
    if (opts == null) {
      opts = {};
    }
    if (this.grid.clientWidth === 0 || this.grid.clientHeight === 0) {
      console.warn("ListView#" + this.listViewCounter + ".__doNextGenLayout: clientWidth or clientHeight is 0, not layouting.");
      return;
    }
    css = [];
    add_css = (function(_this) {
      return function(col_i, width) {
        return css.push("." + _this.__lvClass + "-cell[col=\"" + col_i + ("\"] { width: " + width + "px !important; flex: 0 0 auto !important;}"));
      };
    })(this);
    col_width = [];
    ref = this.__fillCells;
    for (display_col_i = j = 0, len = ref.length; j < len; display_col_i = ++j) {
      fc = ref[display_col_i];
      col_i = this.getColIdx(display_col_i);
      manual_col_width = this.__manualColWidths[col_i];
      if (manual_col_width > 0) {
        add_css(col_i, manual_col_width);
        col_width[col_i] = manual_col_width;
        fc.style.setProperty("width", manual_col_width + "px");
        fc.style.setProperty("flex", "0 0 auto");
      } else {
        col_width[col_i] = fc.offsetWidth;
        fc.style.removeProperty("width");
        fc.style.removeProperty("flex");
      }
    }
    ref1 = this.__colspanRows;
    for (row_i in ref1) {
      row_info = ref1[row_i];
      for (col_i in row_info) {
        colspan = row_info[col_i];
        cell = DOM.matchSelector(this.grid[0], "[row=\"" + row_i + "\"][col=\"" + col_i + "\"]")[0];
        width = 0;
        for (i = k = 0, ref2 = colspan; k < ref2; i = k += 1) {
          width = width + col_width[parseInt(col_i) + i];
        }
        if (width === 0) {
          console.error("col width == 0", row_i, col_i, colspan, col_width);
        }
        cell.style.setProperty("width", width + "px", "important");
      }
    }
    this.styleElement.innerHTML = css.join("\n");
    if (this.fixedColsCount > 0) {
      ref3 = [0, 2];
      for (l = 0, len1 = ref3.length; l < len1; l++) {
        qi = ref3[l];
        rows = [];
        if (opts.resetRows) {
          sel = ".cui-lv-tr-outer";
        } else {
          sel = "[cui-lv-tr-unmeasured=\"" + this.listViewCounter + "\"]";
        }
        ref4 = DOM.matchSelector(this.grid[0], ("[cui-lv-quadrant='" + qi + "'] ") + sel);
        for (m = 0, len2 = ref4.length; m < len2; m++) {
          row = ref4[m];
          rows[parseInt(DOM.getAttribute(row, "row"))] = row;
          DOM.removeAttribute(row, "cui-lv-tr-unmeasured");
        }
        ref5 = DOM.matchSelector(this.grid[0], ("[cui-lv-quadrant='" + (qi + 1) + "'] ") + sel);
        for (idx = n = 0, len3 = ref5.length; n < len3; idx = ++n) {
          row = ref5[idx];
          row_i2 = parseInt(DOM.getAttribute(row, "row"));
          DOM.setDimensions(rows[row_i2], {
            borderBoxHeight: row.offsetHeight
          });
          DOM.removeAttribute(row, "cui-lv-tr-unmeasured");
        }
      }
    }
    this.__setMargins();
    return this;
  };

  ListView.prototype.__doManualLayout = function() {
    var add_css, col_i, css, fc, j, k, l, len, len1, len2, max_width, ref, ref1, ref2, set_width_for_max_cols, td, w;
    css = [];
    set_width_for_max_cols = [];
    max_width = null;
    this.styleElement.innerHTML = "";
    this.__fillRowQ3.style.width = "";
    add_css = (function(_this) {
      return function(col_i, w) {
        return css.push("td > div." + _this.__lvClass + "-cell.cui-list-view-grid-cell-col-" + col_i + " { width: " + w + "px; }");
      };
    })(this);
    this.__colWidths = [];
    ref = this.__fillCells;
    for (col_i = j = 0, len = ref.length; j < len; col_i = ++j) {
      fc = ref[col_i];
      w = this.__manualColWidths[col_i];
      if (w >= 0) {
        add_css(col_i, w);
        fc.style.width = w + "px";
        this.__colWidths[col_i] = w;
        if (indexOf.call(this.__maxCols, col_i) >= 0) {
          fc.style.flexGrow = "0";
        }
      } else {
        fc.style.width = "";
        if (indexOf.call(this.__maxCols, col_i) >= 0) {
          fc.style.flexGrow = "";
        }
      }
    }
    if (this.rowsCount > 0) {
      ref1 = this.__fillCells;
      for (col_i = k = 0, len1 = ref1.length; k < len1; col_i = ++k) {
        fc = ref1[col_i];
        if (this.__manualColWidths[col_i] > 0 || indexOf.call(this.__maxCols, col_i) >= 0) {
          continue;
        }
        td = DOM.findElement(this.grid[0], "td[col='" + col_i + "']:not([colspan])");
        if (!td) {
          CUI.warn("Col_i: no td found", this.rowsCount, this.grid, col_i, "td[col='" + col_i + "']:not([colspan])");
          continue;
        }
        this.__colWidths[col_i] = w = td.getBoundingClientRect().width;
        fc.style.width = w + "px";
      }
    }
    ref2 = this.__fillCells;
    for (col_i = l = 0, len2 = ref2.length; l < len2; col_i = ++l) {
      fc = ref2[col_i];
      if (this.__isMaximizedCol(col_i)) {
        this.__colWidths[col_i] = w = fc.getBoundingClientRect().width;
        add_css(col_i, w);
      }
    }
    this.styleElement.innerHTML = css.join("\n");
    this.__addRowsOddEvenClasses();
    this.__setMargins();
    return this;
  };

  ListView.prototype.__addRowsOddEvenClasses = function() {
    if ((this.rowsCount - this.fixedRowsCount) % 2 === 0) {
      this.grid.addClass("cui-list-view-grid-rows-even");
      this.grid.removeClass("cui-list-view-grid-rows-odd");
    } else {
      this.grid.removeClass("cui-list-view-grid-rows-even");
      this.grid.addClass("cui-list-view-grid-rows-odd");
    }
    return this;
  };

  ListView.prototype.__doAutoLayout = function() {
    this.__measureCellDims();
    this.__calculateDims();
    if (this.isDestroyed()) {
      return;
    }
    this.__addStyle();
    this.__addRowsOddEvenClasses();
    this.__setMargins();
    if (this.__currentScroll.top > 0 || this.__currentScroll.left > 0) {
      this.__setScrolling(this.__currentScroll);
      this.__syncScrolling();
    }
    return this;
  };

  ListView.prototype.__getValue = function(px) {
    if (!isNaN(parseFloat(px))) {
      return px + "px";
    } else if (isNull(px)) {
      return "";
    } else {
      return px;
    }
  };

  ListView.prototype.hideWaitBlock = function(internal) {
    if (internal == null) {
      internal = false;
    }
    if (!this.grid) {
      this.__showWaitBlock = false;
    } else if (this.__waitBlock) {
      if (!internal || this.__waitBlock.__internal) {
        this.__waitBlock.destroy();
        delete this.__waitBlock;
      }
    }
    return this;
  };

  ListView.prototype.showWaitBlock = function(internal) {
    if (internal == null) {
      internal = false;
    }
    if (this.__waitBlock) {
      return this;
    }
    if (!this.grid) {
      this.__showWaitBlock = true;
      return;
    }
    delete this.__showWaitBlock;
    this.__waitBlock = new WaitBlock({
      element: this.grid
    });
    this.__waitBlock.__internal = internal;
    this.__waitBlock.show();
    return this;
  };

  ListView.prototype.__debugRect = function(func, ms) {
    var viewport;
    viewport = this.grid.rect();
    return this.grid.rect(true, 500, ("ListView[#" + this.listViewCounter + "]." + func + " " + ms + "ms ") + viewport.width + "x" + viewport.height);
  };

  ListView.prototype.__appendRows = function(rows) {
    var idx, j, len, row, row_i, start_row_i;
    assert(!this.isDestroyed(), "ListView.appendRow", "ListView " + this.listViewCounter + " is already destroyed.");
    for (idx = j = 0, len = rows.length; j < len; idx = ++j) {
      row = rows[idx];
      row_i = ++this.__maxRowIdx;
      if (idx === 0) {
        start_row_i = row_i;
      }
      this.rowsCount++;
      this.rowsOrder.push(row_i);
    }
    this.__addRows(start_row_i, rows);
    return this;
  };

  ListView.prototype.__getColsFromAndTo = function(qi) {
    switch (qi) {
      case 0:
      case 2:
        return {
          from: 0,
          to: this.fixedColsCount - 1
        };
      case 1:
      case 3:
        return {
          from: this.fixedColsCount,
          to: this.colsCount - 1
        };
    }
  };

  ListView.prototype.__deferRow = function(row) {
    return this.__deferredRows.push(row);
  };

  ListView.prototype.__addRow = function(row_i, listViewRow, mode, sibling_row_i) {
    if (listViewRow == null) {
      listViewRow = null;
    }
    if (mode == null) {
      mode = "append";
    }
    if (sibling_row_i == null) {
      sibling_row_i = null;
    }
    return this.__addRows(row_i, [listViewRow], mode, sibling_row_i);
  };

  ListView.prototype.__getQuadrants = function(row_i) {
    if (this.getDisplayRowIdx(row_i) < this.fixedRowsCount) {
      return [0, 1];
    } else {
      return [2, 3];
    }
  };

  ListView.prototype.__addRows = function(_row_i, listViewRows, mode, sibling_row_i) {
    var _mode, _qi, _qi_s, anchor_row, anchor_row_idx, cls, col_i, display_col_i, find_cells_and_rows, fixedRows, ft, html, i, idx, j, k, l, len, len1, len2, listViewRow, m, maxi, n, new_cls, node, o, outer, p, qi, ref, ref1, ref2, ref3, ref4, ref5, ref6, row, row_i, txt, width;
    if (listViewRows == null) {
      listViewRows = [];
    }
    if (mode == null) {
      mode = "append";
    }
    if (sibling_row_i == null) {
      sibling_row_i = null;
    }
    assert(this.grid, "ListView.__addRows", "ListView.render has not been called yet.", {
      row_i: _row_i,
      listView: this
    });
    assert(mode === "append" || mode === "prepend" || mode === "after" || mode === "replace", "ListView.__addRows", "mode \"" + mode + "\" not supported", {
      row_i: _row_i
    });
    txt = ("ListView[" + this.listViewCounter + "].__addRows: Adding ") + listViewRows.length + (" rows, starting at " + _row_i + ".");
    html = [[], [], [], []];
    _mode = mode;
    if (_mode === "after" && this.getDisplayRowIdx(_row_i) === this.fixedRowsCount) {
      mode = "prepend";
    }
    if (mode === "replace" || mode === "after") {
      switch (mode) {
        case "replace":
          assert(listViewRows.length === 1, "ListView.__addRows", "Can only use mode \"" + mode + "\" on one row", {
            listViewRows: listViewRows
          });
          row_i = _row_i;
          this.__resetRowDim(row_i);
          break;
        case "after":
          row_i = sibling_row_i;
      }
      anchor_row = this.__rows[row_i];
      assert(anchor_row.length >= 1, "ListView.__addRows", "anchor row " + row_i + " for mode " + mode + " not found.", {
        rows: this.__rows,
        row_i: row_i,
        mode: _mode,
        mode_used: mode
      });
    }
    if (this.__isInDOM) {
      new_cls = "list-view-row-new";
    } else {
      new_cls = "";
    }
    for (row_i = j = ref = _row_i, ref1 = row_i + listViewRows.length - 1; j <= ref1; row_i = j += 1) {
      this.__cells[row_i] = [];
      this.__rows[row_i] = [];
      ref2 = this.__getQuadrants(row_i);
      for (idx = k = 0, len = ref2.length; k < len; idx = ++k) {
        qi = ref2[idx];
        ft = this.__getColsFromAndTo(qi);
        if (ft.to < ft.from) {
          continue;
        }
        switch (this._autoLayout) {
          case true:
            html[qi].push("<div class=\"" + new_cls + " cui-list-view-grid-row " + this.__lvClass + "-row cui-list-view-grid-row-" + row_i + "\" row=\"" + row_i + "\">");
            break;
          case 2:
            html[qi].push("<div class=\"cui-lv-tr-outer cui-list-view-grid-row\" cui-lv-tr-unmeasured=\"" + this.listViewCounter + "\" row=\"" + row_i + "\"><div class=\"cui-lv-tr\">");
            break;
          default:
            html[qi].push("<tr class=\"" + new_cls + " cui-list-view-grid-row " + this.__lvClass + "-row cui-list-view-grid-row-" + row_i + "\" row=\"" + row_i + "\">");
        }
        for (display_col_i = l = ref3 = ft.from, ref4 = ft.to; l <= ref4; display_col_i = l += 1) {
          col_i = this.getColIdx(display_col_i);
          ref5 = this.__getColWidth(row_i, col_i), width = ref5[0], maxi = ref5[1];
          cls = this.__getColClass(col_i);
          switch (this._autoLayout) {
            case true:
              html[qi].push("<div class=\"cui-list-view-grid-cell cui-list-view-grid-cell-div " + this.__lvClass + "-cell cui-list-view-grid-cell-col cui-list-view-grid-cell-col-" + col_i + " " + cls + "\" col=\"" + col_i + "\" row=\"" + row_i + "\"></div>");
              break;
            case 2:
              html[qi].push("<div class=\"cui-lv-td " + cls + " " + this.__lvClass + "-cell cui-list-view-grid-cell\" col=\"" + col_i + "\" row=\"" + row_i + "\"></div>");
              break;
            default:
              html[qi].push("<td class=\"cui-list-view-grid-cell-td " + cls + "\" col=" + col_i + " row=" + row_i + "><div class=\"cui-list-view-grid-cell " + cls + " " + this.__lvClass + "-cell cui-list-view-grid-cell-col cui-list-view-grid-cell-col-" + col_i + "\" col=" + col_i + " row=" + row_i + "></div></td>");
          }
        }
        switch (this._autoLayout) {
          case true:
            html[qi].push("</div>");
            break;
          case 2:
            html[qi].push("</div></div>");
            break;
          default:
            html[qi].push("</tr>");
        }
      }
    }
    find_cells_and_rows = (function(_this) {
      return function(top) {
        var _cells, _col, _row, _rows, cell, len1, len2, m, n, row;
        _cells = CUI.DOM.matchSelector(top, ".cui-list-view-grid-cell");
        for (m = 0, len1 = _cells.length; m < len1; m++) {
          cell = _cells[m];
          _col = parseInt(cell.getAttribute("col"));
          _row = parseInt(cell.getAttribute("row"));
          _this.__cells[_row][_col] = $(cell);
        }
        _rows = CUI.DOM.matchSelector(top, ".cui-list-view-grid-row[row]");
        for (n = 0, len2 = _rows.length; n < len2; n++) {
          row = _rows[n];
          row_i = parseInt(row.getAttribute("row"));
          _this.__rows[row_i].push(row);
        }
      };
    })(this);
    anchor_row_idx = 0;
    for (qi = m = 0; m <= 3; qi = ++m) {
      if (html[qi].length === 0) {
        continue;
      }
      if (this._autoLayout) {
        outer = document.createElement("div");
      } else {
        outer = document.createElement("tbody");
      }
      outer.innerHTML = html[qi].join("");
      find_cells_and_rows(outer);
      if (mode === "append") {
        if (this._autoLayout && (qi === 2 || qi === 3)) {
          while (node = outer.firstChild) {
            this.quadrantRows[qi].insertBefore(node, this.quadrantRows[qi].lastChild);
          }
        } else {
          while (node = outer.firstChild) {
            this.quadrantRows[qi].appendChild(node);
          }
        }
        continue;
      }
      if (mode === "prepend") {
        while (node = outer.lastChild) {
          this.quadrantRows[qi].insertBefore(node, this.quadrantRows[qi].firstChild);
        }
        continue;
      }
      row = $(anchor_row[anchor_row_idx]);
      anchor_row_idx++;
      if (mode === "after") {
        while (node = outer.lastChild) {
          row.after(node);
        }
        continue;
      }
      if (mode === "replace") {
        node = outer.firstChild;
        CUI.DOM.replaceWith(row, node);
      }
    }
    if (this.fixedRowsCount > 0) {
      fixedRows = this.quadrantRows[1].childNodes;
      if (this.fixedRowsCount < fixedRows.length) {
        if (this.fixedColsCount > 0) {
          _qi_s = [0, 1];
        } else {
          _qi_s = [1];
        }
        for (i = n = 0, ref6 = fixedRows.length - this.fixedRowsCount; n < ref6; i = n += 1) {
          for (o = 0, len1 = _qi_s.length; o < len1; o++) {
            _qi = _qi_s[o];
            if (this.quadrantRows[_qi + 2].firstChild) {
              this.quadrantRows[_qi + 2].insertBefore(this.quadrantRows[_qi].lastChild, this.quadrantRows[_qi + 2].firstChild);
            } else {
              this.quadrantRows[_qi + 2].appendChild(this.quadrantRows[_qi].lastChild);
            }
          }
        }
      }
    }
    for (idx = p = 0, len2 = listViewRows.length; p < len2; idx = ++p) {
      listViewRow = listViewRows[idx];
      if (isPromise(listViewRow)) {
        (function(_this) {
          return (function(idx) {
            return listViewRow.done(function(_listViewRow) {
              return _this.__appendCells(_listViewRow, _row_i + idx);
            });
          });
        })(this)(idx);
      } else {
        this.__appendCells(listViewRow, _row_i + idx);
      }
    }
    this.__scheduleLayout();
    return this;
  };

  ListView.prototype.__appendCells = function(listViewRow, row_i) {
    var _cols, cell, col, col_i, colspan, colspan_offset, i, j, k, l, len, len1, node, ref, ref1, row;
    assert(listViewRow instanceof ListViewRow, "ListView.addRow", "listViewRow needs to be instance of ListViewRow or Deferred which returns a ListViewRow", {
      listViewRow: listViewRow
    });
    listViewRow.setRowIdx(row_i).setListView(this);
    ref = this.__rows[row_i];
    for (j = 0, len = ref.length; j < len; j++) {
      row = ref[j];
      DOM.data(row, "listViewRow", listViewRow);
    }
    listViewRow.addClass((listViewRow.getClass() || "") + " " + toDash(getObjectClass(listViewRow)));
    if (this._rowMove) {
      if (row_i >= this.fixedRowsCount + this._rowMoveFixedRows) {
        listViewRow.prependColumn(new ListViewColumnRowMoveHandle());
      } else {
        listViewRow.prependColumn(new ListViewColumnRowMoveHandlePlaceholder());
      }
    } else if (this._rowMovePlaceholder) {
      listViewRow.prependColumn(new ListViewColumnRowMoveHandlePlaceholder());
    }
    _cols = listViewRow.getColumns();
    colspan_offset = 0;
    for (col_i = k = 0, len1 = _cols.length; k < len1; col_i = ++k) {
      col = _cols[col_i];
      node = col.render();
      cell = this.__cells[row_i][col_i + colspan_offset];
      assert(cell, "ListView.__appendCells", "Cell not found: row: " + row_i + " column: " + (col_i + colspan_offset + 1) + ". colsCount: " + this.colsCount);
      if (!isNull(node)) {
        cell.append(node);
      }
      col.setElement(cell);
      colspan = col.getColspan();
      assert(col_i + colspan_offset + colspan - 1 < this.colsCount, "ListView.__appendCells", "Colspan " + colspan + " exceeds cols count " + this.colsCount + ", unable to append cell.", {
        row_i: row_i,
        col_i: col_i,
        colspan_offset: colspan_offset,
        colspan: colspan,
        column: col,
        row: listViewRow,
        ListView: this
      });
      if (colspan > 1) {
        cell.attr("colspan", colspan);
        if (!this._autoLayout) {
          cell.parent().attr("colspan", colspan);
        }
        if (!this.__colspanRows[row_i]) {
          this.__colspanRows[row_i] = {};
        }
        this.__colspanRows[row_i][col_i + colspan_offset] = colspan;
        for (i = l = 1, ref1 = colspan; 1 <= ref1 ? l < ref1 : l > ref1; i = 1 <= ref1 ? ++l : --l) {
          if (!this._autoLayout) {
            this.__cells[row_i][col_i + colspan_offset + 1].parent().remove();
          } else {
            this.__cells[row_i][col_i + colspan_offset + 1].remove();
          }
          delete this.__cells[row_i][col_i + colspan_offset + 1];
          colspan_offset++;
        }
      }
    }
    assert(_cols.length + colspan_offset <= this.colsCount, "ListView.addRow", "ListViewRow provided more columns (" + (_cols.length + colspan_offset) + ") than colsCount (" + this.colsCount + ") is set to", {
      colsCount: this.colsCount,
      cols: _cols
    });
    listViewRow.addedToListView();
  };

  ListView.prototype.__getColClass = function(col_i) {
    var cls, col_cls, ref;
    col_cls = (ref = this.__colClasses) != null ? ref[col_i] : void 0;
    cls = [];
    if (CUI.isArray(col_cls)) {
      cls.push.apply(cls, col_cls);
    } else if (!isEmpty(col_cls)) {
      cls.push(col_cls);
    }
    switch (this._autoLayout) {
      case 2:
        if (indexOf.call(this.__maxCols, col_i) >= 0) {
          cls.push("cui-lv-td-max");
        }
        break;
      default:
        if (indexOf.call(this.__maxCols, col_i) >= 0) {
          cls.push("cui-list-view-grid-cell-max");
        } else {
          cls.push("cui-list-view-grid-cell-standard");
        }
    }
    return cls.join(" ");
  };

  ListView.prototype.__resetRowDim = function(row_i) {
    var col_i, display_col_i, j, k, len, ref, ref1, row;
    delete this.__cellDims[row_i];
    delete this.__rowHeights[row_i];
    if (this.__rows[row_i]) {
      ref = this.__rows[row_i];
      for (j = 0, len = ref.length; j < len; j++) {
        row = ref[j];
        DOM.setAttribute(row, "cui-lv-tr-unmeasured", this.listViewCounter);
      }
    }
    for (display_col_i = k = 0, ref1 = this.colsCount - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; display_col_i = 0 <= ref1 ? ++k : --k) {
      col_i = this.getColIdx(display_col_i);
      this.__resetCellStyle(row_i, col_i);
    }
    return this;
  };

  ListView.prototype.__resetCellStyle = function(row_i, col_i) {
    var cell, ref;
    cell = (ref = this.__cells[row_i]) != null ? ref[col_i] : void 0;
    if (cell) {
      cell[0].style.cssText = "";
    }
    return cell;
  };

  ListView.prototype.__resetColWidth = function(col_i) {
    var dim, display_row_i, j, k, len, ref, ref1, row_i;
    ref = this.__cellDims;
    for (j = 0, len = ref.length; j < len; j++) {
      dim = ref[j];
      if (dim) {
        delete dim[col_i];
      }
    }
    for (display_row_i = k = 0, ref1 = this.rowsCount - 1; 0 <= ref1 ? k <= ref1 : k >= ref1; display_row_i = 0 <= ref1 ? ++k : --k) {
      row_i = this.getRowIdx(display_row_i);
      this.__resetCellStyle(row_i, col_i);
    }
    this.__fillCells[col_i].style.cssText = "";
    this.__colWidths[col_i] = null;
    return this;
  };

  ListView.prototype.__resetCellDims = function(col_i) {
    this.__cellDims = [];
    this.__colWidths = [];
    return this.__rowHeights = [];
  };

  ListView.prototype.__measureCellDims = function() {
    var cell, col_i, display_col_i, display_row_i, j, k, rect, ref, ref1, ref2, row_i;
    for (display_row_i = j = 0, ref = this.rowsCount - 1; j <= ref; display_row_i = j += 1) {
      row_i = this.getRowIdx(display_row_i);
      if (!this.__cellDims[row_i]) {
        this.__cellDims[row_i] = [];
      }
      for (display_col_i = k = 0, ref1 = this.colsCount - 1; k <= ref1; display_col_i = k += 1) {
        col_i = this.getColIdx(display_col_i);
        if (this.__cellDims[row_i][col_i]) {
          continue;
        }
        cell = this.__cells[row_i][col_i];
        if (!cell) {
          this.__cellDims[row_i][col_i] = [0, 0];
        } else {
          rect = cell[0].getBoundingClientRect();
          if (((ref2 = this.__colspanRows[row_i]) != null ? ref2[col_i] : void 0) > 1) {
            this.__cellDims[row_i][col_i] = [0, rect.height];
          } else {
            this.__cellDims[row_i][col_i] = [rect.width, rect.height];
          }
        }
      }
    }
    return this;
  };

  ListView.prototype.__calculateDims = function() {
    var calcHeight, calcWidth, col_i, display_col_i, display_row_i, height, j, k, l, m, manualWidth, ref, ref1, ref2, ref3, row_i, rowsCount, txt, width;
    txt = ("ListView[" + this.listViewCounter + "].__calculateDims[" + this.listViewCounter + "]: ") + this.rowsCount + " rows. ";
    for (display_row_i = j = 0, ref = this.rowsCount - 1; j <= ref; display_row_i = j += 1) {
      row_i = this.getRowIdx(display_row_i);
      if (this.__rowHeights.hasOwnProperty(row_i)) {
        continue;
      }
      calcHeight = -1;
      for (display_col_i = k = 0, ref1 = this.colsCount - 1; k <= ref1; display_col_i = k += 1) {
        col_i = this.getColIdx(display_col_i);
        height = this.__cellDims[row_i][col_i][1];
        if (height > calcHeight) {
          calcHeight = height;
        }
      }
      this.__rowHeights[row_i] = calcHeight;
    }
    for (display_col_i = l = 0, ref2 = this.colsCount - 1; l <= ref2; display_col_i = l += 1) {
      col_i = this.getColIdx(display_col_i);
      if (this.__colWidths[col_i] !== null && this.__colWidths.hasOwnProperty(col_i)) {

      }
      rowsCount = this.rowsCount;
      manualWidth = this.__manualColWidths[col_i];
      if (manualWidth >= 0) {
        calcWidth = manualWidth;
      } else {
        calcWidth = -1;
        for (display_row_i = m = 0, ref3 = rowsCount - 1; m <= ref3; display_row_i = m += 1) {
          row_i = this.getRowIdx(display_row_i);
          width = this.__cellDims[row_i][col_i][0];
          if (width > calcWidth) {
            calcWidth = width;
          }
        }
      }
      this.__colWidths[col_i] = calcWidth;
    }
    return this;
  };

  ListView.prototype.__getMostCommonIntegerInArray = function(values) {
    var count, j, len, max_count, mostCommon, stats, v;
    stats = {};
    for (j = 0, len = values.length; j < len; j++) {
      v = values[j];
      if (!stats[v]) {
        stats[v] = 1;
      } else {
        stats[v]++;
      }
    }
    mostCommon = null;
    max_count = 0;
    for (v in stats) {
      count = stats[v];
      if (count > max_count) {
        mostCommon = v;
        max_count = count;
      }
    }
    return parseInt(mostCommon);
  };

  ListView.prototype.__calcSum = function(arr) {
    var item, j, len, sum;
    sum = 0;
    for (j = 0, len = arr.length; j < len; j++) {
      item = arr[j];
      if (isNull(item)) {
        continue;
      }
      sum += item;
    }
    return sum;
  };

  ListView.prototype.__isMaximizedCol = function(col_i) {
    return indexOf.call(this.__maxCols, col_i) >= 0 && !this.__manualColWidths.hasOwnProperty(col_i);
  };

  ListView.prototype.__removeStyle = function() {
    var col_i, display_col_i, display_row_i, j, k, ref, ref1, row_i;
    for (display_col_i = j = 0, ref = this.colsCount - 1; j <= ref; display_col_i = j += 1) {
      col_i = this.getColIdx(display_col_i);
      this.__fillCells[col_i].style.cssText = "";
      for (display_row_i = k = 0, ref1 = this.rowsCount - 1; k <= ref1; display_row_i = k += 1) {
        row_i = this.getRowIdx(display_row_i);
        this.__resetCellStyle(row_i, col_i);
      }
    }
    return this;
  };

  ListView.prototype.__addStyle = function() {
    var cell, col_i, display_col_i, display_row_i, j, k, maxi, ref, ref1, ref2, ref3, ref4, row_i, set_width, width;
    set_width = (function(_this) {
      return function(sty, width, maxi) {
        if (width === -1) {
          sty.minWidth = "";
          sty.flexGrow = "";
          return sty.width = "";
        } else if (maxi) {
          sty.minWidth = _this.__getValue(width);
          return sty.flexGrow = 1;
        } else {
          sty.minWidth = "";
          sty.flexGrow = "";
          return sty.width = _this.__getValue(width);
        }
      };
    })(this);
    for (display_row_i = j = 0, ref = this.rowsCount - 1; j <= ref; display_row_i = j += 1) {
      row_i = this.getRowIdx(display_row_i);
      for (display_col_i = k = 0, ref1 = this.colsCount - 1; k <= ref1; display_col_i = k += 1) {
        col_i = this.getColIdx(display_col_i);
        if (this.getColdef(col_i) === "manual") {
          if (!(((ref2 = this.__colspanRows[row_i]) != null ? ref2[col_i] : void 0) > 1)) {
            continue;
          }
        }
        if (this._autoLayout && display_row_i === 0) {
          ref3 = this.__getColWidth(null, col_i), width = ref3[0], maxi = ref3[1];
          set_width(this.__fillCells[col_i].style, width, maxi);
        }
        cell = this.__cells[row_i][col_i];
        if (!cell) {
          continue;
        }
        ref4 = this.__getColWidth(row_i, col_i), width = ref4[0], maxi = ref4[1];
        set_width(cell[0].style, width, maxi);
        cell[0].style.height = this.__getValue(this.__rowHeights[row_i]);
      }
    }
    return this;
  };

  ListView.counter = 0;

  ListView.prototype.__getColWidth = function(row_i, col_i) {
    var _col_i, accWidth, colspan, j, maxi, ref, ref1, ref2;
    colspan = (ref = this.__colspanRows[row_i]) != null ? ref[col_i] : void 0;
    if (colspan > 1) {
      accWidth = 0;
      maxi = false;
      for (_col_i = j = ref1 = col_i, ref2 = col_i + colspan - 1; j <= ref2; _col_i = j += 1) {
        if (this.__isMaximizedCol(_col_i)) {
          maxi = true;
        }
        accWidth += this.__colWidths[_col_i];
      }
      return [accWidth, maxi];
    } else {
      return [this.__colWidths[col_i], this.__isMaximizedCol(col_i)];
    }
  };

  ListView.prototype.__debugCall = function(name, func) {
    var end, start;
    if (!CUI.defaults.debug) {
      return func();
    }
    start = getMs();
    func();
    end = getMs();
    return this.__debugRect(name, end - start);
  };

  ListView.prototype.__addDebugControl = function() {
    Events.listen({
      type: "contextmenu",
      node: this.DOM,
      call: (function(_this) {
        return function(ev) {
          var get_maximize_text, items;
          if (!(ev.altKey() && !(ev.ctrlKey() || ev.shiftKey() || ev.metaKey()))) {
            return;
          }
          ev.preventDefault();
          ev.stopPropagation();
          _this.grid.rect(true, 500);
          get_maximize_text = function(name, on_off) {
            return name + ": " + (on_off ? "ON" : "OFF");
          };
          items = [
            {
              label: "ListView[#" + _this.listViewCounter + "] Debug Menu"
            }, {
              text: "measure",
              onClick: function() {
                return _this.__debugCall("__measureCellDims", function() {
                  _this.__resetCellDims();
                  _this.__measureCellDims();
                  _this.__calculateDims();
                  CUI.debug(_this.__cellDims);
                  return CUI.debug("colWidths:", _this.__colWidths, "rowHeights:", _this.__rowHeights);
                });
              }
            }, {
              text: "addStyle",
              onClick: function(ev) {
                return _this.__debugCall("__addStyle", function() {
                  return _this.__addStyle(ev);
                });
              }
            }, {
              text: "removeStyle",
              onClick: function(ev) {
                return _this.__debugCall("__removeStyle", function() {
                  return _this.__removeStyle(ev);
                });
              }
            }, {
              text: "layout",
              onClick: function() {
                return _this.__debugCall("__doLayout", function() {
                  return _this.__doLayout({
                    resetRows: true
                  });
                });
              }
            }, {
              text: "flash",
              onClick: function() {
                return _this.grid.rect(true, 1000, "ListView[#" + _this.listViewCounter + "]");
              }
            }, {
              text: "showWaitBlock",
              onClick: function(ev) {
                return _this.showWaitBlock();
              }
            }, {
              text: "hideWaitBlock",
              onClick: function(ev) {
                return _this.hideWaitBlock();
              }
            }, {
              text: "debug",
              onClick: function() {
                return _this.__debugCall("debug", function() {
                  CUI.debug("ListView[#" + _this.listViewCounter + "]", _this);
                  CUI.debug("opts:", _this.opts);
                  CUI.debug("manualColWidths:", dump(_this.__manualColWidths));
                  return CUI.debug("colWidths:", dump(_this.__colWidths), "rowHeights:", _this.__rowHeights);
                });
              }
            }, {
              text: "appendRow",
              onClick: function() {
                var col, col_i, display_col_i, j, len, lv, ref;
                lv = new ListViewRow();
                ref = _this._cols;
                for (display_col_i = j = 0, len = ref.length; j < len; display_col_i = ++j) {
                  col = ref[display_col_i];
                  col_i = _this.getColIdx(display_col_i);
                  lv.addColumn(new ListViewColumn({
                    text: _this.getColdef(col_i) + " " + _this.rowsCount
                  }));
                }
                return _this.appendRow(lv);
              }
            }, {
              text: "removeRow",
              onClick: function() {
                return _this.removeRow(_this.getRowIdx(_this.rowsCount - 1));
              }
            }, {
              text: "close",
              onClick: function() {
                return _this.__control.destroy();
              }
            }
          ];
          (new Menu({
            auto_close_after_click: false,
            itemList: {
              items: items
            },
            show_at_position: {
              top: ev.pageY(),
              left: ev.pageX()
            }
          })).show();
          return false;
        };
      })(this)
    });
    return this;
  };

  return ListView;

})(CUI.SimplePane);

ListView = CUI.ListView;
// Generated by CoffeeScript 1.9.3
var ListViewTree,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewTree = (function(superClass) {
  extend(ListViewTree, superClass);

  function ListViewTree(opts) {
    this.opts = opts != null ? opts : {};
    ListViewTree.__super__.constructor.call(this, this.opts);
    this.root.setTree(this);
  }

  ListViewTree.prototype.initOpts = function() {
    ListViewTree.__super__.initOpts.call(this);
    return this.addOpts({
      rowMoveWithinNodesOnly: {
        check: Boolean
      },
      children: {
        check: Array
      },
      selectable: {
        check: Boolean
      },
      no_hierarchy: {
        "default": false,
        check: Boolean
      },
      root: {
        check: function(v) {
          return v instanceof ListViewRow;
        }
      },
      onOpen: {
        check: Function
      },
      onClose: {
        check: Function
      }
    });
  };

  ListViewTree.prototype.readOpts = function() {
    var i, idx, len, lv_opts, ref, t;
    ListViewTree.__super__.readOpts.call(this);
    if (!this._root) {
      lv_opts = {};
      if (this._children) {
        lv_opts.children = this._children;
      } else if (this._getChildren) {
        lv_opts.getChildren = this._getChildren;
      } else {
        lv_opts.children = [];
      }
      this.root = new ListViewTreeNode(lv_opts);
    } else {
      assert(this._root instanceof ListViewTreeNode, "new ListViewTree", "opts.root must be instance of ListViewTreeNode", {
        opts: this.opts
      });
      this.root = this._root;
    }
    ref = this.tools;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      t = ref[idx];
      if (t instanceof ListViewRowMoveTool) {
        this.tools[idx] = new ListViewTreeRowMoveTool({
          rowMoveWithinNodesOnly: this._rowMoveWithinNodesOnly
        });
      }
    }
    return this;
  };

  ListViewTree.prototype.isSelectable = function() {
    return this._selectable;
  };

  ListViewTree.prototype.hasSelectableRows = function() {
    return this._selectable;
  };

  ListViewTree.prototype.isNoHierarchy = function() {
    return this._no_hierarchy;
  };

  ListViewTree.prototype.triggerNodeDeselect = function(ev, node) {
    var info;
    info = {
      ev: ev,
      node: node,
      listView: this
    };
    if (typeof this._onDeselect === "function") {
      this._onDeselect(ev, info);
    }
    return Events.trigger({
      node: this,
      type: "row_deselected"
    });
  };

  ListViewTree.prototype.triggerNodeSelect = function(ev, node) {
    var info;
    info = {
      ev: ev,
      node: node,
      listView: this
    };
    if (typeof this._onSelect === "function") {
      this._onSelect(ev, info);
    }
    return Events.trigger({
      node: this,
      type: "row_selected"
    });
  };

  ListViewTree.prototype.render = function(do_open) {
    if (do_open !== false) {
      CUI.error("ListViewTree.render called with do_open == " + do_open + ", only \"false\" is supported. The automatic root.open() is deprecated and will be removed in a future version.");
      do_open = true;
    }
    ListViewTree.__super__.render.call(this);
    if (do_open) {
      this.root.open();
    }
    Events.listen({
      node: this.DOM,
      capture: true,
      type: ["click", "dragover-scroll"],
      call: (function(_this) {
        return function(ev, info) {
          var $target, _handle, _row, action_on_node, node, prep_target, run_trigger;
          $target = $(ev.getTarget());
          _row = $target.closest(".cui-list-view-grid-row");
          _handle = $target.closest(".cui-tree-node-handle");
          node = DOM.data(_row, "listViewRow");
          if (!node || (typeof node.isLoading === "function" ? node.isLoading() : void 0)) {
            return;
          }
          prep_target = function() {
            if (ev.getType() === "click") {
              _handle.css({
                opacity: 0.5
              });
              return true;
            }
            if (info.mousemoveEvent._done) {
              return false;
            }
            if (info.mousemoveEvent._counter % 2 === 0) {
              _handle.css({
                opacity: ""
              });
            } else {
              _handle.css({
                opacity: 0.5
              });
            }
            return info.mousemoveEvent._counter > 4;
          };
          run_trigger = function(action) {
            if (ev.ctrlKey() && ev.getType() === "click") {
              action_on_node(action + "Recursively", node);
            } else {
              action_on_node(action, node);
            }
          };
          action_on_node = function(action, _node) {
            var hide_spinner, ref, ret, spinner_timeout;
            console.time(_this.__uniqueId + ": action on node " + action);
            if ((ref = info.mousemoveEvent) != null) {
              ref._done = true;
            }
            ev.stopPropagation();
            hide_spinner = null;
            spinner_timeout = CUI.setTimeout({
              ms: 500,
              call: function() {
                node.showSpinner();
                spinner_timeout = null;
                return hide_spinner = true;
              }
            });
            _this.stopLayout();
            ret = _node[action]();
            ret.done(function() {
              switch (action) {
                case "open":
                  return typeof _this._onOpen === "function" ? _this._onOpen(ev, {
                    node: node
                  }) : void 0;
                case "close":
                  return typeof _this._onClose === "function" ? _this._onClose(ev, {
                    node: node
                  }) : void 0;
              }
            });
            ret.always(function() {
              if (spinner_timeout) {
                CUI.clearTimeout(spinner_timeout);
              }
              if (hide_spinner) {
                node.hideSpinner();
              }
              return _this.startLayout();
            });
            return ret;
          };
          if (_handle.hasClass("cui-tree-node-is-closed")) {
            if (prep_target()) {
              run_trigger("open");
            }
          } else if (_handle.hasClass("cui-tree-node-is-open")) {
            if (prep_target()) {
              run_trigger("close");
            }
          }
        };
      })(this)
    });
    Events.listen({
      node: this.DOM,
      type: ["click"],
      call: (function(_this) {
        return function(ev, info) {
          var $target, _row, node;
          if (ev.hasModifierKey(true)) {
            return;
          }
          $target = $(ev.getTarget());
          _row = $target.closest(".cui-list-view-grid-row");
          node = DOM.data(_row, "listViewRow");
          if (!node || (typeof node.isLoading === "function" ? node.isLoading() : void 0)) {
            return;
          }
          if (typeof node.isSelected === "function" ? node.isSelected() : void 0) {
            if (typeof node.deselect === "function") {
              node.deselect(ev);
            }
          } else {
            if (typeof node.select === "function") {
              node.select(ev);
            }
          }
        };
      })(this)
    });
    if (this._no_hierarchy) {
      this.grid.addClass("cui-list-view-tree-no-hierarchy");
    }
    return this.DOM;
  };

  ListViewTree.prototype.getNodesForMove = function(from_i, to_i, after) {
    var from_node, new_father, to_node;
    from_node = this.getListViewRow(from_i);
    to_node = this.getListViewRow(to_i);
    assert(from_node, "ListViewTree.moveRow", "from_i node not found", {
      from_i: from_i
    });
    assert(to_node, "ListViewTree.moveRow", "to_i node not found", {
      to_i: to_i
    });
    if (from_node.father === to_node.father && !(to_node.is_open && after)) {
      new_father = null;
    } else if (to_node.is_open && after) {
      new_father = to_node;
    } else {
      new_father = to_node.father;
    }
    if (new_father === from_node.father) {
      new_father = null;
    }
    return [from_node, to_node, new_father];
  };

  ListViewTree.prototype.moveRow = function(from_i, to_i, after) {
    var from_node, new_father, promise, ref, to_node;
    ref = this.getNodesForMove(from_i, to_i, after), from_node = ref[0], to_node = ref[1], new_father = ref[2];
    promise = from_node.moveNodeBefore(to_node, new_father, after);
    assert(isPromise(promise), "ListViewTree.moveRow", "moveNodeBefore needs to return a Promise", {
      promise: promise
    });
    promise.done((function(_this) {
      return function() {
        ListViewTree.__super__.moveRow.call(_this, from_i, to_i, after, false);
        if (from_node.father === to_node.father && !(to_node.is_open && after)) {
          moveInArray(from_node.getChildIdx(), to_node.getChildIdx(), from_node.father.children, after);
        } else {
          from_node.father.removeChild(from_node);
          if (to_node.is_open && after) {
            to_node.children.splice(0, 0, from_node);
            from_node.setFather(to_node);
          } else {
            if (!after) {
              to_node.father.children.splice(to_node.getChildIdx(), 0, from_node);
            } else {
              to_node.father.children.splice(to_node.getChildIdx() + 1, 0, from_node);
            }
            from_node.setFather(to_node.father);
          }
        }
        from_node.reload();
        if (new_father != null) {
          new_father.reload();
        }
        from_node.moveNodeAfter(to_node, new_father, after);
        return Events.trigger({
          node: _this.grid,
          type: "row_moved",
          info: {
            from_i: from_i,
            to_i: to_i,
            after: after
          }
        });
      };
    })(this));
    return promise;
  };

  ListViewTree.prototype.getRootChildren = function() {
    return this.root.children;
  };

  ListViewTree.prototype.getSelectedNode = function() {
    return this.root.selectedNode;
  };

  ListViewTree.prototype.prependNode = function(node) {
    return this.addNode(node, false);
  };

  ListViewTree.prototype.addNode = function(node, append) {
    var promise;
    if (append == null) {
      append = true;
    }
    assert(node instanceof ListViewTreeNode, (getObjectClass(this)) + ".addNode", "Node must be instance of ListViewTreeNode", {
      node: node
    });
    promise = this.root.addNode(node, append);
    Events.trigger({
      node: this,
      type: "row_added",
      info: {
        node: node
      }
    });
    return promise;
  };

  ListViewTree.prototype.openTreeNodeByRowDisplayIndex = function(index) {
    var row, row_index;
    row_index = this.getRowIdx(index);
    row = this.getRow(row_index);
    return DOM.data(row[0], "listViewRow").open();
  };

  return ListViewTree;

})(CUI.ListView);

CUI.Events.registerEvent({
  bubble: true,
  type: ["row_removed", "row_added", "row_moved", "row_selected", "row_deselected"]
});

ListViewTree = CUI.ListViewTree;
// Generated by CoffeeScript 1.9.3
var ListViewRow,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ListViewRow = (function(superClass) {
  extend(ListViewRow, superClass);

  function ListViewRow() {
    return ListViewRow.__super__.constructor.apply(this, arguments);
  }

  ListViewRow.prototype.initOpts = function() {
    ListViewRow.__super__.initOpts.call(this);
    return this.addOpts({
      columns: {
        check: Array
      },
      selectable: {
        check: Boolean
      },
      "class": {
        check: String
      }
    });
  };

  ListViewRow.prototype.readOpts = function() {
    var col, i, idx, len, ref;
    ListViewRow.__super__.readOpts.call(this);
    if (this._columns) {
      this.columns = this._columns;
      ref = this.columns;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        col = ref[idx];
        if (col) {
          this.setColumn(idx, col);
        }
      }
    } else {
      this.columns = [];
    }
    if (this._selectable === false) {
      this.setSelectable(false);
    } else {
      this.setSelectable(true);
    }
    if (this._class) {
      this.__class = this._class;
    } else {
      this.__class = null;
    }
    this.row_i = null;
    this.__addedToListView = false;
    return this.listView = null;
  };

  ListViewRow.prototype.addColumn = function(column) {
    assert(column instanceof ListViewColumn, "ListViewRow.addColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns.push(column);
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.setColumn = function(idx, column) {
    assert(column instanceof ListViewColumn, "ListViewRow.addColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns[idx] = column;
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.prependColumn = function(column) {
    assert(column instanceof ListViewColumn, "ListViewRow.prependColumn", "column must be instance of ListViewColumn", {
      column: column
    });
    this.columns.splice(0, 0, column);
    column.setRow(this);
    return this;
  };

  ListViewRow.prototype.setSelectable = function(on_off) {
    return this.__selectable = on_off;
  };

  ListViewRow.prototype.isSelectable = function() {
    if (this.listView) {
      if (!this.listView.hasSelectableRows()) {
        return false;
      }
      if (this.getRowIdx() < this.listView.fixedRowsCount) {
        return false;
      }
    }
    return this.__selectable;
  };

  ListViewRow.prototype.isMovable = function(ev) {
    return this.listView.hasMovableRows();
  };

  ListViewRow.prototype.moveRow = null;

  ListViewRow.prototype.removeColumns = function() {
    var c, i, len, ref;
    ref = this.columns;
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      c.setRow();
    }
    return this.columns.splice(0);
  };

  ListViewRow.prototype.getColumns = function() {
    return this.columns;
  };

  ListViewRow.prototype.setRowIdx = function(row_i) {
    this.row_i = row_i;
    return this;
  };

  ListViewRow.prototype.getDOMNodes = function() {
    var ref;
    return CUI.jQueryCompat((ref = this.listView) != null ? ref.getRow(this.row_i) : void 0);
  };

  ListViewRow.prototype.getRowIdx = function() {
    return this.row_i;
  };

  ListViewRow.prototype.scrollIntoView = function() {
    var ref;
    if ((ref = this.getDOMNodes()[0]) != null) {
      ref.scrollIntoView();
    }
    return this;
  };

  ListViewRow.prototype.getDisplayRowIdx = function() {
    var ref;
    return (ref = this.listView) != null ? ref.getDisplayRowIdx(this.row_i) : void 0;
  };

  ListViewRow.prototype.addedToListView = function() {
    return this.__addedToListView = true;
  };

  ListViewRow.prototype.isAddedToListView = function() {
    return this.__addedToListView;
  };

  ListViewRow.prototype.setListView = function(listView) {
    this.listView = listView;
  };

  ListViewRow.prototype.getListView = function() {
    return this.listView;
  };

  ListViewRow.prototype.__selectableClass = "cui-list-view-row-selectable";

  ListViewRow.prototype.getClass = function() {
    if (this.isSelectable()) {
      return this.__selectableClass + " " + this.__class;
    } else {
      return this.__class;
    }
  };

  ListViewRow.prototype.setClass = function(__class) {
    this.__class = __class;
  };

  ListViewRow.prototype.addClass = function(cls) {
    var ref;
    return (ref = this.listView) != null ? ref.rowAddClass(this.row_i, cls) : void 0;
  };

  ListViewRow.prototype.removeClass = function(cls) {
    var ref;
    return (ref = this.listView) != null ? ref.rowRemoveClass(this.row_i, cls) : void 0;
  };

  ListViewRow.prototype.select = function(ev) {
    var base;
    if (this.selected) {
      CUI.debug("already selected", this);
      return;
    }
    if (!this.isSelectable()) {
      CUI.debug("not selectable", this);
      return;
    }
    this.selected = true;
    if (!this.listView) {
      return;
    }
    this.listView.rowAddClass(this.row_i, ListViewRow.defaults.selected_class);
    if (typeof (base = this.listView)._onSelect === "function") {
      base._onSelect(ev, {
        originalEvent: ev,
        listView: this.listView,
        row: this
      });
    }
    return this;
  };

  ListViewRow.prototype.deselect = function(ev) {
    var ref, ref1;
    if (!this.listView.hasSelectableRows()) {
      return;
    }
    if (!this.selected) {
      return;
    }
    if ((ref = this.listView) != null) {
      ref.rowRemoveClass(this.row_i, ListViewRow.defaults.selected_class);
    }
    this.selected = false;
    if ((ref1 = this.listView) != null) {
      if (typeof ref1._onDeselect === "function") {
        ref1._onDeselect(ev, {
          originalEvent: ev,
          listView: this.listView,
          row: this
        });
      }
    }
    return this;
  };

  ListViewRow.prototype.isSelected = function() {
    return !!this.selected;
  };

  ListViewRow.prototype.remove = function() {
    return this.listView.removeRow(this.row_i);
  };

  ListViewRow.defaults = {
    selected_class: "cui-selected"
  };

  return ListViewRow;

})(CUI.Element);

ListViewRow = CUI.ListViewRow;
// Generated by CoffeeScript 1.9.3
var ListViewHeaderRow,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewHeaderRow = (function(superClass) {
  extend(ListViewHeaderRow, superClass);

  function ListViewHeaderRow() {
    return ListViewHeaderRow.__super__.constructor.apply(this, arguments);
  }

  ListViewHeaderRow.prototype.isSelectable = function() {
    return false;
  };

  return ListViewHeaderRow;

})(ListViewRow);
// Generated by CoffeeScript 1.9.3
var ListViewTreeNode,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.ListViewTreeNode = (function(superClass) {
  extend(ListViewTreeNode, superClass);

  function ListViewTreeNode() {
    this.update = bind(this.update, this);
    return ListViewTreeNode.__super__.constructor.apply(this, arguments);
  }

  ListViewTreeNode.prototype.initOpts = function() {
    ListViewTreeNode.__super__.initOpts.call(this);
    return this.addOpts({
      children: {
        check: Array
      },
      open: {
        check: Boolean
      },
      html: {},
      getChildren: {
        check: Function
      }
    });
  };

  ListViewTreeNode.prototype.readOpts = function() {
    ListViewTreeNode.__super__.readOpts.call(this);
    if (this._children) {
      this.children = this.opts.children;
      this.initChildren();
    }
    if (this._open) {
      this.do_open = true;
    } else {
      this.do_open = false;
    }
    this.is_open = false;
    this.html = this._html;
    return this.__loadingDeferred = null;
  };

  ListViewTreeNode.prototype.isLeaf = function() {
    var leaf;
    leaf = (this.children ? false : this.opts.getChildren ? false : this.getChildren ? this.opts.leaf || (this.hasChildren && !this.hasChildren()) ? true : false : true);
    return leaf;
  };

  ListViewTreeNode.prototype.isSelectable = function() {
    return (typeof this.getTree === "function" ? this.getTree().isSelectable() : void 0) && this.__selectable;
  };

  ListViewTreeNode.prototype.getFather = function() {
    return this.father;
  };

  ListViewTreeNode.prototype.setFather = function(new_father) {
    var c, j, len, ref, ref1, tree;
    assert(new_father === null || new_father instanceof ListViewTreeNode, (getObjectClass(this)) + ".setFather", "father can only be null or instanceof ListViewTreeNode", {
      father: new_father
    });
    assert(new_father !== this, (getObjectClass(this)) + ".setFather", "father cannot be self", {
      node: this,
      father: new_father
    });
    if (new_father) {
      assert(indexOf.call(new_father.getPath(true), this) < 0, (getObjectClass(this)) + ".setFather", "father cannot any of the node's children", {
        node: this,
        father: new_father
      });
    }
    if (!new_father && this.selected) {
      if ((ref = this.getRoot()) != null) {
        ref.selectedNode = null;
      }
      this.selected = false;
    }
    if (this.father && !new_father) {
      tree = this.getTree();
      this.father = new_father;
      if (tree) {
        this.setTree(tree);
      }
    } else {
      this.father = new_father;
    }
    if (this.children) {
      ref1 = this.children;
      for (j = 0, len = ref1.length; j < len; j++) {
        c = ref1[j];
        c.setFather(this);
      }
    }
    return this;
  };

  ListViewTreeNode.prototype.isRoot = function() {
    return !this.father;
  };

  ListViewTreeNode.prototype.setTree = function(tree1) {
    this.tree = tree1;
    assert(this.isRoot(), (getObjectClass(this)) + ".setTree", "node must be root node to set tree", {
      tree: this.tree,
      opts: this.opts
    });
    return assert(this.tree instanceof ListViewTree, (getObjectClass(this)) + ".setTree", "tree must be instance of ListViewTree", {
      tree: this.tree,
      opts: this.opts
    });
  };

  ListViewTreeNode.prototype.getRoot = function(call) {
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getRoot", "Recursion detected.");
    if (this.father) {
      return this.father.getRoot(call + 1);
    } else {
      return this;
    }
  };

  ListViewTreeNode.prototype.dump = function(lines, depth) {
    var c, j, k, len, pad, padding, ref, ref1;
    if (lines == null) {
      lines = [];
    }
    if (depth == null) {
      depth = 0;
    }
    padding = [];
    for (pad = j = 0, ref = depth; 0 <= ref ? j < ref : j > ref; pad = 0 <= ref ? ++j : --j) {
      padding.push("  ");
    }
    lines.push(padding.join("") + this.dumpString());
    if (this.children) {
      ref1 = this.children;
      for (k = 0, len = ref1.length; k < len; k++) {
        c = ref1[k];
        c.dump(lines, depth + 1);
      }
    }
    if (depth === 0) {
      return "\n" + lines.join("\n") + "\n";
    }
  };

  ListViewTreeNode.prototype.dumpString = function() {
    return this.getNodeId();
  };

  ListViewTreeNode.prototype.getTree = function(call) {
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getTree", "Recursion detected.");
    if (this.isRoot()) {
      return this.tree;
    } else {
      return this.getRoot().getTree(call + 1);
    }
  };

  ListViewTreeNode.prototype.find = function(eq_func, nodes) {
    var c, j, len, ref;
    if (eq_func == null) {
      eq_func = null;
    }
    if (nodes == null) {
      nodes = [];
    }
    if (!eq_func || eq_func.call(this, this)) {
      nodes.push(this);
    }
    if (this.children) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        c.find(eq_func, nodes);
      }
    }
    return nodes;
  };

  ListViewTreeNode.prototype.filter = function(filter_func, filtered_nodes) {
    var c, father, idx, j, k, len, len1, our_idx, ref, save_children;
    if (filtered_nodes == null) {
      filtered_nodes = [];
    }
    save_children = (ref = this.children) != null ? ref.slice(0) : void 0;
    if (this.father && filter_func.call(this, this)) {
      our_idx = this.getChildIdx();
      filtered_nodes.push(this);
      father = this.getFather();
      ListViewTreeNode.prototype.remove.call(this, true, false);
      for (idx = j = 0, len = save_children.length; j < len; idx = ++j) {
        c = save_children[idx];
        father.children.splice(our_idx + idx, 0, c);
        c.setFather(father);
      }
    }
    if (save_children) {
      for (k = 0, len1 = save_children.length; k < len1; k++) {
        c = save_children[k];
        c.filter(filter_func, filtered_nodes);
      }
    }
    return filtered_nodes;
  };

  ListViewTreeNode.prototype.getPath = function(include_self, path, call) {
    if (include_self == null) {
      include_self = false;
    }
    if (path == null) {
      path = [];
    }
    if (call == null) {
      call = 0;
    }
    assert(call < 100, "ListViewTreeNode.getPath", "Recursion detected.");
    if (this.father) {
      this.father.getPath(true, path, call + 1);
    }
    if (include_self) {
      path.push(this);
    }
    return path;
  };

  ListViewTreeNode.prototype.getChildIdx = function() {
    var ci;
    if (this.isRoot()) {
      return "root";
    } else {
      ci = this.father.children.indexOf(this);
      assert(ci > -1, (getObjectClass(this)) + ".getChildIdx()", "Node not found in fathers children Array", {
        node: this,
        father: this.father,
        "father.children": this.father.children
      });
      return ci;
    }
  };

  ListViewTreeNode.prototype.getNodeId = function(include_self) {
    var p, path;
    if (include_self == null) {
      include_self = true;
    }
    path = this.getPath(include_self);
    return ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = path.length; j < len; j++) {
        p = path[j];
        results.push(p.getChildIdx());
      }
      return results;
    })()).join(".");
  };

  ListViewTreeNode.prototype.getOpenChildNodes = function(nodes) {
    var j, len, node, ref;
    if (nodes == null) {
      nodes = [];
    }
    if (this.children && this.is_open) {
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        node = ref[j];
        nodes.push(node);
        node.getOpenChildNodes(nodes);
      }
    }
    return nodes;
  };

  ListViewTreeNode.prototype.getRowsToMove = function() {
    return this.getOpenChildNodes();
  };

  ListViewTreeNode.prototype.isRendered = function() {
    var ref;
    if ((this.isRoot() && ((ref = this.getTree()) != null ? ref.getGrid() : void 0)) || this.element) {
      return true;
    } else {
      return false;
    }
  };

  ListViewTreeNode.prototype.sort = function(func, level) {
    var j, len, node, ref, ref1;
    if (level == null) {
      level = 0;
    }
    if (!((ref = this.children) != null ? ref.length : void 0)) {
      return;
    }
    this.children.sort(func);
    ref1 = this.children;
    for (j = 0, len = ref1.length; j < len; j++) {
      node = ref1[j];
      node.sort(func, level + 1);
    }
    if (level === 0 && this.isRendered()) {
      this.reload();
    }
    return this;
  };

  ListViewTreeNode.prototype.close = function() {
    assert(this.father, "ListViewTreeNode.close()", "Cannot close root node", {
      node: this
    });
    assert(!this.isLoading(), "ListViewTreeNode.close", "Cannot close node, during opening...", {
      node: this,
      tree: this.getTree()
    });
    this.do_open = false;
    if (this.father.is_open) {
      this.removeFromDOM(false);
      this.replaceSelf();
    }
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.removeFromDOM = function(remove_self) {
    var c, j, len, ref;
    if (remove_self == null) {
      remove_self = true;
    }
    this.abortLoading();
    if (this.is_open) {
      this.do_open = true;
      ref = this.children;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        c.removeFromDOM();
      }
    } else {
      this.do_open = false;
    }
    if (remove_self) {
      if (this.element) {
        if (this.getRowIdx() === null) {
          if (!this.isRoot()) {
            this.getTree().removeDeferredRow(this);
          }
        } else {
          this.getTree().removeRow(this.getRowIdx());
        }
        this.element = null;
      }
    }
    this.is_open = false;
    return this;
  };

  ListViewTreeNode.prototype.getElement = function() {
    return this.element;
  };

  ListViewTreeNode.prototype.replaceSelf = function() {
    var tree;
    if (this.father) {
      if (tree = this.getTree()) {
        tree.replaceRow(this.getRowIdx(), this.render());
        if (this.selected) {
          tree.rowAddClass(this.getRowIdx(), ListViewRow.defaults.selected_class);
        }
      }
      return CUI.resolvedPromise();
    } else if (this.is_open) {
      this.removeFromDOM(false);
      return this.open();
    } else {
      return CUI.resolvedPromise();
    }
  };

  ListViewTreeNode.prototype.openRecursively = function() {
    return this.__actionRecursively("open");
  };

  ListViewTreeNode.prototype.closeRecursively = function() {
    return this.__actionRecursively("close");
  };

  ListViewTreeNode.prototype.__actionRecursively = function(action) {
    var dfr;
    dfr = new CUI.Deferred();
    if (this.isLeaf()) {
      return dfr.resolve().promise();
    }
    this[action]().done((function(_this) {
      return function() {
        var child, j, len, promises, ref;
        promises = [];
        ref = _this.children;
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          promises.push(child[action + "Recursively"]());
        }
        return CUI.when(promises).done(function() {
          return dfr.resolve();
        }).fail(function() {
          return dfr.reject();
        });
      };
    })(this)).fail((function(_this) {
      return function() {
        return dfr.reject();
      };
    })(this));
    return dfr.promise();
  };

  ListViewTreeNode.prototype.isOpen = function() {
    return !!this.is_open;
  };

  ListViewTreeNode.prototype.isLoading = function() {
    return !!this.__loadingDeferred;
  };

  ListViewTreeNode.prototype.getLoading = function() {
    return this.__loadingDeferred;
  };

  ListViewTreeNode.prototype.abortLoading = function() {
    if (!this.__loadingDeferred) {
      return;
    }
    CUI.error("ListViewTreeNode.abortLoading: Aborting chunk loading.");
    return this.__loadingDeferred.reject();
  };

  ListViewTreeNode.prototype.open = function() {
    var dfr, func, load_children, ret, tree;
    dfr = new CUI.Deferred();
    tree = this.getTree();
    assert(!this.isLoading(), "ListViewTreeNode.open", "Cannot open node " + (this.getUniqueId()) + ", during opening. This can happen if the same node exists multiple times in the same tree.", {
      node: this,
      tree: tree
    });
    if (this.is_open) {
      return dfr.resolve(this).promise();
    }
    this.__loadingDeferred = new CUI.Deferred();
    dfr.always((function(_this) {
      return function() {
        _this.__loadingDeferred = null;
      };
    })(this));
    load_children = (function(_this) {
      return function() {
        var promises;
        assert(CUI.isArray(_this.children), "ListViewTreeNode.open", "children to be loaded must be an Array", {
          children: _this.children,
          listViewTreeNode: _this
        });
        if (_this.children.length === 0) {
          _this.is_open = true;
          _this.do_open = false;
          if (!_this.isRoot()) {
            _this.replaceSelf();
          }
          dfr.resolve(_this);
          return;
        }
        _this.initChildren();
        promises = [];
        _this.__loadingDeferred = CUI.chunkWork(_this.children, 5, 1).progress(function(node, idx) {
          return promises.push(_this.__appendNode(node, true));
        }).done(function() {
          return CUI.when(promises).done(function() {
            _this.is_open = true;
            _this.do_open = false;
            if (!_this.isRoot()) {
              _this.replaceSelf();
            }
            return dfr.resolve(_this);
          }).fail(function() {
            return dfr.reject(_this);
          });
        }).fail(function() {
          var c, j, len, ref;
          ref = _this.children;
          for (j = 0, len = ref.length; j < len; j++) {
            c = ref[j];
            c.removeFromDOM();
          }
          return dfr.reject(_this);
        });
      };
    })(this);
    if (this.children) {
      load_children();
    } else {
      func = this.opts.getChildren || this.getChildren;
      if (func) {
        ret = func.call(this);
        if (CUI.isArray(ret)) {
          this.children = ret;
          load_children();
        } else {
          assert(isPromise(ret), (getObjectClass(this)) + ".open", "returned children are not of type Promise or Array", {
            children: ret
          });
          ret.done((function(_this) {
            return function(children1) {
              _this.children = children1;
              if (_this.__loadingDeferred.state() === "rejected") {
                CUI.warn("getChildren promise returned, but node opening was cancelled.");
                return dfr.reject(_this);
              } else {
                return load_children();
              }
            };
          })(this)).fail((function(_this) {
            return function() {
              return dfr.reject(_this);
            };
          })(this));
        }
      } else {
        if (!this.isRoot()) {
          this.replaceSelf();
        }
        dfr.resolve(this);
      }
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.prependChild = function(node) {
    return this.addNode(node, false);
  };

  ListViewTreeNode.prototype.addChild = function(node) {
    return this.addNode(node, true);
  };

  ListViewTreeNode.prototype.prependSibling = function(node) {
    var idx;
    idx = this.getChildIdx();
    return this.father.addNode(node, idx);
  };

  ListViewTreeNode.prototype.appendSibling = function(node) {
    var idx;
    idx = this.getChildIdx() + 1;
    if (idx > this.father.children.length - 1) {
      return this.father.addNode(node);
    } else {
      return this.father.addNode(node, idx);
    }
  };

  ListViewTreeNode.prototype.initChildren = function() {
    var idx, j, len, node, ref;
    ref = this.children;
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      node = ref[idx];
      node.setFather(this);
    }
  };

  ListViewTreeNode.prototype.addNode = function(node, append) {
    var dfr, promise;
    if (append == null) {
      append = true;
    }
    assert(!this.isLoading(), "ListViewTreeNode.addNode", "Cannot add node, during loading.", {
      node: this
    });
    if (!this.children) {
      this.children = [];
    }
    assert(CUI.isArray(this.children), "Tree.addNode", "Cannot add node, children needs to be an Array in node", {
      node: this,
      new_node: node
    });
    if (append === true) {
      this.children.push(node);
    } else {
      this.children.splice(append, 0, node);
    }
    node.setFather(this);
    if (!this.is_open) {
      if (this.isRoot() || !this.isRendered()) {
        return CUI.resolvedPromise(node);
      }
      dfr = new CUI.Deferred();
      this.open().done((function(_this) {
        return function() {
          return dfr.resolve(node);
        };
      })(this)).fail((function(_this) {
        return function() {
          return dfr.reject(node);
        };
      })(this));
      promise = dfr.promise();
    } else {
      promise = this.__appendNode(node, append);
    }
    return promise;
  };

  ListViewTreeNode.prototype.__appendNode = function(node, append) {
    var child_idx, child_nodes, last_node, tree;
    if (append == null) {
      append = true;
    }
    assert(node instanceof ListViewTreeNode, "ListViewTreeNode.__appendNode", "node must be instance of ListViewTreeNode", {
      node: this,
      new_node: node
    });
    assert(node.getFather() === this, "ListViewTreeNode.__appendNode", "node added must be child of current node", {
      node: this,
      new_node: node
    });
    if (append === false) {
      append = 0;
    }
    tree = this.getTree();
    if (tree != null ? tree.isDestroyed() : void 0) {
      return CUI.rejectedPromise(node);
    }
    if (!this.isRendered()) {
      return CUI.resolvedPromise(node);
    }
    child_idx = node.getChildIdx();
    if (this.isRoot()) {
      if (append === true || this.children.length === 1 || append + 1 === this.children.length) {
        tree.appendRow(node.render());
      } else {
        assert(this.children[append + 1], this.__cls + ".__addNode", "Node not found", {
          children: this.children,
          node: this,
          append: append
        });
        tree.insertRowBefore(this.children[append + 1].getRowIdx(), node.render());
      }
    } else if (child_idx === 0) {
      tree.insertRowAfter(this.getRowIdx(), node.render());
    } else if (append !== true) {
      tree.insertRowBefore(this.children[append + 1].getRowIdx(), node.render());
    } else {
      last_node = this.children[child_idx - 1];
      child_nodes = last_node.getOpenChildNodes();
      if (child_nodes.length) {
        last_node = child_nodes[child_nodes.length - 1];
      }
      tree.insertRowAfter(last_node.getRowIdx(), node.render());
    }
    if (node.selected) {
      tree.rowAddClass(node.getRowIdx(), ListViewRow.defaults.selected_class);
    }
    if (node.do_open) {
      return node.open();
    } else {
      return CUI.resolvedPromise(node);
    }
  };

  ListViewTreeNode.prototype.remove = function(keep_children_array, select_after) {
    var child_idx, children, dfr, remove_node, select_after_node;
    if (keep_children_array == null) {
      keep_children_array = false;
    }
    if (select_after == null) {
      select_after = true;
    }
    dfr = new CUI.Deferred();
    select_after_node = null;
    remove_node = (function(_this) {
      return function() {
        var ref, tree;
        _this.removeFromDOM();
        if ((ref = _this.father) != null) {
          ref.removeChild(_this, keep_children_array);
        }
        if (tree = _this.getTree()) {
          Events.trigger({
            node: tree,
            type: "row_removed"
          });
          if (select_after_node) {
            select_after_node.select().done(dfr.resolve).fail(dfr.reject);
          } else {
            dfr.resolve();
          }
        } else {
          dfr.resolve();
        }
      };
    })(this);
    if (select_after && !this.isRoot()) {
      children = this.getFather().children;
      if (children.length > 1) {
        child_idx = this.getChildIdx();
        if (child_idx === 0) {
          select_after = 1;
        } else {
          select_after = Math.min(children.length - 2, child_idx - 1);
        }
      }
      if (select_after !== null) {
        select_after_node = children[select_after];
      }
    }
    if (this.isSelected()) {
      this.deselect().fail(dfr.reject).done(remove_node);
    } else {
      remove_node();
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.removeChild = function(child, keep_children_array) {
    if (keep_children_array == null) {
      keep_children_array = false;
    }
    removeFromArray(child, this.children);
    if (this.children.length === 0 && !this.isRoot()) {
      this.is_open = false;
      if (!keep_children_array) {
        this.children = null;
      }
    }
    this.update();
    return child.setFather(null);
  };

  ListViewTreeNode.prototype.deselect = function(ev) {
    if (!this.getTree().isSelectable()) {
      return CUI.resolvedPromise();
    }
    return this.check_deselect(ev).done((function(_this) {
      return function() {
        var t;
        _this.getRoot().selectedNode = null;
        t = _this.getTree();
        t.rowRemoveClass(_this.getRowIdx(), ListViewRow.defaults.selected_class);
        _this.selected = false;
        return _this.getTree().triggerNodeDeselect(ev, _this);
      };
    })(this));
  };

  ListViewTreeNode.prototype.allowRowMove = function() {
    return true;
  };

  ListViewTreeNode.prototype.allow_deselect = function(ev, info) {};

  ListViewTreeNode.prototype.check_deselect = function(ev) {
    var m;
    if (ev) {
      this.allow_deselect(ev);
      if (ev.getInfo()._confirm_hash_change) {
        m = new ModalConfirm({
          text: ev.getInfo()._confirm_hash_change
        });
        return m.open();
      }
    }
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.isSelected = function() {
    return !!this.selected;
  };

  ListViewTreeNode.prototype.select = function(ev) {
    var dfr, do_select, sel_node;
    dfr = new CUI.Deferred();
    if (ev && (typeof this.getTree === "function" ? this.getTree().isSelectable() : void 0)) {
      ev.stopPropagation();
    }
    dfr.done((function(_this) {
      return function() {
        return _this.getTree().triggerNodeSelect(ev, _this);
      };
    })(this));
    if (!this.isSelectable()) {
      return dfr.reject().promise();
    }
    if (this.isSelected()) {
      return dfr.resolve().promise();
    }
    do_select = (function(_this) {
      return function() {
        _this.getRoot().selectedNode = _this;
        return _this.openUpwards().done(function() {
          _this.getTree().rowAddClass(_this.getRowIdx(), ListViewRow.defaults.selected_class);
          _this.selected = true;
          return dfr.resolve();
        }).fail(dfr.reject);
      };
    })(this);
    sel_node = this.getRoot().selectedNode;
    if (sel_node) {
      sel_node.check_deselect(ev).done(function() {
        return sel_node.deselect().done(function() {
          return do_select();
        }).fail(dfr.reject);
      }).fail(dfr.reject);
    } else {
      do_select();
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.openUpwards = function(level) {
    var dfr, promise;
    if (level == null) {
      level = 0;
    }
    dfr = new CUI.Deferred();
    if (this.isRoot()) {
      if (this.isLoading()) {
        this.getLoading().done((function(_this) {
          return function() {
            return dfr.resolve(_this);
          };
        })(this)).fail((function(_this) {
          return function() {
            return dfr.reject(_this);
          };
        })(this));
      } else if (this.is_open) {
        dfr.resolve(this);
      } else {
        dfr.reject(this);
      }
    } else {
      promise = this.father.openUpwards(level + 1);
      promise.done((function(_this) {
        return function() {
          var _promise;
          if (!_this.is_open && level > 0) {
            if (_this.isLoading()) {
              _promise = _this.getLoading();
            } else {
              _promise = _this.open();
            }
            return _promise.done(function() {
              return dfr.resolve(_this);
            }).fail(function() {
              return dfr.reject(_this);
            });
          } else {
            return dfr.resolve(_this);
          }
        };
      })(this));
      promise.fail((function(_this) {
        return function() {
          _this.do_open = true;
          if (level === 0) {
            return dfr.resolve(_this);
          } else {
            return dfr.reject(_this);
          }
        };
      })(this));
    }
    return dfr.promise();
  };

  ListViewTreeNode.prototype.level = function() {
    if (this.isRoot()) {
      return 0;
    } else {
      return this.father.level() + 1;
    }
  };

  ListViewTreeNode.prototype.renderContent = function() {
    if (CUI.isFunction(this.html)) {
      return this.html.call(this.opts, this);
    } else if (this.html) {
      return this.html;
    } else {
      return new EmptyLabel({
        text: "<empty>"
      }).DOM;
    }
  };

  ListViewTreeNode.prototype.update = function(update_root) {
    var layout_stopped, tree;
    if (update_root == null) {
      update_root = false;
    }
    if (this.isRoot() && !update_root) {
      return;
    }
    tree = this.getTree();
    layout_stopped = tree != null ? tree.stopLayout() : void 0;
    this.replaceSelf().done((function(_this) {
      return function() {
        if (layout_stopped) {
          return tree.startLayout();
        }
      };
    })(this));
    return this;
  };

  ListViewTreeNode.prototype.reload = function() {
    assert(!this.isLoading(), "ListViewTreeNode.reload", "Cannot reload node, during opening...", {
      node: this,
      tree: this.getTree()
    });
    if (this.isRoot()) {
      return this.replaceSelf();
    } else if (this.is_open) {
      this.close();
      this.do_open = true;
      return this.open();
    } else {
      if (this.opts.children) {
        this.children = null;
      }
      return this.update();
    }
  };

  ListViewTreeNode.prototype.showSpinner = function() {
    if (this.element) {
      this.__handleDiv.empty();
      this.__handleDiv.append(new Icon({
        icon: "spinner"
      }).DOM);
    }
    return this;
  };

  ListViewTreeNode.prototype.hideSpinner = function() {
    if (this.element) {
      this.__handleDiv.empty();
      if (this.__handleIcon) {
        this.__handleDiv.append(new Icon({
          icon: this.__handleIcon
        }).DOM);
      } else {

      }
    }
    return this;
  };

  ListViewTreeNode.prototype.render = function() {
    var cls, con, content, contentDiv, i, j, k, len, ref, ref1;
    assert(!this.isRoot(), "ListViewTreeNode.render", "Unable to render root node.");
    this.removeColumns();
    this.element = $div("cui-tree-node level-" + (this.level()));
    for (i = j = 1, ref = this.level(); j < ref; i = j += 1) {
      this.element.append($div("cui-tree-node-spacer"));
    }
    cls = ["cui-tree-node-handle"];
    if (this.is_open) {
      this.__handleIcon = "tree_close";
      cls.push("cui-tree-node-is-open");
    } else if (this.isLeaf()) {
      this.__handleIcon = null;
      cls.push("cui-tree-node-is-leaf");
    } else {
      this.__handleIcon = "tree_open";
      cls.push("cui-tree-node-is-closed");
    }
    if (((ref1 = this.children) != null ? ref1.length : void 0) === 0) {
      cls.push("cui-tree-node-no-children");
    }
    this.__handleDiv = $div(cls.join(" "));
    if (this.__handleIcon) {
      this.__handleDiv.append(new Icon({
        icon: this.__handleIcon
      }).DOM);
    }
    this.element.append(this.__handleDiv);
    this.prependColumn(new ListViewColumn({
      element: this.element,
      "class": "cui-tree-node-column cui-tree-node-level-" + (this.level()),
      colspan: this.opts.colspan
    }));
    contentDiv = $div("cui-tree-node-content");
    content = this.renderContent();
    if (CUI.isArray(content)) {
      for (k = 0, len = content.length; k < len; k++) {
        con = content[k];
        contentDiv.append((con != null ? con.DOM : void 0) || content);
      }
    } else {
      contentDiv.append((content != null ? content.DOM : void 0) || content);
    }
    this.element.append(contentDiv);
    return this;
  };

  ListViewTreeNode.prototype.moveToNewFather = function(new_father, new_child_idx) {
    var old_father;
    old_father = this.father;
    old_father.removeChild(this);
    new_father.children.splice(new_child_idx, 0, this);
    this.setFather(new_father);
    old_father.reload();
    return new_father.reload();
  };

  ListViewTreeNode.prototype.moveNodeBefore = function(to_node, new_father, after) {
    return CUI.resolvedPromise();
  };

  ListViewTreeNode.prototype.moveNodeAfter = function(to_node, new_father, after) {};

  return ListViewTreeNode;

})(CUI.ListViewRow);

ListViewTreeNode = CUI.ListViewTreeNode;
// Generated by CoffeeScript 1.9.3
var ListViewColumn,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumn = (function(superClass) {
  extend(ListViewColumn, superClass);

  function ListViewColumn() {
    this.getColspan = bind(this.getColspan, this);
    this.setColspan = bind(this.setColspan, this);
    return ListViewColumn.__super__.constructor.apply(this, arguments);
  }

  ListViewColumn.prototype.readOpts = function() {
    ListViewColumn.__super__.readOpts.call(this);
    this.__cl = this._class || "";
    return this.__attrs = this._attrs || null;
  };

  ListViewColumn.prototype.initOpts = function() {
    ListViewColumn.__super__.initOpts.call(this);
    return this.addOpts({
      "class": {
        "default": "",
        check: String
      },
      attrs: {
        "default": null,
        check: "PlainObject"
      },
      text: {
        check: String
      },
      colspan: {
        check: "Integer"
      },
      element: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      onSetElement: {
        check: Function
      }
    });
  };

  ListViewColumn.prototype.setRow = function(listViewRow) {
    this.listViewRow = listViewRow;
  };

  ListViewColumn.prototype.getRow = function() {
    return this.listViewRow;
  };

  ListViewColumn.prototype.render = function() {
    if (!isUndef(this._element)) {
      if (this._element.DOM) {
        return this._element.DOM;
      } else {
        return this._element;
      }
    } else if (!isEmpty(this._text)) {
      return new Label({
        text: this._text
      }).DOM;
    } else {
      return null;
    }
  };

  ListViewColumn.prototype.getAttrs = function() {
    return this.__attrs || {};
  };

  ListViewColumn.prototype.setElement = function(__element) {
    this.__element = __element;
    this.addClass(this.getClass());
    if (this.__attrs) {
      CUI.DOM.setAttributeMap(this.__element, this.__attrs);
    }
    if (typeof this._onSetElement === "function") {
      this._onSetElement(this);
    }
    return this.__element;
  };

  ListViewColumn.prototype.getElement = function() {
    return this.__element;
  };

  ListViewColumn.prototype.getClass = function() {
    return this.__cl;
  };

  ListViewColumn.prototype.addClass = function(cls) {
    if (!this.__element) {
      this.__cl += " " + cls;
    } else if (this.__element instanceof HTMLElement) {
      CUI.DOM.addClass(this.__element, cls);
    }
    return this;
  };

  ListViewColumn.prototype.removeClass = function(cls) {
    if (this.__element instanceof HTMLElement) {
      CUI.DOM.removeClass(this.__element, cls);
    }
    return this;
  };

  ListViewColumn.prototype.setColspan = function(colspan) {
    return this._colspan = colspan;
  };

  ListViewColumn.prototype.getColspan = function() {
    var cp;
    if (CUI.isFunction(this._colspan)) {
      cp = parseInt(this._colspan());
    } else {
      cp = parseInt(this._colspan);
    }
    if (cp > 1) {
      return cp;
    } else {
      return 1;
    }
  };

  return ListViewColumn;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var ListViewColumnEmpty,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnEmpty = (function(superClass) {
  extend(ListViewColumnEmpty, superClass);

  function ListViewColumnEmpty() {
    return ListViewColumnEmpty.__super__.constructor.apply(this, arguments);
  }

  ListViewColumnEmpty.prototype.render = function() {};

  return ListViewColumnEmpty;

})(ListViewColumn);
// Generated by CoffeeScript 1.9.3
var ListViewHeaderColumn,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewHeaderColumn = (function(superClass) {
  extend(ListViewHeaderColumn, superClass);

  function ListViewHeaderColumn() {
    return ListViewHeaderColumn.__super__.constructor.apply(this, arguments);
  }

  ListViewHeaderColumn.prototype.initOpts = function() {
    ListViewHeaderColumn.__super__.initOpts.call(this);
    this.removeOpt("text");
    this.removeOpt("element");
    this.addOpts({
      rotate_90: {
        check: Boolean
      },
      label: {
        mandatory: true,
        check: function(v) {
          if (CUI.isPlainObject(v) || v instanceof Label) {
            return true;
          } else {
            return false;
          }
        }
      }
    });
  };

  ListViewHeaderColumn.prototype.readOpts = function() {
    ListViewHeaderColumn.__super__.readOpts.call(this);
    if (this._label instanceof Label) {
      return this.__label = this._label;
    } else {
      this._label.rotate_90 = this._rotate_90;
      return this.__label = new CUI.defaults["class"].Label(this._label);
    }
  };

  ListViewHeaderColumn.prototype.setElement = function(__element) {
    this.__element = __element;
    ListViewHeaderColumn.__super__.setElement.call(this, this.__element);
    if (this._rotate_90) {
      this.addClass("cui-lv-td-rotate-90");
    }
    this.addClass("cui-lv-th");
    return this.__element;
  };

  ListViewHeaderColumn.prototype.render = function() {
    return this.__label.DOM;
  };

  return ListViewHeaderColumn;

})(ListViewColumn);
// Generated by CoffeeScript 1.9.3
var ListViewColumnRowMoveHandle,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnRowMoveHandle = (function(superClass) {
  extend(ListViewColumnRowMoveHandle, superClass);

  function ListViewColumnRowMoveHandle() {
    return ListViewColumnRowMoveHandle.__super__.constructor.apply(this, arguments);
  }

  ListViewColumnRowMoveHandle.prototype.getClass = function() {
    if (this.getRow().isMovable()) {
      return "cui-list-view-row-move-handle";
    } else {
      return "";
    }
  };

  ListViewColumnRowMoveHandle.prototype.setElement = function(cell) {
    ListViewColumnRowMoveHandle.__super__.setElement.call(this, cell);
    Events.listen({
      type: ["mousedown"],
      node: cell,
      call: function(ev, info) {
        cell.attr("allow-row-move", "1");
        return Events.listen({
          type: "mouseup",
          node: window,
          only_once: true,
          capture: true,
          call: function() {
            return cell.removeAttr("allow-row-move");
          }
        });
      }
    });
  };

  ListViewColumnRowMoveHandle.prototype.render = function() {
    return new Template({
      name: "list-view-tool-row-move-handle"
    }).DOM;
  };

  return ListViewColumnRowMoveHandle;

})(ListViewColumn);
// Generated by CoffeeScript 1.9.3
var ListViewColumnRowMoveHandlePlaceholder,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColumnRowMoveHandlePlaceholder = (function(superClass) {
  extend(ListViewColumnRowMoveHandlePlaceholder, superClass);

  function ListViewColumnRowMoveHandlePlaceholder() {
    return ListViewColumnRowMoveHandlePlaceholder.__super__.constructor.apply(this, arguments);
  }

  ListViewColumnRowMoveHandlePlaceholder.prototype.initOpts = function() {
    ListViewColumnRowMoveHandlePlaceholder.__super__.initOpts.call(this);
    return this.removeOpt("class");
  };

  ListViewColumnRowMoveHandlePlaceholder.prototype.readOpts = function() {
    ListViewColumnRowMoveHandlePlaceholder.__super__.readOpts.call(this);
    return this._class = "cui-list-view-no-row-move-placeholder";
  };

  return ListViewColumnRowMoveHandlePlaceholder;

})(ListViewColumnEmpty);
// Generated by CoffeeScript 1.9.3
var ListViewTool,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewTool = (function(superClass) {
  extend(ListViewTool, superClass);

  function ListViewTool() {
    this.registerListView = bind(this.registerListView, this);
    return ListViewTool.__super__.constructor.apply(this, arguments);
  }

  ListViewTool.prototype.registerListView = function(lV) {
    this.lV = lV;
    return assert(this.lV instanceof ListView, "ListViewTool.registerListView", "Only instance of ListView can be registered", {
      listView: this.lV
    });
  };

  ListViewTool.prototype.mousemoveEvent = function(ev, info) {
    this.info = info;
  };

  return ListViewTool;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var ListViewHoverTool,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewHoverTool = (function(superClass) {
  extend(ListViewHoverTool, superClass);

  function ListViewHoverTool() {
    return ListViewHoverTool.__super__.constructor.apply(this, arguments);
  }

  ListViewHoverTool.prototype.threshold = 5;

  ListViewHoverTool.prototype.mousemoveEvent = function(ev, info) {
    this.info = info;
    if (ev.isImmediatePropagationStopped()) {
      CUI.debug("prop is stopped");
      return;
    }
    if (this.__hasMarker) {
      this.removeMarker();
    }
    return this.mousemove(ev);
  };

  ListViewHoverTool.prototype.mousemove = function(ev) {
    return CUI.debug("ListViewHoverTool mousemove must be overwritten", ev);
  };

  ListViewHoverTool.prototype.startDrag = function(ev, $target, diff, movable) {
    return CUI.debug("ListViewHoverTool startDrag must be overwritten");
  };

  ListViewHoverTool.prototype.doDrag = function(ev, $target, diff, movable) {
    return CUI.debug("ListViewHoverTool doDrag must be overwritten");
  };

  ListViewHoverTool.prototype.endDrag = function() {
    return CUI.debug("ListViewHoverTool endDrag must be overwritten");
  };

  ListViewHoverTool.prototype.createMovableDiv = function(tname, transparent, css) {
    var md;
    md = this.appendMarker(tname, transparent, css);
    Events.listen({
      type: "mouseleave",
      node: md,
      call: (function(_this) {
        return function() {
          return _this.removeMarker();
        };
      })(this)
    });
    md.appendTo(this.lV.getGrid());
    new Movable({
      element: md,
      start_drag: (function(_this) {
        return function(ev, $target, diff, movable) {
          return _this.startDrag(ev, $target, diff, movable);
        };
      })(this),
      do_drag: (function(_this) {
        return function(ev, $target, diff, movable) {
          return _this.doDrag(ev, $target, diff, movable);
        };
      })(this),
      dragend: (function(_this) {
        return function(ev, globalDrag, movable) {
          _this.removeMarker(true);
          if (ev.getType() === "mouseup") {
            return _this.endDrag();
          }
        };
      })(this)
    });
    return md;
  };

  ListViewHoverTool.prototype.markRow = function(row_i) {
    var rect;
    if (row_i == null) {
      row_i = this.info.cell.row_i;
    }
    rect = this.lV.getRowGridRect(row_i);
    return this.appendMarker("row-marker", true, {
      top: rect.top,
      left: rect.left,
      width: rect.width,
      height: rect.height
    });
  };

  ListViewHoverTool.prototype.markCol = function(col_i) {
    var rect;
    if (col_i == null) {
      col_i = this.info.cell.col_i;
    }
    rect = this.lV.getCellGridRect(col_i, 0);
    return this.appendMarker("col-marker", true, {
      top: rect.top,
      left: rect.left,
      width: rect.width,
      height: this.lV.getGrid().height()
    });
  };

  ListViewHoverTool.prototype.appendMarker = function(tname, transparent, css) {
    var tmpl;
    if (transparent == null) {
      transparent = true;
    }
    if (css == null) {
      css = null;
    }
    tmpl = new Template({
      name: "list-view-tool-" + tname
    });
    tmpl.addClass("cui-list-view-tool cui-demo-node-copyable");
    if (transparent) {
      tmpl.addClass("cui-list-view-tool cui-drag-drop-select-transparent");
    }
    if (css) {
      tmpl.DOM.css(css);
    }
    tmpl.DOM.appendTo(this.lV.getGrid());
    this.__hasMarker = true;
    return tmpl.DOM;
  };

  ListViewHoverTool.prototype.removeMarker = function(force) {
    var el, i, len, ref;
    if (force == null) {
      force = false;
    }
    if (!force && globalDrag) {
      return false;
    }
    this.__hasMarker = false;
    ref = CUI.DOM.matchSelector(document.documentElement, ".cui-list-view-tool:not(.cui-demo-node-copy)");
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      el.remove();
    }
    return true;
  };

  return ListViewHoverTool;

})(ListViewTool);
// Generated by CoffeeScript 1.9.3
var ListViewRowMoveTool,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewRowMoveTool = (function(superClass) {
  extend(ListViewRowMoveTool, superClass);

  function ListViewRowMoveTool() {
    this.mousemove = bind(this.mousemove, this);
    return ListViewRowMoveTool.__super__.constructor.apply(this, arguments);
  }

  ListViewRowMoveTool.prototype.mousemove = function(ev) {
    var rect;
    if (!this.info.cell) {
      return;
    }
    if (ev.isImmediatePropagationStopped()) {
      return;
    }
    if (this.info.cell.display_row_i < this.lV.fixedRowsCount) {
      return;
    }
    if (this.info.$target.is(".cui-list-view-row-move-handle[allow-row-move]")) {
      if (!this.lV.getListViewRow(this.info.cell.row_i).isMovable(ev)) {
        return;
      }
      ev.stopImmediatePropagation();
      rect = this.lV.getCellGridRectByNode(this.info.$target);
      rect.width = this.lV.getGrid().width();
      this.movableDiv = this.createMovableDiv("row-move-marker", true, rect);
      Movable.getInstance(this.movableDiv[0]).init_drag(ev, this.movableDiv);
    }
  };

  ListViewRowMoveTool.prototype.startDrag = function() {
    this.movableTargetDiv = this.appendMarker("row-move-target");
    this.movableMarkers = this.markRow();
    return this.__rect_top = this.lV.getRowGridRect(this.lV.getRowIdx(this.lV.fixedRowsCount));
  };

  ListViewRowMoveTool.prototype.doDrag = function(ev, $target, diff, movable) {
    var cell, rect_bottom, x, y;
    x = 0;
    y = diff.y + movable.start.y;
    y = Math.max(y, this.__rect_top.top);
    rect_bottom = this.lV.getRowGridRect(this.lV.getRowIdx(this.lV.rowsCount - 1));
    y = Math.min(y, rect_bottom.top);
    movable.setElementCss({
      x: x,
      y: y
    });
    cell = this.lV.getCellByTarget($target);
    if (cell) {
      cell.clientX = ev.clientX();
      cell.clientY = ev.clientY();
      if (cell.display_row_i >= this.lV.fixedRowsCount) {
        this.showHorizontalTargetMarker(cell);
      }
    }
  };

  ListViewRowMoveTool.prototype.endDrag = function() {
    var source_node, target_node;
    if (!this.target) {
      return;
    }
    source_node = this.lV.getListViewRow(this.info.cell.row_i);
    target_node = this.lV.getListViewRow(this.target.row_i);
    if (source_node.moveRow) {
      return source_node.moveRow(this.lV, target_node, this.target.after);
    } else {
      return this.lV.moveRow(this.info.cell.row_i, this.target.row_i, this.target.after);
    }
  };

  ListViewRowMoveTool.prototype.showHorizontalTargetMarker = function(cell) {
    this.showHorizontalTargetMarkerSetTarget(cell);
    if (this.target.row_i === this.info.cell.row_i || (this.target.before_row_i === this.info.cell.row_i && this.target.after === false) || (this.target.after_row_i === this.info.cell.row_i && this.target.before === false)) {
      this.target = null;
      return this.movableTargetDiv.hide();
    } else {
      return this.movableTargetDiv.css({
        display: "block",
        left: this.target.left,
        top: this.target.top,
        width: this.target.width
      });
    }
  };

  ListViewRowMoveTool.prototype.showHorizontalTargetMarkerSetTarget = function(cell) {
    var diff, row_rect;
    this.target = {
      row_i: cell.row_i
    };
    row_rect = this.lV.getRowGridRect(cell.row_i);
    if (this.info.cell.display_row_i > 0) {
      this.target.before_row_i = this.lV.getRowIdx(this.info.cell.display_row_i - 1);
    }
    if (this.info.cell.display_row_i < this.lV.rowsCount - 1) {
      this.target.after_row_i = this.lV.getRowIdx(this.info.cell.display_row_i + 1);
    }
    diff = cell.clientY - row_rect.top_abs;
    if (diff < row_rect.height / 2) {
      this.target.after = false;
      this.target.top = row_rect.top;
    } else {
      this.target.after = true;
      this.target.top = row_rect.top + row_rect.height;
    }
    this.target.width = row_rect.width;
    this.target.left = row_rect.left;
  };

  return ListViewRowMoveTool;

})(ListViewHoverTool);
// Generated by CoffeeScript 1.9.3
var ListViewColResizeTool,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ListViewColResizeTool = (function(superClass) {
  extend(ListViewColResizeTool, superClass);

  function ListViewColResizeTool() {
    this.mousemove = bind(this.mousemove, this);
    return ListViewColResizeTool.__super__.constructor.apply(this, arguments);
  }

  ListViewColResizeTool.prototype.mousemove = function(ev) {
    var coldef, rect, resize;
    if (!this.info.cell) {
      return;
    }
    if (this.info.cell.row_i >= this.lV.fixedRowsCount) {
      return;
    }
    if (this.info.cell.pos.left <= this.threshold && this.info.cell.display_col_i > 0) {
      this.info.cell.col_i = this.lV.getColIdx(this.info.cell.display_col_i - 1);
      resize = true;
    }
    if (this.info.cell.pos.left >= this.lV.getColWidth(this.info.cell.col_i) - this.threshold || resize) {
      coldef = this.lV.getColdef(this.info.cell.col_i);
      if (coldef === "fixed") {
        return;
      }
      rect = this.lV.getCellGridRect(this.info.cell.col_i, this.info.cell.row_i);
      if (!rect) {
        return;
      }
      CUI.debug("ListViewColResizeTool:", "left:", this.info.cell.pos.left, "width:", rect.width, "threshold:", this.threshold);
      ev.stopImmediatePropagation();
      this.info.cell.width = rect.width;
      this.movableDiv = this.createMovableDiv("col-resize-marker", false, {
        left: rect.left + rect.width,
        top: 0,
        height: this.lV.getGrid().height()
      });
      return Events.listen({
        node: this.movableDiv,
        type: "dblclick",
        call: (function(_this) {
          return function(ev) {
            _this.movableDiv.remove();
            return _this.lV.resetColWidth(_this.info.cell.col_i);
          };
        })(this)
      });
    }
  };

  ListViewColResizeTool.prototype.startDrag = function(ev, $target, diff, movable) {
    this.new_width = null;
    return this.markedCol = this.markCol();
  };

  ListViewColResizeTool.prototype.doDrag = function(ev, $target, diff, movable) {
    var new_width, x, y;
    x = diff.x + movable.start.x;
    y = 0;
    new_width = diff.x + this.info.cell.width;
    if (new_width < 10) {
      this.new_width = 10;
      return;
    }
    this.markedCol.css({
      width: new_width
    });
    this.new_width = new_width;
    return movable.setElementCss({
      x: x,
      y: y
    });
  };

  ListViewColResizeTool.prototype.endDrag = function() {
    if (!this.new_width) {
      return;
    }
    return this.lV.setColWidth(this.info.cell.col_i, this.new_width);
  };

  return ListViewColResizeTool;

})(ListViewHoverTool);
// Generated by CoffeeScript 1.9.3
var ListViewTreeRowMoveTool,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ListViewTreeRowMoveTool = (function(superClass) {
  extend(ListViewTreeRowMoveTool, superClass);

  function ListViewTreeRowMoveTool() {
    return ListViewTreeRowMoveTool.__super__.constructor.apply(this, arguments);
  }

  ListViewTreeRowMoveTool.prototype.initOpts = function() {
    ListViewTreeRowMoveTool.__super__.initOpts.call(this);
    return this.addOpts({
      rowMoveWithinNodesOnly: {
        check: Boolean
      }
    });
  };

  ListViewTreeRowMoveTool.prototype.mousemove = function(ev) {
    var lvr;
    if (!this.info.cell) {
      return;
    }
    lvr = this.lV.getListViewRow(this.info.cell.row_i);
    if (!(lvr instanceof ListViewTreeNode)) {
      return;
    }
    return ListViewTreeRowMoveTool.__super__.mousemove.call(this, ev);
  };

  ListViewTreeRowMoveTool.prototype.startDrag = function() {
    var height, i, idx, len, lvr, ref, row, row_i;
    ListViewTreeRowMoveTool.__super__.startDrag.call(this);
    this.blockedRows = [this.info.cell.row_i];
    lvr = this.lV.getListViewRow(this.info.cell.row_i);
    height = this.lV.getRowHeight(lvr.getRowIdx());
    ref = lvr.getRowsToMove();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      row = ref[idx];
      row_i = row.getRowIdx();
      this.blockedRows.push(row_i);
      height += this.lV.getRowHeight(row_i);
      this.movableMarkers.push(this.markRow(row_i)[0]);
    }
    return this.movableDiv.css({
      height: height
    });
  };

  ListViewTreeRowMoveTool.prototype.showHorizontalTargetMarker = function(cell) {
    var ci, node;
    this.showHorizontalTargetMarkerSetTarget(cell);
    this.blockedAfterRows = [this.target.before_row_i];
    this.blockedBeforeRows = [this.target.after_row_i];
    node = this.lV.getListViewRow(this.info.cell.row_i);
    if ((ci = node.getChildIdx()) < node.father.children.length - 1) {
      this.blockedBeforeRows.push(node.father.children[ci + 1].getRowIdx());
    }
    if (!this.allowRowMove()) {
      this.target = null;
      return this.movableTargetDiv.hide();
    } else {
      return this.movableTargetDiv.css({
        display: "block",
        left: this.target.left,
        top: this.target.top,
        width: this.target.width,
        height: this.target.height
      });
    }
  };

  ListViewTreeRowMoveTool.prototype.allowRowMove = function() {
    var allow, from_node, new_father, ref, ref1, ref2, ref3, to_node;
    allow = true;
    if ((ref = this.target.row_i, indexOf.call(this.blockedRows, ref) >= 0) || ((ref1 = this.target.row_i, indexOf.call(this.blockedAfterRows, ref1) >= 0) && this.target.after) || ((ref2 = this.target.row_i, indexOf.call(this.blockedBeforeRows, ref2) >= 0) && !this.target.after)) {
      return false;
    }
    ref3 = this.lV.getNodesForMove(this.info.cell.row_i, this.target.row_i, this.target.after), from_node = ref3[0], to_node = ref3[1], new_father = ref3[2];
    if (this._rowMoveWithinNodesOnly && new_father) {
      return false;
    }
    if (!from_node.allowRowMove(to_node, new_father, this.target.after)) {
      return false;
    }
    return true;
  };

  return ListViewTreeRowMoveTool;

})(ListViewRowMoveTool);
// Generated by CoffeeScript 1.9.3
var ItemList,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.ItemList = (function(superClass) {
  extend(ItemList, superClass);

  function ItemList() {
    return ItemList.__super__.constructor.apply(this, arguments);
  }

  ItemList.prototype.init = function() {
    ItemList.__super__.init.call(this);
    this.addClass("cui-item-list");
    this.__body = new Template({
      name: "item-list-body"
    });
    return this.append(this.__body, "center");
  };

  ItemList.prototype.initOpts = function() {
    ItemList.__super__.initOpts.call(this);
    this.addOpts({
      items: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v) || CUI.isArray(v);
        }
      },
      active_item_idx: {
        check: "Integer"
      },
      has_items: {
        "default": false,
        check: Boolean
      },
      allow_null: {
        check: Boolean
      },
      onClick: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      orientation: {
        "default": "vertical",
        check: ["horizontal", "vertical"]
      }
    });
    return this;
  };

  ItemList.prototype.readOpts = function() {
    ItemList.__super__.readOpts.call(this);
    if (this._orientation === "horizontal") {
      CUI.error("new CUI.ItemList, orientation == horizontal needs implementation!");
    }
    return this;
  };

  ItemList.prototype.setActiveIdx = function(__active_idx) {
    this.__active_idx = __active_idx;
  };

  ItemList.prototype.getActiveIdx = function() {
    return this.__active_idx;
  };

  ItemList.prototype.getBody = function() {
    return this.__body;
  };

  ItemList.prototype.getItemByValue = function(value) {
    var btn, el, i, len, ref;
    ref = this.__body.DOM.children;
    for (i = 0, len = ref.length; i < len; i++) {
      el = ref[i];
      btn = DOM.data(el, "element");
      if (!(btn instanceof Button)) {
        continue;
      }
      if (btn.getValue() === value) {
        return btn;
      }
    }
    return null;
  };

  ItemList.prototype.hasItems = function(event) {
    var items;
    if (this._has_items) {
      return true;
    }
    items = this.__getItems(event);
    if (isPromise(items)) {
      CUI.warn("ItemList.hasItems: opts.items Function returned a Promise. Set opts.has_items to true, in order to avoid the call of that Function.");
      return true;
    } else {
      return items.length > 0;
    }
  };

  ItemList.prototype.__getItems = function(event) {
    if (CUI.isFunction(this._items)) {
      return this._items(event, this) || [];
    } else {
      return this._items;
    }
  };

  ItemList.prototype.getItems = function(event) {
    var items;
    items = this.__getItems(event);
    if (isPromise(items)) {
      return items;
    } else {
      return new CUI.Deferred().resolve(items);
    }
  };

  ItemList.prototype.__initActiveIdx = function() {
    var active_idx, i, idx, item, items, len;
    if (!isUndef(this.__active_idx)) {
      active_idx = this.__active_idx;
    } else {
      active_idx = this._active_item_idx;
    }
    if (isUndef(active_idx)) {
      items = this.__getItems();
      if (isPromise(items)) {
        active_idx = null;
      }
      for (idx = i = 0, len = items.length; i < len; idx = ++i) {
        item = items[idx];
        if (!item) {
          continue;
        }
        if (isUndef(item.active)) {
          continue;
        }
        if (item.active) {
          active_idx = idx;
          break;
        }
        if (isUndef(active_idx)) {
          active_idx = null;
        }
      }
    }
    if (!isUndef(active_idx)) {
      this.__active_idx = active_idx;
      this.__radio = "item-list--" + this.getUniqueId();
    }
    return this.__isInitActiveIdx = true;
  };

  ItemList.prototype.render = function(menu, event) {
    if (!this.__isInitActiveIdx) {
      this.__initActiveIdx();
    }
    this.__body.empty();
    return this.getItems(event).done((function(_this) {
      return function(items) {
        var _item, fn, i, idx, item, len, list_has_button_left, opt_keys;
        opt_keys = CUI.defaults["class"].Button.getOptKeys();
        list_has_button_left = false;
        fn = function(item, idx) {
          var btn, divider, j, k, label, len1, listenButtonClick, opts;
          if (!item || item.hidden === true || (typeof item.hidden === "function" ? item.hidden() : void 0)) {
            return;
          }
          if (item.divider) {
            divider = $div("cui-menu-divider cui-item-list-divider", {
              role: "menu-item"
            });
            _this.__body.append(divider);
            return;
          }
          if (item.label) {
            if (item.label instanceof Label) {
              label = item.label;
            } else if (CUI.isPlainObject(item.label)) {
              label = new CUI.defaults["class"].Label(item.label);
            } else {
              label = new CUI.defaults["class"].Label({
                text: item.label
              });
            }
            label.addClass("cui-menu-item");
            _this.__body.append(label.DOM);
            return;
          }
          if (item.content) {
            _this.__body.DOM.append(item.content.DOM || item.content);
            return;
          }
          listenButtonClick = function(btn) {
            Events.listen({
              type: "cui-button-click",
              node: btn,
              call: function(ev, info) {
                var dim, el, hide, ref;
                if ((ref = btn.getTooltip()) != null) {
                  ref.destroy();
                }
                if (typeof _this._onClick === "function") {
                  _this._onClick(info.event, btn, item, idx);
                }
                if (!(menu != null ? menu.isAutoCloseAfterClick() : void 0) || btn.hasMenu()) {
                  return;
                }
                hide = function() {
                  return menu.hideAll(info.event);
                };
                el = menu.getElement();
                if (el) {
                  dim = DOM.getDimensions(menu.getElement()[0]);
                  if (dim.clientWidth === 0 && dim.clientHeight === 0) {
                    hide();
                    return;
                  }
                }
                return CUI.setTimeout({
                  call: hide
                });
              }
            });
          };
          if (item instanceof Button) {
            listenButtonClick(item);
            if (CUI.__ng__) {
              item.removeClass("cui-button-button");
            }
            if (item.hasLeft()) {
              list_has_button_left = true;
            }
          }
          if (item instanceof Button || item instanceof DataField || item instanceof Label) {
            _this.__body.append(item.DOM);
            return;
          }
          opts = {
            role: "menu-item",
            radio: _this.__radio,
            radio_allow_null: _this._allow_null,
            onActivate: function(btn, flags) {
              if (_this.__radio) {
                _this.__active_idx = idx;
              }
              return typeof _this._onActivate === "function" ? _this._onActivate(btn, item, idx, flags) : void 0;
            },
            onDeactivate: function(btn, flags) {
              if (_this.__radio) {
                _this.__active_idx = null;
              }
              return typeof _this._onDeactivate === "function" ? _this._onDeactivate(btn, item, idx, flags) : void 0;
            }
          };
          for (j = 0, len1 = opt_keys.length; j < len1; j++) {
            k = opt_keys[j];
            if (item.hasOwnProperty(k) && !opts.hasOwnProperty(k)) {
              opts[k] = item[k];
            }
          }
          if (_this.__radio) {
            if (_this.__active_idx === idx) {
              opts.active = true;
            }
          }
          if (menu) {
            opts.menu_parent = menu;
          }
          btn = new CUI.defaults["class"].Button(opts);
          listenButtonClick(btn);
          if (btn.hasLeft()) {
            list_has_button_left = true;
          }
          _this.__body.append(btn);
        };
        for (idx = i = 0, len = items.length; i < len; idx = ++i) {
          _item = items[idx];
          if (CUI.isFunction(_item)) {
            item = _item(_this, menu, event);
          } else {
            item = _item;
          }
          fn(item, idx);
          if (list_has_button_left) {
            _this.__body.addClass("cui-item-list--has-button-left");
          } else {
            _this.__body.removeClass("cui-item-list--has-button-left");
          }
        }
      };
    })(this));
  };

  ItemList.prototype.destroy = function() {
    var ref;
    ItemList.__super__.destroy.call(this);
    return (ref = this.__body) != null ? ref.destroy() : void 0;
  };

  return ItemList;

})(CUI.VerticalLayout);

ItemList = CUI.ItemList;
// Generated by CoffeeScript 1.9.3
var Menu,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Menu = (function(superClass) {
  extend(Menu, superClass);

  function Menu(opts) {
    this.opts = opts != null ? opts : {};
    Menu.__super__.constructor.call(this, this.opts);
    if (this._itemList) {
      this.setItemList(this._itemList);
    }
  }

  Menu.prototype.initOpts = function() {
    Menu.__super__.initOpts.call(this);
    this.addOpts({
      itemList: {
        check: function(v) {
          return v instanceof CUI.ItemList || CUI.isPlainObject(v);
        }
      },
      auto_close_after_click: {
        "default": true,
        check: Boolean
      },
      parent_menu: {
        check: Menu
      },
      onBeforeItemListInit: {
        check: Function
      }
    });
    return this;
  };

  Menu.prototype.readOpts = function() {
    Menu.__super__.readOpts.call(this);
    if (!this.opts.placements) {
      if (this._parent_menu) {
        this._placements = ["es", "en", "ws", "wn"];
      } else if (this._show_at_position) {
        this._placements = ["es", "en", "ws", "wn"];
      } else {
        this._placements = ["se", "sw", "ne", "nw"];
      }
    }
    if (!this.opts.placement) {
      this._placement = this._placements[0];
    }
  };

  Menu.prototype.show = function(__event) {
    this.__event = __event;
    assert(!this.isDestroyed(), (getObjectClass(this)) + ".show", "Element is already destroyed.");
    if (!this.isShown() && this.__itemList) {
      this.__itemList.render(this, this.__event).done((function(_this) {
        return function() {
          return Events.trigger({
            type: "content-resize",
            node: _this.__itemList
          });
        };
      })(this));
    }
    Menu.__super__.show.call(this, this.__event);
    Events.listen({
      type: "keydown",
      instance: this,
      node: this.DOM,
      capture: true,
      call: (function(_this) {
        return function(ev) {
          if (ev.hasModifierKey()) {
            return;
          }
          if (ev.keyCode() === 27) {
            _this.hide();
            return ev.stop();
          }
        };
      })(this)
    });
    return this;
  };

  Menu.prototype.hasItems = function(event) {
    var ref;
    return (ref = this.__itemList) != null ? ref.hasItems(event) : void 0;
  };

  Menu.prototype.getItemList = function() {
    return this.__itemList;
  };

  Menu.prototype.setItemList = function(itemList) {
    if (itemList instanceof CUI.ItemList) {
      this.__itemList = itemList;
    } else {
      delete itemList.maximize;
      itemList.maximize_vertical = false;
      itemList.maximize_horizontal = true;
      this.__itemList = new CUI.ItemList(itemList);
    }
    this.replace(this.__itemList);
    this.proxy(this.__itemList, ["setActiveIdx"]);
    if (this.isShown()) {
      this.__itemList.render(this, this.__event).done((function(_this) {
        return function() {
          return _this.position();
        };
      })(this));
    }
    return this;
  };

  Menu.prototype.isAutoCloseAfterClick = function() {
    return this._auto_close_after_click;
  };

  Menu.prototype.destroy = function() {
    var ref;
    if ((ref = this.__itemList) != null) {
      ref.destroy();
    }
    return Menu.__super__.destroy.call(this);
  };

  Menu.prototype.hide = function(ev) {
    if (ev != null) {
      ev.preventDefault();
    }
    Menu.__super__.hide.call(this, ev);
    return this;
  };

  Menu.prototype.hideAll = function(ev) {
    var ref;
    this.hide(ev);
    if ((ref = this._parent_menu) != null) {
      ref.hideAll(ev);
    }
    return this;
  };

  Menu.prototype.getButton = function() {
    var ref;
    return DOM.data((ref = this.getElement()) != null ? ref[0] : void 0, "element");
  };

  return Menu;

})(CUI.Layer);

Menu = CUI.Menu;
// Generated by CoffeeScript 1.9.3
var Panel,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Panel = (function(superClass) {
  extend(Panel, superClass);

  function Panel(opts) {
    this.opts = opts != null ? opts : {};
    Panel.__super__.constructor.call(this, this.opts);
    this.panel = new Template({
      name: "panel",
      map: {
        header: true,
        content: true
      }
    });
    this.registerTemplate(this.panel);
    if (this._content_placeholder) {
      this.append(this._content_placeholder, "content");
      this.__has_placeholder = true;
    }
    if (CUI.isFunction(this._content)) {
      if (!this._load_on_open) {
        this.loadContent();
      }
    } else if (this._content) {
      this.append(this._content, "content");
    }
    this.button = new Button({
      text: this._text,
      "class": "cui-panel-header-button",
      radio: this._radio,
      radio_allow_null: true,
      icon_active: this._icon_opened,
      icon_inactive: this._icon_closed,
      onActivate: (function(_this) {
        return function(btn, flags, event) {
          _this.open();
          return typeof _this._onActivate === "function" ? _this._onActivate(btn, flags, event) : void 0;
        };
      })(this),
      onDeactivate: (function(_this) {
        return function(btn, flags, event) {
          _this.close();
          return typeof _this._onDeactivate === "function" ? _this._onDeactivate(btn, flags, event) : void 0;
        };
      })(this)
    });
    this.append(this.button, "header");
    if (this._closed) {
      this.button.deactivate();
    } else {
      this.button.activate();
    }
  }

  Panel.prototype.initOpts = function() {
    Panel.__super__.initOpts.call(this);
    return this.addOpts({
      text: {
        mandatory: true,
        check: String
      },
      content: {
        check: function(v) {
          return isContent(v) || isString(v);
        }
      },
      content_placeholder: {
        check: function(v) {
          return isContent(v);
        }
      },
      load_on_open: {
        check: Boolean
      },
      radio: {
        "default": "panel-switcher",
        check: function(v) {
          return isString(v) || v === true;
        }
      },
      closed: {
        "default": true,
        check: Boolean
      },
      icon_opened: {
        "default": "fa-angle-down",
        check: String
      },
      icon_closed: {
        "default": "fa-angle-right",
        check: String
      },
      footer_right: {},
      footer_left: {},
      onFirstActivate: {
        check: Function
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      }
    });
  };

  Panel.prototype.readOpts = function() {
    Panel.__super__.readOpts.call(this);
    return this;
  };

  Panel.prototype.isClosed = function() {
    return this.DOM.hasClass("cui-panel-closed");
  };

  Panel.prototype.isOpen = function() {
    return !this.isClosed();
  };

  Panel.prototype.close = function() {
    this.DOM.addClass("cui-panel-closed");
    return this;
  };

  Panel.prototype.open = function() {
    if (this._load_on_open && !this.__content_loaded) {
      this.loadContent();
    }
    this.DOM.removeClass("cui-panel-closed");
    return this;
  };

  Panel.prototype.loadContent = function() {
    var ret;
    if (CUI.isFunction(this._content)) {
      ret = this._content();
    } else {
      ret = this._content;
    }
    if (isPromise(ret)) {
      ret.always((function(_this) {
        return function(content) {
          return _this.setContent(content);
        };
      })(this));
    } else {
      this.setContent(ret);
    }
    this.__content_loaded = true;
    return this;
  };

  Panel.prototype.setContent = function(content, key) {
    if (key == null) {
      key = "content";
    }
    if (content === false && this._content_placeholder) {
      return this;
    }
    this.__has_placeholder = false;
    this.replace(content, key);
    return this;
  };

  Panel.prototype.appendContent = function(content, key) {
    if (key == null) {
      key = "content";
    }
    if (this.__has_placeholder) {
      this.setContent(content, key);
    } else {
      this.append(content, key);
    }
    return this;
  };

  return Panel;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var Input,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Input = (function(superClass) {
  extend(Input, superClass);

  function Input(opts1) {
    var hint, j, k, len1, ref;
    this.opts = opts1 != null ? opts1 : {};
    Input.__super__.constructor.call(this, this.opts);
    this.addClass("cui-input");
    if (this._overwrite) {
      this.__getCursorBlocks = this.__overwriteBlocks;
    } else {
      this.__getCursorBlocks = this._getCursorBlocks;
    }
    if (this._content_size) {
      this.addClass("cui-input-content-size");
    }
    if (this.isRequired()) {
      this.addClass("cui-input-required");
    }
    if (this._checkInput) {
      this.addClass("cui-input-has-check-input");
    }
    if (this._prevent_invalid_input) {
      this.addClass("cui-input-has-prevent-invalid-input");
    }
    this.__inputHints = {};
    this.__inputHintTexts = {};
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      hint = this["_" + k + "Hint"];
      if (!hint) {
        continue;
      }
      this.__inputHints[k];
      if (hint instanceof Label) {
        this.__inputHints[k] = hint;
      } else {
        this.__inputHints[k] = new CUI.defaults["class"].Label(hint);
      }
      this.__inputHints[k].addClass("cui-input-" + k + "-hint");
      this.__inputHintTexts[k] = this.__inputHints[k].getText();
      this.addClass("cui-input-has-" + k + "-hint");
    }
    return;
  }

  Input.prototype.initOpts = function() {
    Input.__super__.initOpts.call(this);
    return this.addOpts({
      spellcheck: {
        "default": false,
        check: Boolean
      },
      autocomplete: {
        "default": false,
        check: Boolean
      },
      overwrite: {
        check: Boolean
      },
      checkInput: {
        check: Function
      },
      getValueForDisplay: {
        check: Function
      },
      getValueForInput: {
        check: Function
      },
      correctValueForInput: {
        check: Function
      },
      emptyHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      invalidHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      validHint: {
        check: function(v) {
          return isString(v) || v instanceof Label || CUI.isPlainObject(v);
        }
      },
      onFocus: {
        check: Function
      },
      onClick: {
        check: Function
      },
      onKeyup: {
        check: Function
      },
      onSelectionchange: {
        check: Function
      },
      incNumbers: {
        "default": true,
        check: Boolean
      },
      onBlur: {
        check: Function
      },
      regexp: {
        check: String
      },
      regexp_flags: {
        "default": "",
        check: String
      },
      getInputBlocks: {
        check: Function
      },
      getCursorBlocks: {
        check: function(v) {
          return CUI.isFunction(v) && !this._overwrite;
        }
      },
      placeholder: {
        check: String
      },
      readonly: {
        check: Boolean
      },
      readonly_select_all: {
        "default": true,
        check: Boolean
      },
      textarea: {
        check: Boolean
      },
      content_size: {
        "default": false,
        check: Boolean
      },
      prevent_invalid_input: {
        "default": false,
        check: Boolean
      },
      required: {
        "default": false,
        check: Boolean
      }
    });
  };

  Input.prototype.readOpts = function() {
    if (!isEmpty(this.opts.regexp)) {
      assert(!this.opts.checkInput, "new Input", "opts.regexp conflicts with opts.checkInput.");
      assert(!this.opts.hasOwnProperty("prevent_invalid_input"), "new Input", "opts.prevent_invalid_input conflicts with opts.regexp.");
    }
    if (this.opts.readonly) {
      assert(!(this.opts.getCursorBlocks || this.opts.getInputBlocks || this.opts.checkInput), "new Input", "opts.readonly conflicts with opts.getCursorBlocks, opts.getInputBlocks, opts.checkInput.");
    }
    if (this.opts.textarea) {
      assert(!this.opts.autocomplete, "new Input", "opts.textarea does not work with opts.autocomplete", {
        opts: this.opts
      });
      assert(!this.opts.incNumbers, "new Input", "opts.textarea does not work with opts.incNumbers", {
        opts: this.opts
      });
    }
    Input.__super__.readOpts.call(this);
    if (this._readonly && this._readonly_select_all) {
      this._getCursorBlocks = (function(_this) {
        return function(v) {
          return [
            new InputBlock({
              start: 0,
              string: v
            })
          ];
        };
      })(this);
    }
    if (this._regexp) {
      this.__regexp = new RegExp(this._regexp, this._regexp_flags);
      this._prevent_invalid_input = false;
      this._checkInput = this.__checkInputRegexp;
    }
    if (this._required && !this._checkInput) {
      this._checkInput = (function(_this) {
        return function(opts) {
          return opts.value.trim().lengt > 0;
        };
      })(this);
    }
    if (this._spellcheck === false) {
      this.__spellcheck = "false";
    } else {
      this.__spellcheck = "default";
    }
    if (this._autocomplete === true) {
      this.__autocomplete = "on";
    } else if (this._autocomplete === false) {
      this.__autocomplete = "off";
    }
    return this;
  };

  Input.prototype.__checkInputRegexp = function(value) {
    if (this.__regexp.exec(value)) {
      return true;
    } else {
      return false;
    }
  };

  Input.prototype.setSpellcheck = function(spellcheck) {
    if (spellcheck) {
      return DOM.setAttribute(this.__input0, "spellcheck", "default");
    } else {
      return DOM.setAttribute(this.__input0, "spellcheck", "false");
    }
  };

  Input.prototype.setPlaceholder = function(placeholder) {
    return DOM.setAttribute(this.__input[0], "placeholder", placeholder);
  };

  Input.prototype.__createElement = function(input_type) {
    var oldSizes, size;
    if (input_type == null) {
      input_type = "text";
    }
    if (this._textarea === true) {
      this.__input = $element("textarea", "cui-textarea", {
        placeholder: this._placeholder,
        tabindex: "0",
        id: "cui-input-" + this.getUniqueId(),
        spellcheck: this.__spellcheck
      });
    } else {
      if (CUI.__ng__) {
        size = 1;
      } else {
        size = void 0;
      }
      this.__input = $element("input", "cui-input", {
        type: input_type,
        size: size,
        placeholder: this._placeholder,
        tabindex: "0",
        id: "cui-input-" + this.getUniqueId(),
        spellcheck: this.__spellcheck,
        autocomplete: this.__autocomplete
      });
    }
    Events.listen({
      node: this.__input,
      type: "dragstart",
      call: function(ev) {
        return ev.preventDefault();
      }
    });
    Events.listen({
      node: this.__input,
      type: "keydown",
      call: (function(_this) {
        return function(ev) {
          var ref, ref1, ref2;
          _this.lastKeyDownEvent = ev;
          if (_this._incNumbers && !_this._textarea && !_this._readonly) {
            _this.incNumberBounds(ev);
          }
          if ((ref = ev.keyCode()) === 37 || ref === 39 || ref === 36 || ref === 35) {
            _this.moveCursor(ev);
            _this.showCursor(ev);
            return;
          }
          if ((ref1 = ev.keyCode()) === 9 || ref1 === 16 || ref1 === 17 || ref1 === 18 || ref1 === 27 || ref1 === 33 || ref1 === 34 || ref1 === 35 || ref1 === 36 || ref1 === 38 || ref1 === 40) {
            return;
          }
          if (!_this._textarea && ev.keyCode() === 13) {
            return;
          }
          if (ev.keyCode() === 8 && (0 === (ref2 = _this.__input0.selectionStart) && ref2 === _this.__input0.selectionEnd)) {
            return;
          }
          _this.__focusShadowInput();
        };
      })(this)
    });
    Events.listen({
      type: "keyup",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var ref;
          if ((ref = ev.keyCode()) === 37 || ref === 39 || ref === 36 || ref === 35) {
            ev.preventDefault();
            if (!_this.cursor) {
              _this.showCursor(ev);
            }
            return;
          }
          _this.initCursor(ev);
          _this.showCursor(ev);
          if (_this._onKeyup) {
            _this._onKeyup(_this, ev);
          }
        };
      })(this)
    });
    Events.listen({
      type: "focus",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var ref;
          if (_this.hasShadowFocus()) {
            return;
          }
          _this.__enterInput();
          _this.addClass("cui-has-focus");
          _this.__initShadowInput();
          if (typeof _this._onFocus === "function") {
            _this._onFocus(_this, ev);
          }
          if ((ref = _this.__invalidTooltip) != null) {
            ref.show();
          }
          _this.__setCursor(ev);
        };
      })(this)
    });
    oldSizes = null;
    Events.listen({
      type: "mousedown",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          var mev, trigger;
          oldSizes = [_this.__input0.offsetWidth, _this.__input0.offsetHeight];
          trigger = function() {
            if (oldSizes[0] !== _this.__input0.offsetWidth || oldSizes[1] !== _this.__input0.offsetHeight) {
              return Events.trigger({
                type: "content-resize",
                node: _this.__input
              });
            }
          };
          mev = Events.listen({
            type: "mousemove",
            call: function() {
              trigger();
            }
          });
          return Events.listen({
            type: "mouseup",
            only_once: true,
            capture: true,
            call: function(ev) {
              Events.ignore(mev);
            }
          });
        };
      })(this)
    });
    Events.listen({
      type: "mouseup",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          _this.__setCursor(ev);
        };
      })(this)
    });
    Events.listen({
      type: "blur",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          if (_this.hasShadowFocus()) {
            return;
          }
          _this.removeClass("cui-has-focus");
          _this.__leaveInput();
          _this.__removeShadowInput();
          if (typeof _this._onBlur === "function") {
            _this._onBlur(_this, ev);
          }
        };
      })(this)
    });
    Events.listen({
      type: "input",
      node: this.__input,
      call: (function(_this) {
        return function(ev, info) {
          if (!ev.isDefaultPrevented()) {
            _this.checkInput();
            _this.moveCursor(ev);
            _this.showCursor(ev);
            _this.storeValue(_this.__input0.value);
          }
        };
      })(this)
    });
    Events.listen({
      type: "paste",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          return _this.__focusShadowInput();
        };
      })(this)
    });
    Events.listen({
      type: "click",
      node: this.__input,
      call: (function(_this) {
        return function(ev) {
          ev.stopPropagation();
          if (typeof _this._onClick === "function") {
            _this._onClick(_this, ev);
          }
        };
      })(this)
    });
    this.__input0 = this.__input[0];
    if (this._content_size) {
      DOM.waitForDOMInsert({
        node: this.__input
      }).done((function(_this) {
        return function() {
          if (_this.isDestroyed()) {
            return;
          }
          return _this.setContentSize();
        };
      })(this));
    }
    return this.__input;
  };

  Input.prototype.__setCursor = function(ev) {
    return CUI.setTimeout((function(_this) {
      return function() {
        var block, blocks, j, len1, s;
        _this.initCursor(ev);
        if (_this.cursor === null && (s = _this.__input0.selectionStart) === _this.__input0.selectionEnd && _this.__input0.selectionEnd !== _this.__input0.value.length) {
          blocks = _this.getInputBlocks();
          if (blocks.length > 0) {
            for (j = 0, len1 = blocks.length; j < len1; j++) {
              block = blocks[j];
              if ((block.start <= s && s <= block.end)) {
                _this.markBlock(ev, block);
                break;
              }
            }
          }
        }
        return _this.showCursor(ev);
      };
    })(this), 0);
  };

  Input.prototype.handleSelectionChange = function() {
    var ref;
    return (ref = this._onSelectionchange) != null ? ref.apply(this, arguments) : void 0;
  };

  Input.prototype.getElement = function() {
    return this.__input;
  };

  Input.prototype.getUniqueIdForLabel = function() {
    return "cui-input-" + this.getUniqueId();
  };

  Input.prototype.markBlock = function(ev, bl) {
    this.__input0.setSelectionRange(bl.start, bl.end);
    return this.initCursor(ev);
  };

  Input.prototype.remove = function() {
    this.__removeShadowInput();
    return Input.__super__.remove.call(this);
  };

  Input.prototype.__focusShadowInput = function() {
    if (!this.__shadow) {
      return;
    }
    this.__shadow_focused = true;
    this.__shadow0.value = this.__input0.value;
    this.__shadow0.focus();
    return this.__shadow0.setSelectionRange(this.__input0.selectionStart, this.__input0.selectionEnd);
  };

  Input.prototype.__unfocusShadowInput = function() {
    if (!this.hasShadowFocus()) {
      return;
    }
    this.setContentSize();
    this.__input0.focus();
    this.showCursor();
    return this.__shadow_focused = false;
  };

  Input.prototype.hasShadowFocus = function() {
    return this.__shadow_focused;
  };

  Input.prototype.setContentSize = function() {
    if (!this._content_size) {
      return this;
    }
    if (this.__contentSize) {
      this.__setContentSize();
    } else {
      this.__initContentSize();
      this.__setContentSize();
      this.__removeContentSize();
    }
    return this;
  };

  Input.prototype.__initContentSize = function() {
    var correct_height, css, j, k, len1, ref, style;
    if (this.__contentSize) {
      return;
    }
    this.__contentSize = $element("textarea", "cui-input-shadow", {
      tabindex: "-1"
    });
    this.__contentSize.appendTo(document.body);
    this.__contentSize0 = this.__contentSize[0];
    style = window.getComputedStyle(this.__input0);
    css = {};
    ref = ["fontFamily", "fontKerning", "fontSize", "wordBreak", "wordSpacing", "wordWrap", "fontStretch", "lineHeight", "fontStyle", "fontVariant", "fontVariantLigatures", "fontWeight"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      css[k] = style[k];
    }
    if (!this._textarea) {
      css.whiteSpace = "nowrap";
    }
    this.__contentSize.css(css);
    DOM.height(this.__contentSize, 1);
    if (this._textarea) {
      DOM.width(this.__contentSize, DOM.width(this.__contentSize));
      this.__max_height = parseInt(this.__input.css("max-height"));
      this.__input0.style.overflow = "hidden";
      if (isNaN(this.__max_height)) {
        this.__max_height = null;
      } else {
        correct_height = parseInt(this.__input.css("height")) - DOM.height(this.__input);
        this.__max_height -= correct_height;
      }
    } else {
      DOM.width(this.__contentSize, 1);
    }
    return this;
  };

  Input.prototype.__setContentSize = function() {
    var changed, h, previous_height, w;
    this.__contentSize0.value = this.__input0.value;
    if (this.hasShadowFocus()) {
      this.__contentSize0.focus();
    }
    changed = false;
    if (this._textarea) {
      if (this.__input0.value.length === 0) {
        this.__contentSize0.value = "A";
      }
      if (DOM.width(this.__input) !== DOM.width(this.__contentSize)) {
        DOM.width(this.__contentSize, DOM.width(this.__input));
      }
      h = this.__contentSize0.scrollHeight;
      if (this.__max_height === null || h <= this.__max_height) {
        this.__input0.style.overflow = "hidden";
      } else {
        this.__input0.style.overflow = "";
      }
      previous_height = DOM.height(this.__input);
      DOM.height(this.__input, h);
      if (DOM.height(this.__input) !== previous_height) {
        changed = true;
      }
    } else {
      w = this.__contentSize0.scrollWidth;
      if (this.__contentSize0.value.length === 0) {
        w = 1;
      } else {
        w = w + 1;
      }
      if (DOM.width(this.__input) !== w) {
        changed = true;
      }
      DOM.width(this.__input, w);
    }
    if (changed) {
      Events.trigger({
        type: "content-resize",
        node: this.__input
      });
    }
    return this;
  };

  Input.prototype.checkBlocks = function(blocks) {
    var b, idx, j, len1;
    if (!CUI.isArray(blocks)) {
      return false;
    }
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      b = blocks[idx];
      assert(b instanceof InputBlock, "Input.getInputBlocks", "Block[" + idx + "] needs to be instance of InputBlock.", {
        blocks: blocks,
        block: b
      });
      b.idx = idx;
    }
    return blocks;
  };

  Input.prototype.getInputBlocks = function() {
    var blocks;
    if (this._getInputBlocks) {
      blocks = this._getInputBlocks(this.__input0.value);
    } else if (this._getCursorBlocks) {
      blocks = this._getCursorBlocks(this.__input0.value);
    } else {
      blocks = this.__getInputBlocks(this.__input0.value);
    }
    return this.checkBlocks(blocks);
  };

  Input.prototype.__getInputBlocks = function(v) {
    var blocks, char_1_before, char_2_before, match, match_start, match_str, re;
    blocks = [];
    v = this.__input0.value;
    re = /[0-9]+/g;
    blocks = [];
    while ((match = re.exec(v)) !== null) {
      match_str = match[0];
      match_start = match.index;
      if (match_start > 0) {
        char_1_before = v.substr(match_start - 1, 1);
      } else {
        char_1_before = null;
      }
      if (match_start > 1) {
        char_2_before = v.substr(match_start - 2, 1);
      } else {
        char_2_before = null;
      }
      if (char_1_before === "-" && !(char_2_before != null ? char_2_before.match(/[0-9]/) : void 0)) {
        match_str = "-" + match_str;
        match_start -= 1;
      }
      blocks.push(new NumberInputBlock({
        start: match_start,
        string: match_str
      }));
    }
    return blocks;
  };

  Input.prototype.__overwriteBlocks = function(v) {
    var blocks, i, j, ref;
    blocks = [];
    for (i = j = 0, ref = v.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      blocks.push(new InputBlock({
        start: i,
        string: v.substr(i, 1)
      }));
    }
    blocks.push(new InputBlock({
      start: v.length,
      string: ""
    }));
    return blocks;
  };

  Input.prototype.getMarkedBlock = function() {
    var block, blocks, e, idx, j, len1, s;
    blocks = this.getInputBlocks();
    if (blocks === false || blocks.length === 0) {
      return null;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      block = blocks[idx];
      if (block.start === s && block.end === e) {
        return block;
      }
    }
    return null;
  };

  Input.prototype.getSelection = function() {
    var e, s;
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    return {
      start: s,
      end: e,
      value: this.__input0.value,
      before: this.__input0.value.substring(0, s),
      selected: this.__input0.value.substring(s, e),
      after: this.__input0.value.substring(e)
    };
  };

  Input.prototype.setSelection = function(selection) {
    this.__input0.selectionStart = selection.start;
    return this.__input0.selectionEnd = selection.end;
  };

  Input.prototype.updateSelection = function(txt) {
    var end, sel, start;
    if (txt == null) {
      txt = "";
    }
    sel = this.getSelection();
    this.setValue(sel.before + txt + sel.after);
    start = sel.before.length;
    end = start + txt.length;
    if (sel.start === sel.end) {
      start = end;
    }
    return this.setSelection({
      start: start,
      end: end
    });
  };

  Input.prototype.setValue = function(v, flags) {
    var ref;
    if (flags == null) {
      flags = {};
    }
    if (!this.hasData()) {
      if ((ref = this.__input0) != null) {
        ref.value = v;
      }
      this.setContentSize();
    }
    return Input.__super__.setValue.call(this, v, flags);
  };

  Input.prototype.incNumberBounds = function(ev) {
    var bl, block, block_jump_to, block_move, blocks, e, idx, j, l, last_block, len1, len2, len3, m, new_str, new_value, parts_inbetween, ref, ref1, s, v;
    if ((ref = ev.keyCode()) !== 38 && ref !== 40 && ref !== 9 && ref !== 33 && ref !== 34) {
      return;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    v = this.__input0.value;
    blocks = this.getInputBlocks();
    if (blocks === false || blocks.length === 0) {
      return;
    }
    parts_inbetween = [v.substring(0, blocks[0].start)];
    for (idx = j = 0, len1 = blocks.length; j < len1; idx = ++j) {
      block = blocks[idx];
      if (idx === blocks.length - 1) {
        break;
      }
      parts_inbetween.push(v.substring(block.end, blocks[idx + 1].start));
    }
    last_block = blocks[blocks.length - 1];
    parts_inbetween.push(v.substring(last_block.end));
    block_move = 0;
    if ((ref1 = ev.keyCode()) === 9 || ref1 === 33 || ref1 === 34) {
      if (ev.shiftKey() || ev.keyCode() === 33) {
        block_move = -1;
      } else {
        block_move = 1;
      }
    }
    for (idx = l = 0, len2 = blocks.length; l < len2; idx = ++l) {
      block = blocks[idx];
      if (block.start === s && block.end === e) {
        if (block_move) {
          block_jump_to = idx + block_move;
          break;
        }
        if (ev.keyCode() === 38) {
          block.incrementBlock(block, blocks);
        } else {
          block.decrementBlock(block, blocks);
        }
        block_jump_to = idx;
        break;
      }
      if ((s === e || (this.cursor && this.cursor.start === this.cursor.end)) && (block.start <= s && s <= block.end)) {
        block_jump_to = idx;
        continue;
      }
    }
    if (block_move && s === 0 && e === v.length && blocks.length > 1) {
      if (block_move === -1) {
        block_jump_to = blocks.length - 1;
      } else {
        block_jump_to = 0;
      }
    }
    if (bl = blocks[block_jump_to]) {
      new_str = [parts_inbetween[0]];
      for (idx = m = 0, len3 = blocks.length; m < len3; idx = ++m) {
        block = blocks[idx];
        new_str.push(block.string);
        new_str.push(parts_inbetween[idx + 1]);
      }
      new_value = new_str.join("");
      if (!this.checkInput(new_value)) {
        ev.preventDefault();
        return;
      }
      this.__input0.value = new_value;
      this.markBlock(ev, bl);
      this.storeValue(this.__input0.value);
      ev.preventDefault();
    }
  };

  Input.prototype.__removeContentSize = function() {
    var ref;
    if ((ref = this.__contentSize) != null) {
      ref.remove();
    }
    this.__contentSize = null;
    this.__contentSize0 = null;
    return this;
  };

  Input.prototype.__removeShadowInput = function() {
    var ref;
    this.__removeContentSize();
    if ((ref = this.__shadow) != null) {
      ref.remove();
    }
    this.__shadow = null;
    this.__shadow_focused = false;
    return this;
  };

  Input.prototype.preventInvalidInput = function() {
    if (this._checkInput && this._prevent_invalid_input) {
      return true;
    } else {
      return false;
    }
  };

  Input.prototype.__initShadowInput = function() {
    if (!(this.preventInvalidInput() || this._content_size || this._correctValueForInput || this._readonly)) {
      return;
    }
    if (this.__shadow) {
      return;
    }
    if (this._textarea) {
      this.__shadow = $element("textarea", "cui-input-shadow");
    } else {
      this.__shadow = $element("input", "cui-input-shadow", {
        type: "text"
      });
    }
    this.__shadow.prop("tabindex", "-1");
    this.__shadow.appendTo(document.body);
    this.__shadow0 = this.__shadow[0];
    if (this._content_size) {
      this.__initContentSize();
    }
    Events.listen({
      type: "input",
      node: this.__shadow,
      call: (function(_this) {
        return function(ev) {
          _this.__shadowInput(ev);
          _this.__unfocusShadowInput();
          new CUI.Event({
            type: "input",
            node: _this.__input
          }).dispatch();
        };
      })(this)
    });
    Events.listen({
      type: "keyup",
      node: this.__shadow,
      call: (function(_this) {
        return function(ev) {
          _this.__unfocusShadowInput();
        };
      })(this)
    });
    return this;
  };

  Input.prototype.__shadowInput = function(ev) {
    var ret, shadow_v;
    shadow_v = this.__shadow0.value;
    if (this.preventInvalidInput() && shadow_v.length > 0) {
      ret = this.checkInput(this.correctValueForInput(shadow_v));
      console.debug("checking shadow input", ret, shadow_v);
      if (ret === false) {
        return;
      }
    }
    if (!this._readonly) {
      this.__input0.value = this.correctValueForInput(shadow_v);
      this.__input0.setSelectionRange(this.__shadow0.selectionStart, this.__shadow0.selectionEnd);
    }
    this.initCursor(ev);
  };

  Input.prototype.checkValue = function(v) {
    if (!isString(v) || null) {
      throw new Error(this.__cls + ".checkValue(value): Value needs to be String or null.");
    }
    return this;
  };

  Input.prototype.render = function() {
    var j, k, len1, ref;
    Input.__super__.render.call(this);
    this.replace(this.__createElement(), this.getTemplateKeyForRender());
    this.append(this.getChangedMarker(), this.getTemplateKeyForRender());
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      this.append(this.__inputHints[k], this.getTemplateKeyForRender());
    }
    return this;
  };

  Input.prototype.getTemplateKeyForRender = function() {
    return null;
  };

  Input.prototype.isRequired = function() {
    return this._required;
  };

  Input.prototype.updateInputState = function(__inputState) {
    var j, k, len1, ref, ref1, ref2, ref3, state;
    this.__inputState = __inputState != null ? __inputState : this.__inputState;
    if (this.hasUserInput()) {
      this.addClass("cui-input-has-user-input");
      this.removeClass("cui-input-has-no-user-input");
    } else {
      this.removeClass("cui-input-has-user-input");
      this.addClass("cui-input-has-no-user-input");
    }
    state = this.getInputState();
    switch (state) {
      case "empty":
      case "valid":
        this.removeClass("cui-input-invalid");
        break;
      case "invalid":
        this.addClass("cui-input-invalid");
    }
    ref = ["empty", "invalid", "valid"];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      k = ref[j];
      DOM.hideElement((ref1 = this.__inputHints[k]) != null ? ref1.DOM[0] : void 0);
    }
    if (!this.hasUserInput() && state === "invalid") {
      DOM.showElement((ref2 = this.__inputHints.empty) != null ? ref2.DOM[0] : void 0);
    } else {
      DOM.showElement((ref3 = this.__inputHints[state]) != null ? ref3.DOM[0] : void 0);
    }
    return this;
  };

  Input.prototype.getInputState = function() {
    if (this.__inputState !== false) {
      return "valid";
    }
    if (this.hasUserInput() || this.isRequired()) {
      return "invalid";
    }
    return "empty";
  };

  Input.prototype.__leaveInput = function() {
    this.__input0.value = this.getValueForDisplay();
    return this.checkInput();
  };

  Input.prototype.__enterInput = function() {
    this.__input0.value = this.getValueForInput();
    return this.checkInput();
  };

  Input.prototype.hasUserInput = function() {
    return this.__input0.value.length > 0;
  };

  Input.prototype.checkInput = function(value) {
    var state;
    state = this.__checkInputInternal(value);
    if (!this.hasShadowFocus()) {
      this.updateInputState(state);
    }
    return state;
  };

  Input.prototype.__checkInputInternal = function(value) {
    if (value == null) {
      value = this.__input0.value;
    }
    if (this._checkInput) {
      return this._checkInput(value);
    } else {
      return true;
    }
  };

  Input.prototype.setInputHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.input) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.setInvalidHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.invalid) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.setValidHint = function(txt) {
    var ref;
    return (ref = this.__inputHints.valid) != null ? ref.setText(txt) : void 0;
  };

  Input.prototype.displayValue = function() {
    Input.__super__.displayValue.call(this);
    this.__input0.value = this.getValueForDisplay();
    this.checkInput();
    return this;
  };

  Input.prototype.getValueForDisplay = function() {
    if (this._getValueForDisplay) {
      return this._getValueForDisplay(this, this.getValue());
    } else {
      return this.getValue();
    }
  };

  Input.prototype.getValueForInput = function() {
    if (this._getValueForInput) {
      return this._getValueForInput(this, this.getValue());
    } else {
      return this.getValue();
    }
  };

  Input.prototype.correctValueForInput = function(value) {
    if (this._correctValueForInput) {
      return this._correctValueForInput(this, value);
    } else {
      return value;
    }
  };

  Input.prototype.getDefaultValue = function() {
    return "";
  };

  Input.prototype.getValue = function() {
    var ref;
    if (this.hasData()) {
      return Input.__super__.getValue.call(this);
    } else {
      return (ref = this.__input0) != null ? ref.value : void 0;
    }
  };

  Input.prototype.enable = function() {
    var ref;
    Input.__super__.enable.call(this);
    return (ref = this.__input) != null ? ref.prop("disabled", false) : void 0;
  };

  Input.prototype.disable = function() {
    var ref;
    Input.__super__.disable.call(this);
    return (ref = this.__input) != null ? ref.prop("disabled", true) : void 0;
  };

  Input.prototype.focus = function() {
    var ref;
    return (ref = this.__input0) != null ? ref.focus() : void 0;
  };

  Input.prototype.getCursorBlocks = function() {
    var blocks;
    blocks = typeof this.__getCursorBlocks === "function" ? this.__getCursorBlocks(this.__input0.value) : void 0;
    return this.checkBlocks(blocks);
  };

  Input.prototype.findBlock = function(blocks, idx, cut) {
    var block, j, len1, ref;
    for (j = 0, len1 = blocks.length; j < len1; j++) {
      block = blocks[j];
      if ((idx === (ref = block.start) && ref === block.end)) {
        return block;
      }
      if (cut === "full" && idx >= block.start && idx <= block.end) {
        return block;
      }
      if (cut === "left" && idx >= block.start && idx < block.end) {
        return block;
      }
      if (cut === "right" && idx > block.start && idx <= block.end) {
        return block;
      }
      if (cut === "touch" && idx >= block.start && idx <= block.end) {
        return block;
      }
    }
    return null;
  };

  Input.prototype.initCursor = function(ev) {
    var block_left, block_right, blocks, dist_left, dist_right, e, i, j, l, len, range, ref, ref1, ref2, ref3, ref4, ref5, ref6, s;
    blocks = this.getCursorBlocks();
    if (blocks === false) {
      this.cursor = null;
      return;
    }
    if (blocks.length === 0) {
      CUI.warn("initCursor: 0 cursor blocks");
      this.cursor = null;
      return;
    }
    s = this.__input0.selectionStart;
    e = this.__input0.selectionEnd;
    len = this.__input0.value.length;
    this.cursor = {
      shift: (ref = this.cursor) != null ? ref.shift : void 0,
      start: null,
      end: null
    };
    if (ev.getType() === "keyup" && ev.keyCode() === 16) {
      this.cursor.shift = null;
    }
    if (ev.getType() === "keydown" && ((ref1 = ev.keyCode()) === 46 || ref1 === 8)) {
      this.cursor.shift = null;
    }
    if (isUndef(this.cursor.shift)) {
      this.cursor.shift = null;
    }
    this.cursor.start = this.findBlock(blocks, s, "left");
    this.cursor.end = this.findBlock(blocks, e, "right");
    if (((ref2 = this.cursor.end) != null ? ref2.idx : void 0) < ((ref3 = this.cursor.start) != null ? ref3.idx : void 0)) {
      this.cursor.end = this.cursor.start;
    }
    if (s === e && !this.cursor.start && !this.cursor.end) {
      dist_left = null;
      dist_right = null;
      for (i = j = ref4 = s; j >= 0; i = j += -1) {
        block_left = this.findBlock(blocks, i, "left");
        if (block_left) {
          dist_left = s - i;
          break;
        }
      }
      for (i = l = ref5 = s, ref6 = len; l < ref6; i = l += 1) {
        block_right = this.findBlock(blocks, i, "left");
        if (block_right) {
          dist_right = i - s;
          break;
        }
      }
      if (block_right && !block_left) {
        this.cursor.start = block_right;
      } else if (block_left && !block_right) {
        this.cursor.start = block_left;
      } else if (block_left && block_right) {
        if (dist_left > dist_right) {
          this.cursor.start = block_right;
        } else {
          this.cursor.start = block_left;
        }
      }
    }
    range = this.getRangeFromCursor();
    if (!this.cursor.start && !this.cursor.end) {
      this.cursor.start = this.cursor.end = blocks[blocks.length - 1];
    } else if (!this.cursor.start) {
      this.cursor.start = this.cursor.end;
    } else if (!this.cursor.end) {
      this.cursor.end = this.cursor.start;
    }
    if (range[0] === s && range[1] === e) {
      1;
    }
  };

  Input.prototype.showCursor = function(ev) {
    var r;
    if (this.cursor) {
      r = this.getRangeFromCursor();
      this.__input0.setSelectionRange(r[0], r[1]);
    }
    return this;
  };

  Input.prototype.checkSelectionChange = function() {
    var sel;
    sel = this.getSelection();
    if (this.__currentSelection && (this.__currentSelection.start !== sel.start || this.__currentSelection.end !== sel.end)) {
      this.handleSelectionChange();
    }
    this.__currentSelection = sel;
    return this;
  };

  Input.prototype.getRangeFromCursor = function() {
    var ref, ref1;
    return [(ref = this.cursor.start) != null ? ref.start : void 0, (ref1 = this.cursor.end) != null ? ref1.end : void 0];
  };

  Input.prototype.moveCursor = function(ev) {
    var blocks, c_idx, e_idx, left, right, s_idx;
    if (!this.cursor) {
      return;
    }
    ev.preventDefault();
    blocks = this.getCursorBlocks();
    if (blocks === false || blocks.length === 0) {
      this.cursor = null;
      return;
    }
    if (ev.keyCode() === 36) {
      this.cursor.start = blocks[0];
      this.cursor.end = blocks[0];
      return;
    }
    if (ev.keyCode() === 35) {
      this.cursor.start = blocks[blocks.length - 1];
      this.cursor.end = blocks[blocks.length - 1];
      return;
    }
    if (this.lastKeyDownEvent.keyCode() === 46) {
      this.initCursor(this.lastKeyDownEvent);
      return;
    }
    if (this.lastKeyDownEvent.keyCode() === 8) {
      this.initCursor(this.lastKeyDownEvent);
      return;
    }
    left = ev.keyCode() === 37;
    right = ev.keyCode() === 39 || ev.getType() === "input";
    s_idx = this.cursor.start.idx;
    e_idx = this.cursor.end.idx;
    if (!blocks[s_idx] || !blocks[e_idx]) {
      CUI.warn("repositioning cursor, not executing cursor move");
      this.initCursor(ev);
      return;
    }
    if (ev.keyCode() === 46) {
      return;
    }
    if (ev.shiftKey() && this.cursor.shift === null) {
      this.cursor.shift = this.cursor.end.idx;
    }
    if (this.cursor.shift === null) {
      if (s_idx === e_idx) {
        if (left) {
          if (s_idx > 0) {
            this.cursor.start = blocks[s_idx - 1];
          }
        } else if (right) {
          if (s_idx < blocks.length - 1) {
            this.cursor.start = blocks[s_idx + 1];
          }
        }
        this.cursor.end = this.cursor.start;
      } else if (left) {
        this.cursor.end = this.cursor.start;
      } else if (right) {
        this.cursor.start = this.cursor.end;
      }
    } else {
      c_idx = this.cursor.shift;
      if (left) {
        if (c_idx >= e_idx) {
          if (s_idx > 0) {
            this.cursor.start = blocks[s_idx - 1];
          }
        } else {
          this.cursor.end = blocks[e_idx - 1];
        }
      } else if (right) {
        if (c_idx > s_idx) {
          this.cursor.start = blocks[s_idx + 1];
        } else {
          if (e_idx < blocks.length - 1) {
            this.cursor.end = blocks[e_idx + 1];
          }
        }
      }
    }
    return this;
  };

  Input.prototype.destroy = function() {
    this.__removeShadowInput();
    return Input.__super__.destroy.call(this);
  };

  Input.uniqueId = 0;

  return Input;

})(CUI.DataFieldInput);

Input = CUI.Input;
// Generated by CoffeeScript 1.9.3
var MarkdownInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MarkdownInput = (function(superClass) {
  extend(MarkdownInput, superClass);

  function MarkdownInput() {
    return MarkdownInput.__super__.constructor.apply(this, arguments);
  }

  MarkdownInput.prototype.initOpts = function() {
    MarkdownInput.__super__.initOpts.call(this);
    this.removeOpt("textarea");
    return this.addOpts({
      preview: {
        check: Boolean
      },
      preview_ms: {
        "default": 500,
        check: (function(_this) {
          return function(v) {
            return v >= 0;
          };
        })(this)
      },
      renderFunction: {
        mandatory: true,
        "default": (function(_this) {
          return function(md) {
            return marked(md);
          };
        })(this),
        check: Function
      }
    });
  };

  MarkdownInput.prototype.readOpts = function() {
    var i, k, len1, ref, vl_opts;
    MarkdownInput.__super__.readOpts.call(this);
    this._textarea = true;
    this.__preview = null;
    this.__updatePreview = (function(_this) {
      return function() {
        return _this.updatePreview();
      };
    })(this);
    vl_opts = {
      top: {}
    };
    ref = ["maximize", "maximize_horizontal", "maximize_vertical"];
    for (i = 0, len1 = ref.length; i < len1; i++) {
      k = ref[i];
      if (this.hasSetOpt(k)) {
        vl_opts[k] = this.getSetOpt(k);
      }
    }
    return this.__verticalLayout = new Pane(vl_opts);
  };

  MarkdownInput.prototype.initTemplate = function() {
    return this.registerTemplate(this.__verticalLayout.getLayout());
  };

  MarkdownInput.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  MarkdownInput.prototype.encloseSelection = function(char) {
    var len, rows, sel;
    sel = this.getSelection();
    len = char.length;
    rows = sel.selected.split("\n");
    if (rows.length > 1) {
      return;
    }
    if (sel.selected.startsWith(char) && sel.selected.endsWith(char)) {
      this.setValue(sel.before + sel.selected.substr(len, sel.selected.length - len * 2) + sel.after);
      return this.setSelection({
        start: sel.start,
        end: sel.end - len * 2
      });
    } else {
      this.setValue(sel.before + char + sel.selected + char + sel.after);
      return this.setSelection({
        start: sel.start,
        end: sel.end + len * 2
      });
    }
  };

  MarkdownInput.prototype.makeOrderedList = function() {
    return this.__makeList(false);
  };

  MarkdownInput.prototype.makeUnorderedList = function() {
    return this.__makeList(true);
  };

  MarkdownInput.prototype.checkList = function() {
    var type;
    type = this.__makeList(null, true);
    return console.debug("selection is type", type);
  };

  MarkdownInput.prototype.__makeList = function(ul, check_only) {
    var i, is_ul, item, len1, match, new_rows, prefix, row, rows, sel, space;
    if (ul == null) {
      ul = true;
    }
    if (check_only == null) {
      check_only = false;
    }
    sel = this.getSelection();
    rows = sel.selected.split("\n");
    if (sel.before !== "" && !sel.before.endsWith("\n")) {
      return null;
    }
    space = null;
    if (check_only) {
      is_ul = void 0;
    } else if (ul) {
      prefix = "- ";
    } else {
      prefix = "1. ";
    }
    new_rows = [];
    for (i = 0, len1 = rows.length; i < len1; i++) {
      row = rows[i];
      console.debug("row:", row);
      if (row.trim().length === 0) {
        new_rows.push(row);
        continue;
      }
      match = row.match(/^(\s*)([0-9]+\.|\*|\-|)(\s*)(.*)$/);
      console.debug("match", row, match);
      if (!match) {
        console.warn("No match, not making list.", row);
        return null;
      }
      if (space === null) {
        space = match[1];
        item = match[2];
        if (item !== "") {
          is_ul = isNaN(parseInt(item));
        } else {
          is_ul = null;
        }
        if (is_ul !== null && !xor(is_ul, ul)) {
          prefix = "";
        }
        console.debug("rowcriteria.", space.length, item);
      } else if (match[1] !== space) {
        new_rows.push(row.substring(match[1].length - space.length));
        console.debug("row not matching space criteria.");
        continue;
      }
      if (!check_only) {
        new_rows.push(space + prefix + match[4]);
      }
    }
    if (check_only) {
      if (is_ul === null) {
        return "nolist";
      } else if (is_ul === true) {
        return "ul";
      } else if (is_ul === false) {
        return "ol";
      } else {
        return null;
      }
    }
    return this.updateSelection(new_rows.join("\n"));
  };

  MarkdownInput.prototype.handleSelectionChange = function(ev) {
    var sel;
    MarkdownInput.__super__.handleSelectionChange.call(this, ev);
    sel = this.getSelection();
    console.debug("md selection change", ev, dump(sel));
    return this.checkList();
  };

  MarkdownInput.prototype.render = function() {
    var bb;
    MarkdownInput.__super__.render.call(this);
    bb = new Toolbar({
      left: {
        content: [
          {
            group: "lists",
            icon: "fa-list-ul",
            onClick: (function(_this) {
              return function() {
                return _this.makeUnorderedList();
              };
            })(this)
          }, {
            group: "lists",
            icon: "fa-list-ol",
            onClick: (function(_this) {
              return function() {
                return _this.makeOrderedList();
              };
            })(this)
          }, {
            text: "*",
            onClick: (function(_this) {
              return function() {
                return _this.encloseSelection("*");
              };
            })(this)
          }, {
            text: "**",
            onClick: (function(_this) {
              return function() {
                return _this.encloseSelection("**");
              };
            })(this)
          }, {
            text: "SC",
            onClick: (function(_this) {
              return function() {
                return _this.handleSelectionChange();
              };
            })(this)
          }
        ]
      }
    });
    this.__verticalLayout.append(bb, "top");
    return this;
  };

  MarkdownInput.prototype.storeValue = function(value, flags) {
    var ret;
    if (flags == null) {
      flags = {};
    }
    ret = MarkdownInput.__super__.storeValue.call(this, value, flags);
    if (!this.__preview) {
      return ret;
    }
    if (this._preview_ms === 0) {
      this.updatePreview();
    } else {
      CUI.scheduleCallback({
        ms: this._preview_ms,
        call: this.__updatePreview
      });
    }
    return ret;
  };

  MarkdownInput.prototype.getPreview = function() {
    if (!this.__preview) {
      this.__preview = DOM.element("div", {
        "class": "cui-markdown-input-preview"
      });
      this.updatePreview();
    }
    return this.__preview;
  };

  MarkdownInput.prototype.updatePreview = function() {
    return this.__preview.innerHTML = this.renderHTML();
  };

  MarkdownInput.prototype.renderHTML = function() {
    return this._renderFunction(this.getElement().value);
  };

  MarkdownInput.__escape_regexp = new RegExp('[\\' + ('*-_\\![]()'.split("").join("\\")) + ']', 'g');

  MarkdownInput.escape = function(obj) {
    var k, new_obj, ref, v;
    assert((ref = typeof obj) === "string" || ref === "object", "MarkdownInput.escape", "Object needs to be typof 'string' or 'object'.", {
      obj: obj
    });
    if (typeof obj === "string") {
      return obj.replace(this.__escape_regexp, "\\$&");
    }
    new_obj = {};
    for (k in obj) {
      v = obj[k];
      new_obj[k] = this.escape(v);
    }
    return new_obj;
  };

  return MarkdownInput;

})(Input);
// Generated by CoffeeScript 1.9.3
var FileUploadFile,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileUploadFile = (function(superClass) {
  extend(FileUploadFile, superClass);

  function FileUploadFile(opts) {
    this.opts = opts != null ? opts : {};
    FileUploadFile.__super__.constructor.call(this, this.opts);
    this.__progress = {
      status: "CREATED",
      total: this._file.size,
      loaded: 0,
      percent: null
    };
    this.__dfr = new CUI.Deferred();
    this.__promise = this.__dfr.promise();
  }

  FileUploadFile.prototype.initOpts = function() {
    FileUploadFile.__super__.initOpts.call(this);
    return this.addOpts({
      file: {
        mandatory: true,
        check: function(v) {
          return v instanceof File;
        }
      },
      fileUpload: {
        mandatory: true,
        check: FileUpload
      },
      batch: {
        check: function(v) {
          return v >= 0;
        }
      },
      onRemove: {
        check: Function
      },
      onDequeue: {
        check: Function
      },
      onBeforeDone: {
        check: Function
      }
    });
  };

  FileUploadFile.prototype.queue = function() {
    this.__progress.status = "QUEUED";
    this.__dfr.notify(this);
    return this;
  };

  FileUploadFile.prototype.getImage = function() {
    var img;
    if (this.__imgDiv) {
      return this.__imgDiv;
    }
    img = $img()[0];
    img.src = window.URL.createObjectURL(this._file);
    img.onload = (function(_this) {
      return function(ev) {
        if (img.width < img.height) {
          _this.__imgDiv.removeClass("landscape");
          _this.__imgDiv.addClass("portrait");
        }
        return window.URL.revokeObjectURL(img.src);
      };
    })(this);
    return this.__imgDiv = $div("cui-file-upload-file-img").addClass("landscape").append($div().append(img));
  };

  FileUploadFile.prototype.getFile = function() {
    return this._file;
  };

  FileUploadFile.prototype.getFileUpload = function() {
    return this._fileUpload;
  };

  FileUploadFile.prototype.getPromise = function() {
    return this.__promise;
  };

  FileUploadFile.prototype.getBatch = function() {
    return this._batch;
  };

  FileUploadFile.prototype.getName = function() {
    return this._file.name;
  };

  FileUploadFile.prototype.getStatus = function() {
    return this.__progress.status;
  };

  FileUploadFile.prototype.getError = function() {
    return this.__progress.fail;
  };

  FileUploadFile.prototype.getErrorXHR = function() {
    return this.__progress.fail_xhr;
  };

  FileUploadFile.prototype.getData = function() {
    return this.__progress.data;
  };

  FileUploadFile.prototype.getProgress = function() {
    return this.__progress;
  };

  FileUploadFile.prototype.getPercent = function() {
    return this.__progress.percent;
  };

  FileUploadFile.prototype.getInfo = function() {
    var s;
    s = this.getStatus();
    if (s === "PROGRESS" || s === "COMPLETED") {
      return (this.getPercent() || 0) + "%";
    }
    return s;
  };

  FileUploadFile.prototype.abort = function() {
    switch (this.getStatus()) {
      case "CREATED":
      case "QUEUED":
        this.__progress.status = "ABORT";
        this.__dfr.reject(this);
        break;
      case "STARTED":
      case "PROGRESS":
      case "COMPLETED":
        CUI.debug("FileUploadFile.abort:", this.__upload);
        this.__upload.abort();
        break;
      case "ABORT":
      case "DEQUEUED":
    }
    return this;
  };

  FileUploadFile.prototype.dequeue = function() {
    this.__progress.status = "DEQUEUED";
    if (typeof this._onDequeue === "function") {
      this._onDequeue(this);
    }
    return this;
  };

  FileUploadFile.prototype.remove = function() {
    if (this.isDone()) {
      this.dequeue();
    } else {
      this.abort();
    }
    this._fileUpload.removeFile(this);
    if (typeof this._onRemove === "function") {
      this._onRemove(this);
    }
    return this;
  };

  FileUploadFile.prototype.isDone = function() {
    var ref;
    return (ref = this.__progress.status) !== "CREATED" && ref !== "QUEUED" && ref !== "STARTED" && ref !== "PROGRESS" && ref !== "COMPLETED";
  };

  FileUploadFile.prototype.isUploading = function() {
    return !!this.__upload;
  };

  FileUploadFile.prototype.upload = function(url, name) {
    var form, onDone;
    assert(!this.__upload, "FileUploadFile.upload", "A file can only be uploaded once.", {
      file: this
    });
    form = {};
    form[name] = this._file;
    onDone = (function(_this) {
      return function() {};
    })(this);
    this.__upload = new CUI.XHR({
      url: url,
      form: form
    });
    this.__upload.start().progress((function(_this) {
      return function(type, loaded, total, percent) {
        if (type === "download") {
          return;
        }
        if (_this.__progress.status === "ABORT") {
          return;
        }
        if (loaded === total) {
          _this.__progress.status = "COMPLETED";
        } else {
          _this.__progress.status = "PROGRESS";
        }
        _this.__progress.loaded = loaded;
        _this.__progress.total = total;
        _this.__progress.percent = percent;
        return _this.__dfr.notify(_this);
      };
    })(this)).done((function(_this) {
      return function(data) {
        _this.__progress.data = data;
        onDone = function() {
          _this.__progress.status = "DONE";
          _this.__upload = null;
          return _this.__dfr.resolve(_this);
        };
        if (_this._onBeforeDone) {
          return CUI.decide(_this._onBeforeDone(_this)).done(onDone).fail(function() {
            _this.__progress.status = "ABORT";
            _this.__upload = null;
            return _this.__dfr.reject(_this);
          });
        } else {
          return onDone();
        }
      };
    })(this)).fail((function(_this) {
      return function(data, status, statusText) {
        CUI.warn("FileUploadFile.fail", status, statusText);
        if (statusText === "abort") {
          _this.__progress.status = "ABORT";
        }
        if (_this.__progress.status !== "ABORT") {
          _this.__progress.status = "FAILED";
        }
        _this.__progress.fail = _this.__upload.response();
        _this.__progress.fail_xhr = _this.__upload.getXHR();
        _this.__upload = null;
        return _this.__dfr.reject(_this);
      };
    })(this));
    this.__progress.status = "STARTED";
    this.__progress.percent = 0;
    this.__dfr.notify(this);
    return this.__promise;
  };

  return FileUploadFile;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var FileUploadButton,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileUploadButton = (function(superClass) {
  extend(FileUploadButton, superClass);

  function FileUploadButton(opts) {
    this.opts = opts != null ? opts : {};
    this.__onClick = bind(this.__onClick, this);
    FileUploadButton.__super__.constructor.call(this, this.opts);
    this.addClass("cui-button");
    if (this._drop) {
      this._fileUpload.initDropZone({
        dropZone: this.DOM
      });
    }
  }

  FileUploadButton.prototype.initOpts = function() {
    FileUploadButton.__super__.initOpts.call(this);
    return this.addOpts({
      fileUpload: {
        mandatory: true,
        check: FileUpload
      },
      multiple: {
        "default": true,
        check: Boolean
      },
      directory: {
        check: Boolean
      },
      drop: {
        check: Boolean
      }
    });
  };

  FileUploadButton.prototype.getTemplateName = function() {
    this.__has_left = true;
    this.__has_right = true;
    if (CUI.__ng__) {
      return "file-upload-button-ng";
    } else {
      return "file-upload-button";
    }
  };

  FileUploadButton.prototype.readOpts = function() {
    this.__ownClick = this.opts.onClick;
    this.opts.onClick = this.__onClick;
    return FileUploadButton.__super__.readOpts.call(this);
  };

  FileUploadButton.prototype.__onClick = function(ev, btn) {
    var ref, uploadBtn;
    if ((ref = this.__ownClick) != null) {
      ref.call(this, ev, btn);
    }
    if (ev.isDefaultPrevented() || ev.isImmediatePropagationStopped()) {
      return;
    }
    uploadBtn = document.getElementById("cui-file-upload-button");
    uploadBtn.form.reset();
    this._fileUpload.initFilePicker({
      directory: (ev.altKey() || ev.shiftKey() && this._multiple) || this._directory,
      multiple: this._multiple,
      fileUpload: uploadBtn
    });
  };

  return FileUploadButton;

})(Button);

CUI.ready((function(_this) {
  return function() {
    return CUI.DOM.append(document.body, CUI.DOM.htmlToNodes("<!-- CUI.FileUploadButton --><form style=\"display:none;\"><input type=\"file\" id=\"cui-file-upload-button\"></input></form><!-- /CUI.FileUploadButton -->"));
  };
})(this));
// Generated by CoffeeScript 1.9.3
var FileUpload,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

FileUpload = (function(superClass) {
  extend(FileUpload, superClass);

  function FileUpload(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FileUpload.__super__.constructor.call(this, this.opts);
    this.__files = [];
    this.__dropZones = [];
    this.__batch_id = 0;
    this.__batches_done = 0;
  }

  FileUpload.prototype.initOpts = function() {
    FileUpload.__super__.initOpts.call(this);
    return this.addOpts({
      url: {
        mandatory: true,
        check: String
      },
      name: {
        "default": CUI.defaults.FileUpload.name,
        check: String
      },
      parallel: {
        "default": 2,
        check: function(v) {
          return v >= 1;
        }
      },
      onAdd: {
        check: Function
      },
      onBatchQueued: {
        check: Function
      },
      onBatchDone: {
        check: Function
      },
      onProgress: {
        check: Function
      },
      onDone: {
        check: Function
      },
      onUpdate: {
        check: Function
      },
      onDequeue: {
        check: Function
      },
      onRemove: {
        check: Function
      },
      onFail: {
        check: Function
      },
      onAlways: {
        check: Function
      },
      onBeforeDone: {
        check: Function
      }
    });
  };

  FileUpload.prototype.readOpts = function() {
    FileUpload.__super__.readOpts.call(this);
    return this.setUrl(this._url);
  };

  FileUpload.prototype.setUrl = function(__url) {
    this.__url = __url;
    return this.__url;
  };

  FileUpload.prototype.getUrl = function() {
    return this.__url;
  };

  FileUpload.prototype.getFiles = function(filter) {
    var file, files, i, len, ref, ref1;
    if (isString(filter)) {
      filter = [filter];
    }
    files = [];
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      file = ref[i];
      if (!filter || (ref1 = file.getStatus(), indexOf.call(filter, ref1) >= 0)) {
        files.push(file);
      }
    }
    return files;
  };

  FileUpload.prototype.getInfo = function() {
    var _fuf, _p, all_done, count, done, i, info, len, loaded, ref, s, status, total;
    status = {};
    total = 0;
    loaded = 0;
    count = 0;
    done = 0;
    all_done = true;
    ref = this.getFiles();
    for (i = 0, len = ref.length; i < len; i++) {
      _fuf = ref[i];
      _p = _fuf.getProgress();
      s = _p.status;
      if (!status[s]) {
        status[s] = 1;
      } else {
        status[s]++;
      }
      if (!_fuf.isDone()) {
        all_done = false;
      } else {
        done += 1;
      }
      total += _p.total;
      loaded += _p.loaded;
      count += 1;
    }
    return info = {
      status: status,
      total: total,
      count: count,
      done: done,
      loaded: loaded,
      percent: Math.floor(loaded / total * 100),
      all_done: all_done
    };
  };

  FileUpload.prototype.getUploadFileClass = function() {
    return FileUploadFile;
  };

  FileUpload.prototype.queueFiles = function(files) {
    var batch, idx, next_file;
    batch = ++this.__batch_id;
    idx = -1;
    next_file = (function(_this) {
      return function() {
        var cls, dont_queue_file, f, file, queue_file;
        idx++;
        if (idx === files.length) {
          if (typeof _this._onBatchQueued === "function") {
            _this._onBatchQueued();
          }
          _this.uploadNextFiles();
          return;
        }
        file = files[idx];
        cls = _this.getUploadFileClass();
        f = new cls({
          file: file,
          fileUpload: _this,
          batch: batch,
          onBeforeDone: _this._onBeforeDone,
          onDequeue: function(f) {
            if (typeof _this._onDequeue === "function") {
              _this._onDequeue(f);
            }
            return typeof _this._onUpdate === "function" ? _this._onUpdate(f) : void 0;
          },
          onRemove: function(f) {
            return typeof _this._onRemove === "function" ? _this._onRemove(f) : void 0;
          }
        });
        f.getPromise().progress(function() {
          if (typeof _this._onProgress === "function") {
            _this._onProgress(f);
          }
          return typeof _this._onUpdate === "function" ? _this._onUpdate(f) : void 0;
        }).done(function() {
          if (typeof _this._onDone === "function") {
            _this._onDone(f);
          }
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          return _this.uploadNextFiles();
        }).fail(function() {
          if (typeof _this._onFail === "function") {
            _this._onFail(f);
          }
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          return _this.uploadNextFiles();
        }).always(function() {
          if (typeof _this._onAlways === "function") {
            _this._onAlways(f);
          }
          return _this.checkBatchDone(f);
        });
        dont_queue_file = function() {
          CUI.debug("FileUpload.onAdd: Skipping file, function returned 'false'.");
          return next_file();
        };
        queue_file = function() {
          _this.__files.push(f);
          if (typeof _this._onUpdate === "function") {
            _this._onUpdate(f);
          }
          f.queue();
          return next_file();
        };
        return CUI.decide(typeof _this._onAdd === "function" ? _this._onAdd(f) : void 0).done(function() {
          return queue_file();
        }).fail(function() {
          return dont_queue_file();
        });
      };
    })(this);
    next_file();
    return this;
  };

  FileUpload.prototype.clear = function() {
    var file;
    while (file = this.__files[0]) {
      file.remove();
    }
    return this;
  };

  FileUpload.prototype.removeFile = function(file) {
    return removeFromArray(file, this.__files);
  };

  FileUpload.prototype.isUploading = function() {
    var f, i, len, ref;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.isUploading()) {
        return true;
      }
    }
    return false;
  };

  FileUpload.prototype.uploadNextFiles = function() {
    var f, file, files, i, j, len, len1, ref, slots;
    files = [];
    slots = this._parallel;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getStatus() === "QUEUED") {
        files.push(f);
        slots--;
      }
      if (f.isUploading()) {
        slots--;
      }
      if (slots === 0) {
        break;
      }
    }
    for (j = 0, len1 = files.length; j < len1; j++) {
      file = files[j];
      this.uploadFile(file);
    }
    return this;
  };

  FileUpload.prototype.uploadFile = function(file) {
    return file.upload(this.getUrl(), this._name);
  };

  FileUpload.prototype.checkBatchDone = function(file) {
    var alarm, f, i, len, ref;
    alarm = false;
    ref = this.__files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getBatch() !== file.getBatch()) {
        continue;
      }
      if (!f.isDone()) {
        return;
      }
      alarm = true;
    }
    if (alarm) {
      if (typeof this._onBatchDone === "function") {
        this._onBatchDone();
      }
    }
  };

  FileUpload.prototype.initDropZone = function(opts) {
    var dropZone, dz, i, len, multiple, ref, ref1, selector;
    if (opts == null) {
      opts = {};
    }
    dropZone = (ref = opts.dropZone) != null ? ref.DOM : void 0;
    if (!dropZone) {
      dropZone = opts.dropZone;
    }
    selector = opts.selector;
    if (opts.multiple === false) {
      multiple = false;
    } else {
      multiple = true;
    }
    assert(isElement(dropZone) || isElement(dropZone != null ? dropZone.DOM : void 0), "FileUpload.initDropZone", "Drop Zone needs to be instanceof HTMLElement or contain such an element in its property \"DOM\".", {
      dropZone: dropZone
    });
    Events.ignore({
      instance: this
    });
    dropZone.classList.add("cui-file-upload-drop-zone");
    Events.listen({
      node: dropZone,
      type: ["dragover"],
      instance: this,
      selector: selector,
      call: (function(_this) {
        return function(ev) {
          FileUpload.setDropClassByEvent(ev);
          ev.stopPropagation();
          ev.preventDefault();
          return false;
        };
      })(this)
    });
    Events.listen({
      node: dropZone,
      type: "drop",
      instance: this,
      selector: selector,
      call: (function(_this) {
        return function(ev) {
          var dt, file, files, ref1;
          FileUpload.setDropClassByEvent(ev);
          dt = ev.getNativeEvent().dataTransfer;
          if (((ref1 = dt.files) != null ? ref1.length : void 0) > 0) {
            files = (function() {
              var i, len, ref2, results;
              ref2 = dt.files;
              results = [];
              for (i = 0, len = ref2.length; i < len; i++) {
                file = ref2[i];
                results.push(file);
              }
              return results;
            })();
            if (multiple === false) {
              files.splice(1);
            }
            _this.queueFiles(files);
          }
          ev.stopPropagation();
          ev.preventDefault();
          return false;
        };
      })(this)
    });
    ref1 = this.__dropZones;
    for (i = 0, len = ref1.length; i < len; i++) {
      dz = ref1[i];
      if (dz === dropZone[0]) {
        return this;
      }
    }
    this.__dropZones.push(dropZone[0]);
    return this;
  };

  FileUpload.setDropClassByEvent = function(ev) {
    var el, ref;
    el = ev.getCurrentTarget();
    switch (ev.getType()) {
      case "dragover":
        CUI.clearTimeout(this.__dropElementTimeout);
        if ((ref = this.__dropElement) != null) {
          ref.classList.remove("cui-file-upload-drag-over");
        }
        el.classList.add("cui-file-upload-drag-over");
        this.__dropElement = el;
        this.__dropElementTimeout = CUI.setTimeout({
          ms: 500,
          call: (function(_this) {
            return function() {
              el.classList.remove("cui-file-upload-drag-over");
              return delete _this.__dropElement;
            };
          })(this)
        });
        ev.getNativeEvent().dataTransfer.dropEffect = "copy";
        break;
      case "drop":
        el.classList.remove("cui-file-upload-drag-over");
    }
    return this;
  };

  FileUpload.prototype.initFilePicker = function(opts) {
    var dfr, i, inp, k, len, ref;
    inp = opts.fileUpload;
    ref = ["webkitdirectory", "mozdirectory", "directory"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (opts.directory) {
        DOM.setAttribute(inp, k, true);
      } else {
        DOM.removeAttribute(inp, k);
      }
    }
    if (opts.multiple) {
      DOM.setAttribute(inp, "multiple", true);
    } else {
      DOM.removeAttribute(inp, "multiple");
    }
    dfr = new CUI.Deferred();
    Events.ignore({
      node: inp
    });
    Events.listen({
      type: "change",
      node: inp,
      call: (function(_this) {
        return function() {
          var file, files;
          files = (function() {
            var j, len1, ref1, results;
            ref1 = inp.files;
            results = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              file = ref1[j];
              results.push(file);
            }
            return results;
          })();
          _this.queueFiles(files);
          inp.form.reset();
          dfr.resolve();
        };
      })(this)
    });
    return dfr.promise();
  };

  FileUpload.prototype.resetDropZones = function() {
    var dz, i, len, ref;
    Events.ignore({
      instance: this
    });
    ref = this.__dropZones;
    for (i = 0, len = ref.length; i < len; i++) {
      dz = ref[i];
      $(dz).removeClass("cui-file-upload-drop-zone");
    }
    this.__dropZones = [];
    return this;
  };

  FileUpload.prototype.destroy = function() {
    this.resetDropZones();
    FileUpload.__super__.destroy.call(this);
    return this;
  };

  return FileUpload;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.FileReader = (function(superClass) {
  extend(FileReader, superClass);

  function FileReader() {
    return FileReader.__super__.constructor.apply(this, arguments);
  }

  FileReader.prototype.initOpts = function() {
    FileReader.__super__.initOpts.call(this);
    return this.removeOpt("url");
  };

  FileReader.prototype.readOpts = function() {
    return CUI.Element.prototype.readOpts.call(this);
  };

  FileReader.prototype.getUploadFileClass = function() {
    return FileReaderFile;
  };

  FileReader.prototype.uploadFile = function(file) {
    CUI.debug("filereader upload file", file);
    return file.upload(file);
  };

  return FileReader;

})(FileUpload);
// Generated by CoffeeScript 1.9.3
var FileReaderFile,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FileReaderFile = (function(superClass) {
  extend(FileReaderFile, superClass);

  function FileReaderFile() {
    return FileReaderFile.__super__.constructor.apply(this, arguments);
  }

  FileReaderFile.prototype.initOpts = function() {
    FileReaderFile.__super__.initOpts.call(this);
    return this.addOpts({
      format: {
        mandatory: true,
        "default": "Text",
        check: ["ArrayBuffer", "Text"]
      }
    });
  };

  FileReaderFile.prototype.upload = function(file) {
    var fn, i, key, len, ref;
    this.__reader = new FileReader();
    ref = ["loadStart", "progress", "abort", "error", "load", "loadend"];
    fn = (function(_this) {
      return function(key) {
        return _this.__reader.addEventListener(key.toLowerCase(), function(ev) {
          return _this["__event_" + key](ev);
        });
      };
    })(this);
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      fn(key);
    }
    switch (this._format) {
      case "Text":
        this.__reader.readAsText(this._file);
        break;
      case "ArrayBuffer":
        this.__reader.readAsArrayBuffer(this._file);
    }
  };

  FileReaderFile.prototype.getDataAsUtf8String = function() {
    return CUI.utf8ArrayBufferToString(this.getData());
  };

  FileReaderFile.prototype.getDataAsBytes = function() {
    return String.fromCharCode.apply(null, new Uint8Array(this.getData()));
  };

  FileReaderFile.prototype.__event_loadStart = function() {
    this.__progress.status = "STARTED";
    this.__progress.percent = 0;
    this.__dfr.notify(this);
  };

  FileReaderFile.prototype.__event_progress = function(ev) {
    var loaded, percent, total;
    total = ev.total;
    loaded = ev.loaded;
    if (ev.lengthComputable) {
      percent = Math.floor(ev.loaded / ev.total * 100);
    } else {
      percent = -1;
    }
    if (loaded === total) {
      this.__progress.status = "COMPLETED";
    } else {
      this.__progress.status = "PROGRESS";
    }
    this.__progress.loaded = loaded;
    this.__progress.total = total;
    this.__progress.percent = percent;
    this.__dfr.notify(this);
  };

  FileReaderFile.prototype.__event_abort = function() {};

  FileReaderFile.prototype.__event_error = function() {};

  FileReaderFile.prototype.__event_load = function() {};

  FileReaderFile.prototype.__event_loadend = function() {
    this.__progress.data = this.__reader.result;
    this.__progress.status = "DONE";
    this.__upload = null;
    return this.__dfr.resolve(this);
  };

  FileReaderFile.prototype.abort = function() {
    return this.__reader.abort();
  };

  return FileReaderFile;

})(FileUploadFile);
// Generated by CoffeeScript 1.9.3
var InputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

InputBlock = (function(superClass) {
  extend(InputBlock, superClass);

  function InputBlock(opts) {
    this.opts = opts != null ? opts : {};
    InputBlock.__super__.constructor.call(this, this.opts);
    this.__start = this._start;
    this.setString(this._string);
  }

  InputBlock.prototype.initOpts = function() {
    InputBlock.__super__.initOpts.call(this);
    return this.addOpts({
      start: {
        mandatory: true,
        check: function(v) {
          return isInteger(v) && v >= 0;
        }
      },
      string: {
        mandatory: true,
        check: function(v) {
          return isString(v);
        }
      }
    });
  };

  InputBlock.prototype.setString = function(s) {
    assert(isString(s), (getObjectClass(this)) + ".setString", "Parameter needs to be String with a minimum length of 1.", {
      string: s
    });
    this.__string = s;
    this.calcSizes();
    return this;
  };

  InputBlock.prototype.getString = function() {
    return this._string;
  };

  InputBlock.prototype.calcSizes = function() {
    var i, k, len, ref;
    this.__len = this.__string.length;
    this.__end = this.__start + this.__len;
    ref = ["len", "end", "start", "string"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this[k] = this["__" + k];
    }
    return this;
  };

  InputBlock.prototype.incrementBlock = function(block, blocks) {
    return block;
  };

  InputBlock.prototype.decrementBlock = function(block, blocks) {
    return block;
  };

  InputBlock.prototype.toString = function() {
    return dump({
      start: this.__start,
      end: this.__end,
      len: this.__len,
      string: this.__string
    });
  };

  return InputBlock;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var NumberInputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

NumberInputBlock = (function(superClass) {
  extend(NumberInputBlock, superClass);

  function NumberInputBlock() {
    return NumberInputBlock.__super__.constructor.apply(this, arguments);
  }

  NumberInputBlock.prototype.incrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, 1);
  };

  NumberInputBlock.prototype.decrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, -1);
  };

  NumberInputBlock.prototype.__changeBlock = function(block, blocks, diff) {
    var nn, number;
    number = parseInt(this.__string);
    nn = ("" + (number + diff)).split("");
    return block.setString(nn.join(""));
  };

  return NumberInputBlock;

})(InputBlock);
// Generated by CoffeeScript 1.9.3
var NumberInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

NumberInput = (function(superClass) {
  extend(NumberInput, superClass);

  function NumberInput() {
    return NumberInput.__super__.constructor.apply(this, arguments);
  }

  NumberInput.prototype.initOpts = function() {
    NumberInput.__super__.initOpts.call(this);
    this.addOpts({
      decimals: {
        "default": 0,
        check: "Integer"
      },
      symbol: {
        check: function(v) {
          return isString(v) && v.length > 0;
        }
      },
      symbol_before: {
        "default": false,
        check: Boolean
      },
      store_as_integer: {
        "default": false,
        check: Boolean
      },
      decimalpoint: {
        mandatory: true,
        "default": ".",
        check: [",", "."]
      },
      separator: {
        check: function(v) {
          return isString(v) && v.length > 0;
        }
      },
      min: {
        "default": null,
        check: function(v) {
          return isNumber(v);
        }
      },
      max: {
        "default": null,
        check: function(v) {
          return isNumber(v);
        }
      }
    });
    this.removeOpt("checkInput");
    this.removeOpt("getValueForDisplay");
    this.removeOpt("getValueForInput");
    this.removeOpt("correctValueForInput");
    return this.removeOpt("prevent_invalid_input");
  };

  NumberInput.prototype.readOpts = function() {
    NumberInput.__super__.readOpts.call(this);
    this._checkInput = this.__checkInput;
    return this._prevent_invalid_input = true;
  };

  NumberInput.prototype.formatValueForDisplay = function(value, forInput) {
    var decimals, number, v, v0, v1;
    if (value == null) {
      value = this.getValue();
    }
    if (forInput == null) {
      forInput = false;
    }
    assert(typeof value === "number" || value === null, "NumberInput.formatValueForDisplay", "value needs to be Number or null", {
      value: value,
      type: typeof value
    });
    if (isEmpty(value)) {
      return "";
    }
    if (this._store_as_integer) {
      v = (value / Math.pow(10, this._decimals)).toFixed(this._decimals);
    } else {
      v = value + "";
    }
    v0 = v.split(".");
    if (v0.length > 1) {
      number = v0[0];
      decimals = v0[1];
    } else {
      number = v0[0];
      decimals = "";
    }
    if (this._decimals > 0) {
      while (decimals.length < this._decimals) {
        decimals = decimals + "0";
      }
    }
    if (forInput) {
      if (this._decimals > 0) {
        return number + this._decimalpoint + decimals;
      } else {
        return number;
      }
    }
    if (this._decimals > 0) {
      v1 = this.__addSeparator(number) + this._decimalpoint + decimals;
    } else {
      v1 = this.__addSeparator(number);
    }
    return this.__addSymbol(v1);
  };

  NumberInput.prototype.getValue = function() {
    var v;
    v = NumberInput.__super__.getValue.call(this);
    if (this.hasData()) {
      return v;
    }
    return this.getValueForStore(v);
  };

  NumberInput.prototype.getValueForDisplay = function() {
    return this.formatValueForDisplay(this.getValue());
  };

  NumberInput.prototype.getValueForStore = function(value) {
    var number;
    if (!isString(value)) {
      value = value + "";
    }
    number = parseFloat(value.replace(/,/, "."));
    if (isNaN(number)) {
      return null;
    }
    if (this._store_as_integer) {
      return parseInt((number * Math.pow(10, this._decimals)).toFixed(0));
    }
    return number;
  };

  NumberInput.prototype.storeValue = function(value, flags) {
    if (flags == null) {
      flags = {};
    }
    return NumberInput.__super__.storeValue.call(this, this.getValueForStore(value), flags);
  };

  NumberInput.prototype.getDefaultValue = function() {
    return null;
  };

  NumberInput.prototype.setValue = function(v, flags) {
    if (flags == null) {
      flags = {};
    }
    this.checkValue(v);
    return NumberInput.__super__.setValue.call(this, v, flags);
  };

  NumberInput.prototype.checkValue = function(v) {
    if (v === null) {
      return true;
    } else if (this._decimals > 0 && isFloat(v)) {
      return true;
    } else if (isInteger(v)) {
      return true;
    } else {
      throw new Error(this.__cls + ".setValue(value): Value needs to be Number or null.");
    }
  };

  NumberInput.prototype.__addSymbol = function(str) {
    if (isEmpty(this._symbol)) {
      return str;
    }
    if (this._symbol_before) {
      return this._symbol + " " + str;
    } else {
      return str + " " + this._symbol;
    }
  };

  NumberInput.prototype.__addSeparator = function(str) {
    var i, idx, len, n, nn, ref;
    if (isEmpty(this._separator)) {
      return str;
    }
    nn = [];
    ref = str.split("").reverse();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      n = ref[idx];
      if (idx % 3 === 0 && idx > 0) {
        nn.push(this._separator);
      }
      nn.push(n);
    }
    nn.reverse();
    return nn.join("");
  };

  NumberInput.prototype.correctValueForInput = function(value) {
    return value.replace(/[,\.]/, this._decimalpoint);
  };

  NumberInput.prototype.getValueForInput = function() {
    return this.formatValueForDisplay(null, true);
  };

  NumberInput.prototype.checkInput = function(value) {
    if (value === null) {
      return true;
    } else {
      return NumberInput.__super__.checkInput.call(this, value);
    }
  };

  NumberInput.prototype.__checkInput = function(value) {
    var number, point_idx, points, re, v;
    if (!this.hasShadowFocus()) {
      v = value.replace(this._symbol, "");
    } else {
      v = value;
    }
    v = v.trim();
    if (v === "") {
      return true;
    }
    if (this._separator) {
      re = new RegExp(RegExp.escape(this._separator), "g");
      v = v.replace(re, "");
    }
    point_idx = v.lastIndexOf(this._decimalpoint);
    if (point_idx === -1) {
      number = v;
      points = "";
    } else {
      if (this._decimals === 0) {
        return false;
      }
      number = v.substring(0, point_idx);
      points = v.substring(point_idx + 1);
    }
    if (points.length > this._decimals) {
      return false;
    }
    if (number.length > 0 && !number.match(/^((0|[1-9]+[0-9]*)|(-|-[1-9]|-[1-9][0-9]*))$/)) {
      return false;
    }
    if (!isNull(this._min)) {
      if (this._min >= 0 && number === "-") {
        return false;
      }
      if (number < this._min) {
        return false;
      }
    }
    if (!isNull(this._max)) {
      if (number > this._max) {
        return false;
      }
    }
    if (!points.match(/^([0-9]*)$/)) {
      return false;
    }
    if (points.length > this._decimals) {
      return false;
    }
    return true;
  };

  NumberInput.format = function(v, opts) {
    var _v, ni;
    if (opts == null) {
      opts = {};
    }
    if (isEmpty(v)) {
      v = null;
    }
    if (isFloat(v) && !opts.hasOwnProperty("decimals")) {
      _v = v + "";
      opts.decimals = _v.length - _v.indexOf(".") - 1;
    }
    ni = new NumberInput(opts);
    ni.start();
    if (!ni.checkInput(v + "")) {
      return null;
    } else {
      return ni.formatValueForDisplay(v);
    }
  };

  return NumberInput;

})(Input);
// Generated by CoffeeScript 1.9.3
var EmailInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EmailInput = (function(superClass) {
  extend(EmailInput, superClass);

  function EmailInput() {
    return EmailInput.__super__.constructor.apply(this, arguments);
  }

  EmailInput.prototype.initOpts = function() {
    EmailInput.__super__.initOpts.call(this);
    return this.removeOpt("checkInput");
  };

  EmailInput.prototype.readOpts = function() {
    EmailInput.__super__.readOpts.call(this);
    return this._checkInput = this.__checkInput;
  };

  EmailInput.prototype.__checkInput = function(value) {
    if (isEmpty(value) || EmailInput.regexp.exec(value)) {
      return true;
    } else {
      return false;
    }
  };

  EmailInput.regexp = new RegExp("^[a-z0-9!\#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!\#$%&'*+/=?^_`{|}~-]+)*@(([a-z0-9][a-z0-9-]*[a-z0-9]\.)+[a-z0-9][a-z0-9-]*[a-z0-9]|localhost)$", "i");

  return EmailInput;

})(Input);
// Generated by CoffeeScript 1.9.3
var DateTime,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

CUI.tz_data = {};

DateTime = (function(superClass) {
  extend(DateTime, superClass);

  function DateTime(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    DateTime.__super__.constructor.call(this, this.opts);
    this.init();
  }

  DateTime.prototype.initOpts = function() {
    var locale;
    DateTime.__super__.initOpts.call(this);
    if (DateTime.__locale) {
      locale = DateTime.__locale;
    } else {
      for (locale in DateTimeFormats) {
        break;
      }
    }
    this.addOpts({
      locale: {
        mandatory: true,
        "default": locale,
        check: function(v) {
          var ref;
          return CUI.isArray((ref = DateTimeFormats[v]) != null ? ref.formats : void 0);
        }
      },
      input_types: {
        "default": ["date_time"],
        check: Array
      },
      display_type: {
        "default": "long",
        check: ["long", "short"]
      },
      min_year: {
        mandatory: true,
        "default": 0,
        check: "Integer"
      },
      max_year: {
        mandatory: true,
        "default": 2499,
        check: "Integer"
      }
    });
    this.removeOpt("getValueForDisplay");
    this.removeOpt("getValueForInput");
    this.removeOpt("checkInput");
    return this.removeOpt("getInputBlocks");
  };

  DateTime.prototype.init = function() {
    var f, found, i, j, len, len1, ref, ref1, ref2, type;
    this.__regexpMatcher = this.regexpMatcher();
    this.__input_formats_known = DateTimeFormats[this._locale].formats;
    this.__locale_format = DateTimeFormats[this._locale];
    this.__input_formats = [];
    if (!((ref = this._input_types) != null ? ref.length : void 0)) {
      this.__input_formats = this.__input_formats_known.slice(0);
    } else {
      ref1 = this._input_types;
      for (i = 0, len = ref1.length; i < len; i++) {
        type = ref1[i];
        found = false;
        ref2 = this.__input_formats_known;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          f = ref2[j];
          if (f.type === type) {
            this.__input_formats.push(f);
            found = true;
          }
        }
        assert(found, "new DateTime", "opts.input_types contains unknown type: " + type, {
          formats: this.__input_formats_known,
          input_type: this._input_types
        });
      }
    }
    this.initFormat(0);
  };

  DateTime.prototype.initDateTimePicker = function() {
    var i, k, len, ref;
    if (this.__dateTimeTmpl) {
      return this.__dateTimeTmpl;
    }
    this.__dateTimeTmpl = new Template({
      name: "date-time",
      map: {
        calendar: true,
        analog_clock: true,
        hour_minute: true,
        digi_clock: true,
        header_left: true,
        header_center: true,
        header_right: true,
        hour: true,
        minute: true,
        second: true
      }
    });
    ref = ["calendar", "hour_minute", "hour", "minute", "second"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this["__" + k] = this.__dateTimeTmpl.map[k];
    }
    this.__dateTimeTmpl.append(new CUI.defaults["class"].Button({
      "class": "cui-date-time-browser-date",
      icon_left: "left",
      text: this.__locale_format.tab_date,
      onClick: (function(_this) {
        return function() {
          return _this.setCursor("day");
        };
      })(this)
    }), "header_left");
    this.__dateTimeTmpl.append(new CUI.defaults["class"].Button({
      "class": "cui-date-time-browser-time",
      icon_right: "right",
      text: this.__locale_format.tab_time,
      onClick: (function(_this) {
        return function() {
          return _this.setCursor("hour");
        };
      })(this)
    }), "header_right");
    this.setCursor("day");
    return this.__dateTimeTmpl;
  };

  DateTime.prototype.getTemplate = function() {
    return new Template({
      name: "date-time-input",
      map: {
        center: true,
        right: true
      }
    });
  };

  DateTime.prototype.readOpts = function() {
    DateTime.__super__.readOpts.call(this);
    this._checkInput = this.__checkInput;
    return this._getInputBlocks = this.__getInputBlocks;
  };

  DateTime.prototype.getCurrentFormat = function() {
    return this.__input_format;
  };

  DateTime.prototype.getCurrentFormatDisplay = function() {
    var ref;
    return (ref = this.__input_format) != null ? ref.__display : void 0;
  };

  DateTime.prototype.setCursor = function(cursor) {
    var title;
    switch (cursor) {
      case "hour":
      case "minute":
      case "second":
      case "am_pm":
        title = this.__locale_format.tab_time;
        DOM.setAttribute(this.__dateTimeTmpl.DOM[0], "browser", "time");
        this.setDigiClock();
        break;
      default:
        title = this.__locale_format.tab_date;
        DOM.setAttribute(this.__dateTimeTmpl.DOM[0], "browser", "date");
    }
    this.__dateTimeTmpl.replace(new Label({
      text: title
    }), "header_center");
    return this;
  };

  DateTime.prototype.initFormat = function(idx_or_format) {
    var input, k, last_match_end, match, match_start, match_str, matcher, re, ref, regexp, rstr, s, v;
    if (isInteger(idx_or_format)) {
      this.__input_format = this.__input_formats[idx_or_format];
    } else {
      this.__input_format = idx_or_format;
    }
    moment.locale(this.__locale_format.moment_locale || this._locale);
    switch (this._display_type) {
      case "short":
        this.__input_format.__display = this.__input_format.display_short;
        break;
      default:
        this.__input_format.__display = this.__input_format.display;
    }
    this._invalidHint = {
      text: this.__input_format.invalid
    };
    ref = this.__regexpMatcher;
    for (k in ref) {
      v = ref[k];
      v.match_str = k;
    }
    input = this.__input_format.input;
    rstr = "(" + Object.keys(this.__regexpMatcher).join("|") + ")";
    re = new RegExp(rstr, "g");
    s = input.split("");
    regexp = [];
    matcher = [];
    last_match_end = 0;
    while ((match = re.exec(input)) !== null) {
      match_str = match[0];
      match_start = match.index;
      regexp.push("(" + escapeRegExp(s.slice(last_match_end, match_start).join("")) + ")");
      regexp.push("(" + this.__regexpMatcher[match_str].regexp + ")");
      matcher.push(this.__regexpMatcher[match_str]);
      last_match_end = match_start + match_str.length;
    }
    regexp.push("(" + escapeRegExp(s.slice(last_match_end).join("")) + ")");
    this.__input_format.regexp = new RegExp("^" + regexp.join("") + "$");
    this.__input_format.matcher = matcher;
    return this;
  };

  DateTime.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  DateTime.prototype.render = function() {
    var btn;
    DateTime.__super__.render.call(this);
    if (isEmpty(this._placeholder)) {
      this.__input.prop("placeholder", this.__input_formats[0].text);
    }
    btn = new CUI.defaults["class"].Button({
      icon: "calendar",
      onClick: (function(_this) {
        return function() {
          if (_this.__popover) {
            return _this.closePopover();
          } else {
            return _this.openPopover(btn);
          }
        };
      })(this)
    });
    return this.replace(btn, "right");
  };

  DateTime.prototype.format = function(s, type, output_type) {
    var f, format, formats_tried, i, j, k, l, len, len1, len2, mom, output_format, ref, ref1, ref2;
    if (type == null) {
      type = "display";
    }
    if (output_type == null) {
      output_type = null;
    }
    assert(indexOf.call(DateTime.formatTypes, type) >= 0, "DateTime.format", "type must be on of \"" + (DateTime.formatTypes.join(',')) + "\".", {
      parm1: s,
      type: type
    });
    if (isEmpty(s)) {
      return null;
    }
    if (moment.isMoment(s)) {
      mom = s;
    } else {
      mom = this.parse(s, this.__input_formats_known);
      if (mom.isValid() && isNull(output_type)) {
        output_type = this.getCurrentFormat().type;
      }
    }
    if (!mom.isValid()) {
      formats_tried = [];
      ref = this.__input_formats_known;
      for (i = 0, len = ref.length; i < len; i++) {
        format = ref[i];
        ref1 = DateTime.formatTypes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          k = ref1[j];
          formats_tried.push(format[k]);
        }
      }
      CUI.warn("DateTime.format: Moment is invalid:", s, "Tried formats:", formats_tried);
      return null;
    }
    output_format = null;
    ref2 = this.__input_formats_known;
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      f = ref2[l];
      if (f.type === output_type) {
        output_format = f;
        break;
      }
    }
    assert(output_format, "DateTime.format", "output_type must be in known formats", {
      formats: this.__input_formats_known,
      output_type: output_type
    });
    return mom.format(output_format[type]);
  };

  DateTime.prototype.regexpMatcher = function() {
    return {
      YYYY: {
        regexp: "(?:-|)[0-9]{1,}",
        inc_func: "year",
        cursor: "year"
      },
      MM: {
        regexp: "(?:0[1-9]|1[0-2])",
        inc_func: "month",
        cursor: "month"
      },
      DD: {
        regexp: "[0-3][0-9]",
        inc_func: "day",
        cursor: "day"
      },
      HH: {
        regexp: "[0-2][0-9]",
        inc_func: "hour",
        cursor: "hour"
      },
      hh: {
        regexp: "[0-1][0-9]",
        inc_func: "hour",
        cursor: "hour"
      },
      mm: {
        regexp: "[0-5][0-9]",
        inc_func: "minute",
        cursor: "minute"
      },
      ss: {
        regexp: "[0-5][0-9]",
        inc_func: "second",
        cursor: "second"
      },
      A: {
        regexp: "(?:AM|PM)",
        inc_func: this.incAMPM,
        cursor: "am_pm"
      },
      a: {
        regexp: "(?:am|pm)",
        inc_func: this.incAMPM,
        cursor: "am_pm"
      }
    };
  };

  DateTime.prototype.incAMPM = function(mom, diff) {
    var current_hour;
    current_hour = mom.hour();
    if (current_hour < 12) {
      return mom.add(12, "hour");
    } else {
      return mom.subtract(12, "hour");
    }
  };

  DateTime.prototype.initValue = function() {
    var corrected_value, value;
    DateTime.__super__.initValue.call(this);
    value = this.getValue();
    corrected_value = this.parseValue(value, "store");
    if (corrected_value && corrected_value !== value) {
      CUI.warn("DateTime.initValue: Corrected value in data:", corrected_value, "Original value:", value);
      this.__data[this._name] = corrected_value;
    }
    return this;
  };

  DateTime.prototype.getValueForDisplay = function() {
    var mom, ref, value;
    value = (ref = this.getValue()) != null ? typeof ref.trim === "function" ? ref.trim() : void 0 : void 0;
    if (isEmpty(value)) {
      return "";
    }
    mom = this.parse(value);
    if (mom.isValid()) {
      return mom.format(this.getCurrentFormatDisplay());
    } else {
      return value;
    }
  };

  DateTime.prototype.getValueForInput = function(v) {
    var mom;
    if (v == null) {
      v = this.getValue();
    }
    if (isEmpty(v != null ? v.trim() : void 0)) {
      return "";
    }
    mom = this.parse(v);
    if (mom.isValid()) {
      return mom.format(this.__input_format.input);
    } else {
      return v;
    }
  };

  DateTime.prototype.__checkInput = function(value) {
    var mom;
    if (!isEmpty(value != null ? value.trim() : void 0)) {
      mom = this.parse(value);
      if (!mom.isValid()) {
        return false;
      }
    } else {
      this.initFormat(0);
    }
    return true;
  };

  DateTime.prototype.__getInputBlocks = function(v) {
    var blocks, i, idx, len, m, match, pos;
    CUI.debug("getInputBlocks", v, this.__input_format.regexp);
    match = v.match(this.__input_format.regexp);
    if (!match) {
      return false;
    }
    blocks = [];
    pos = 0;
    for (idx = i = 0, len = match.length; i < len; idx = ++i) {
      m = match[idx];
      if (idx === 0) {
        continue;
      }
      if (idx % 2 === 0) {
        blocks.push(new DateTimeInputBlock({
          start: pos,
          string: m,
          datetime: v,
          input_format: this.__input_format,
          matcher: this.__input_format.matcher[idx / 2 - 1]
        }));
      }
      pos += m.length;
      if (idx % 2 === 1) {
        continue;
      }
    }
    return blocks;
  };

  DateTime.prototype.start_day = 1;

  DateTime.prototype.storeValue = function(value, flags) {
    var mom;
    if (flags == null) {
      flags = {};
    }
    mom = this.parse(value);
    if (mom.isValid()) {
      value = mom.format(this.__input_format.store);
    } else {
      value = null;
    }
    DateTime.__super__.storeValue.call(this, value, flags);
    return this;
  };

  DateTime.prototype.getDigiDisplay = function(format) {
    var cursor, d, digits, i, idx, len, ref;
    digits = [];
    ref = format.split("");
    for (i = 0, len = ref.length; i < len; i++) {
      d = ref[i];
      if ((idx = ["H", "h", "m", "s", "A", "a"].indexOf(d)) > -1) {
        cursor = ["hour", "hour", "minute", "second", "am_pm", "am_pm"][idx];
        if (d === "A" || d === "a") {
          digits.push({
            mask: "[aApP]",
            attr: {
              cursor: cursor,
              title: cursor
            }
          });
          digits.push({
            mask: "[mM]",
            attr: {
              cursor: cursor,
              title: cursor
            }
          });
        } else {
          digits.push({
            mask: "[0-9]",
            attr: {
              cursor: cursor
            }
          });
        }
      } else if (d === "*") {
        digits.push({
          mask: "[0-9A-Z+\-:\. ]"
        });
      } else {
        digits.push({
          "static": ":"
        });
      }
    }
    return this.__digiDisplay = new DigiDisplay({
      digits: digits
    });
  };

  DateTime.prototype.openPopover = function(btn) {
    this.initDateTimePicker();
    this.__popover = new Popover({
      element: btn,
      handle_focus: false,
      onHide: (function(_this) {
        return function() {
          return _this.displayValue();
        };
      })(this),
      placement: "se",
      "class": "cui-date-time-popover",
      pane: {
        content: this.__dateTimeTmpl
      }
    });
    this.updateDateTimePicker();
    this.setCursor("day");
    if (!this.__current_moment.__now) {
      this.setInputFromMoment();
    }
    this.__popover.show();
    return this;
  };

  DateTime.prototype.closePopover = function() {
    if (this.__popover) {
      this.__popover.destroy();
      this.__gridTable = null;
      delete this.__popover;
    }
    return this;
  };

  DateTime.prototype.popoverSetClasses = function() {
    if (this.__input_format.clock_seconds) {
      this.__dateTimeTmpl.removeClass("hide-clock-seconds");
    } else {
      this.__dateTimeTmpl.addClass("hide-clock-seconds");
    }
    if (this.__input_format.clock) {
      this.__dateTimeTmpl.removeClass("hide-clock");
    } else {
      this.__dateTimeTmpl.addClass("hide-clock");
    }
    return this;
  };

  DateTime.prototype.updateDateTimePicker = function() {
    this.setMomentFromInput();
    CUI.debug("updating popover...", this.__input_format);
    this.popoverSetClasses();
    this.drawDate();
    this.drawHourMinute();
    this.setClock();
    this.setDigiClock();
    this.setPrintClock();
    return this;
  };

  DateTime.prototype.destroy = function() {
    this.closePopover();
    return DateTime.__super__.destroy.call(this);
  };

  DateTime.prototype.setClock = function(mom) {
    var hour, hours, millisecond, minute, minutes, second, seconds;
    if (mom == null) {
      mom = this.__current_moment;
    }
    hour = mom.hour();
    minute = mom.minute();
    second = mom.second();
    millisecond = 0;
    seconds = second + millisecond / 1000;
    minutes = minute + seconds / 60;
    hours = (hour % 12) + minutes / 60;
    this.__hour.css("transform", "rotate(" + hours * 30 + "deg)");
    this.__minute.css("transform", "rotate(" + minutes * 6 + "deg)");
    return this.__second.css("transform", "rotate(" + seconds * 6 + "deg)");
  };

  DateTime.prototype.setDigiClock = function(mom) {
    var f;
    if (mom == null) {
      mom = this.__current_moment;
    }
    f = this.__input_format.digi_clock;
    CUI.debug("setDigiClock", f, mom, mom.format(f));
    if (f) {
      this.__digiDisplay.display(mom.format(f));
    }
    return this;
  };

  DateTime.prototype.setPrintClock = function(mom) {
    var mom_tz;
    if (mom == null) {
      mom = this.__current_moment;
    }
    if (!this.__input_format.timezone_display) {
      return this;
    }
    mom_tz = mom.clone();
    mom_tz.tz(CUI.tz_data.tz);
    return this.__timezone_display.empty().append(mom_tz.format(this.__input_format.timezone_display));
  };

  DateTime.prototype.setTimezone = function() {};

  DateTime.prototype.UNUSEDgetTimezoneData = function() {
    if (this.__tz_data) {
      return CUI.resolvedPromise();
    }
    return $.get((CUI.getPathToScript()) + "/moment-timezone-meta.json").done((function(_this) {
      return function(tz_data) {
        var by_name, i, j, len, len1, n, names, results, tz;
        names = [];
        by_name = {};
        for (i = 0, len = tz_data.length; i < len; i++) {
          tz = tz_data[i];
          tz.geo = tz.lat + "/" + tz.long;
          tz.print_name = tz.name;
          names.push(tz.print_name);
          by_name[tz.print_name] = tz;
        }
        names.sort();
        _this.__tz_data = [];
        results = [];
        for (j = 0, len1 = names.length; j < len1; j++) {
          n = names[j];
          results.push(_this.__tz_data.push(by_name[n]));
        }
        return results;
      };
    })(this));
  };

  DateTime.prototype.getTimezoneOpts = function() {
    var i, idx, len, mom, opts, ref, tz;
    if (this.__current_moment) {
      mom = this.__current_moment.clone();
    }
    opts = [];
    ref = this.__tz_data;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      tz = ref[idx];
      if (!mom && tz.name !== DateTimeFormats["de-DE"].timezone) {
        continue;
      }
      opts.push({
        text: tz.print_name,
        right: mom ? $span("cui-timezone-offset").prop("title", tz.geo).text(mom.tz(tz.name).format("zZ")) : null,
        value: tz.name
      });
    }
    return opts;
  };

  DateTime.prototype.parse = function(s, formats, use_formats) {
    var format, i, len, mom;
    if (formats == null) {
      formats = this.__input_formats;
    }
    if (use_formats == null) {
      use_formats = formats;
    }
    if (!((s != null ? typeof s.trim === "function" ? s.trim().length : void 0 : void 0) > 0)) {
      return moment.invalid();
    }
    for (i = 0, len = formats.length; i < len; i++) {
      format = formats[i];
      mom = this.__parseFormat(format, s);
      if (mom) {
        if (indexOf.call(use_formats, format) >= 0) {
          this.initFormat(format);
        } else {
          this.initFormat(0);
        }
        mom.locale(moment.locale());
        return mom;
      }
    }
    return moment.invalid();
  };

  DateTime.prototype.parseValue = function(value, output_format) {
    var format, i, input_formats, len, mom, ref;
    if (output_format == null) {
      output_format = null;
    }
    input_formats = this.__input_formats.slice(0);
    ref = this.__input_formats_known;
    for (i = 0, len = ref.length; i < len; i++) {
      format = ref[i];
      pushOntoArray(format, input_formats);
    }
    mom = this.parse(value, input_formats, this.__input_formats);
    if (!output_format) {
      return mom;
    }
    if (mom.isValid()) {
      return mom.format(this.__input_format[output_format]);
    } else {
      return null;
    }
  };

  DateTime.prototype.__parseFormat = function(f, s) {
    var i, j, k, len, len1, mom, p, ref, ref1;
    ref = DateTime.formatTypes;
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      assert(f[k], "DateTime.__parseFormat", "." + k + " must be set", {
        format: f
      });
      mom = moment(s, f[k], true);
      if (mom.isValid()) {
        return mom;
      }
    }
    ref1 = f.parse;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      p = ref1[j];
      mom = moment(s, p, true);
      if (mom.isValid()) {
        return mom;
      }
    }
  };

  DateTime.prototype.setMomentFromInput = function() {
    var inp;
    inp = this.__input0.value.trim();
    if (inp.length > 0) {
      this.__current_moment = this.parse(inp);
    }
    if (inp === "" || !this.__current_moment.isValid()) {
      this.__current_moment = moment();
      this.__current_moment.__now = true;
      this.initFormat(0);
    }
  };

  DateTime.prototype.setInputFromMoment = function() {
    this.__clearOverwriteMonthAndYear();
    this.__input0.value = this.__current_moment.format(this.__input_format.input);
    this.storeValue(this.__input.val());
    return this;
  };

  DateTime.prototype.__clearOverwriteMonthAndYear = function() {
    this.__overwrite_month = null;
    return this.__overwrite_year = null;
  };

  DateTime.prototype.drawDate = function(_mom) {
    var mom;
    if (!_mom) {
      mom = this.__current_moment.clone();
    } else {
      mom = _mom;
    }
    return this.updateCalendar(mom, false);
  };

  DateTime.prototype.updateCalendar = function(mom, update_current_moment) {
    if (update_current_moment == null) {
      update_current_moment = true;
    }
    this.__calendar.empty();
    if (CUI.__ng__) {
      this.__calendar.append(this.getDateTimeDrawer(mom));
      this.__calendar.append(this.drawMonthTable(mom));
      this.__calendar.append(this.drawYearMonthsSelect(mom));
    } else {
      this.__calendar.append(this.drawYearMonthsSelect(mom));
      this.__calendar.append(this.drawMonthTable(mom));
    }
    if (update_current_moment) {
      this.__current_moment = mom.clone();
      this.setInputFromMoment();
    }
    console.info("DateTime.updateCalendar:", this.__current_moment.format(this.__input_format.input));
    this.markDay();
    return this;
  };

  DateTime.prototype.getDateTimeDrawer = function(mom) {
    var am_pm, am_pm_sel, data, date_sel, hour_sel, minute_sel, month_sel, pad0, year_sel;
    am_pm = this.__input_formats[0].clock_am_pm;
    data = {
      month: mom.month(),
      year: mom.year(),
      date: mom.date(),
      hour: mom.hour(),
      minute: mom.minute(),
      second: mom.second(),
      am_pm: null
    };
    if (am_pm) {
      data.am_pm = Math.floor(data.hour / 12) * 12;
      data.hour = data.hour % 12;
    }
    pad0 = function(n) {
      if (n < 10) {
        return "0" + n;
      } else {
        return "" + n;
      }
    };
    date_sel = new Select({
      name: "date",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.date(data.date));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var day, i, opts, ref;
          opts = [];
          for (day = i = 1, ref = mom.daysInMonth(); 1 <= ref ? i <= ref : i >= ref; day = 1 <= ref ? ++i : --i) {
            opts.push({
              text: pad0(day),
              value: day
            });
          }
          return opts;
        };
      })(this)
    }).start();
    month_sel = new Select({
      name: "month",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.month(data.month));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var i, month, opts;
          opts = [];
          for (month = i = 0; i <= 11; month = ++i) {
            opts.push({
              text: pad0(month + 1),
              value: month
            });
          }
          return opts;
        };
      })(this)
    }).start();
    year_sel = new Select({
      name: "year",
      data: data,
      group: "date",
      onDataChanged: (function(_this) {
        return function() {
          return _this.updateCalendar(mom.year(data.year));
        };
      })(this),
      options: (function(_this) {
        return function() {
          var i, opts, ref, ref1, year;
          opts = [];
          for (year = i = ref = data.year - 20, ref1 = data.year + 20; ref <= ref1 ? i <= ref1 : i >= ref1; year = ref <= ref1 ? ++i : --i) {
            opts.push({
              text: "" + year,
              value: year
            });
          }
          return opts;
        };
      })(this)
    }).start();
    if (this.__input_formats[0].clock) {
      hour_sel = new Select({
        name: "hour",
        data: data,
        group: "time",
        onDataChanged: (function(_this) {
          return function() {
            if (am_pm) {
              return _this.updateCalendar(mom.hour(data.hour + data.am_pm));
            } else {
              return _this.updateCalendar(mom.hour(data.hour));
            }
          };
        })(this),
        options: (function(_this) {
          return function() {
            var hour, i, j, opts;
            opts = [];
            if (am_pm) {
              for (hour = i = 1; i <= 12; hour = ++i) {
                opts.push({
                  text: pad0(hour),
                  value: hour % 12
                });
              }
            } else {
              for (hour = j = 0; j <= 23; hour = ++j) {
                opts.push({
                  text: pad0(hour),
                  value: hour
                });
              }
            }
            return opts;
          };
        })(this)
      }).start();
      minute_sel = new Select({
        "class": "cui-date-time-60-select",
        name: "minute",
        group: "time",
        data: data,
        onDataChanged: (function(_this) {
          return function() {
            return _this.updateCalendar(mom.minute(data.minute));
          };
        })(this),
        options: (function(_this) {
          return function() {
            var i, minute, opts;
            opts = [];
            for (minute = i = 0; i <= 59; minute = ++i) {
              opts.push({
                text: pad0(minute),
                value: minute
              });
            }
            return opts;
          };
        })(this)
      }).start();
      if (am_pm) {
        am_pm_sel = new Select({
          "class": "cui-date-time-am-pm-select",
          name: "am_pm",
          group: "time",
          data: data,
          onDataChanged: (function(_this) {
            return function() {
              return _this.updateCalendar(mom.hour(data.hour + data.am_pm));
            };
          })(this),
          options: (function(_this) {
            return function() {
              var i, len, opts, ref;
              opts = [];
              ref = ["AM", "PM"];
              for (i = 0, len = ref.length; i < len; i++) {
                am_pm = ref[i];
                opts.push({
                  text: am_pm,
                  value: am_pm === "AM" ? 0 : 12
                });
              }
              return opts;
            };
          })(this)
        }).start();
      }
    }
    return new Buttonbar({
      buttons: [date_sel, month_sel, year_sel, hour_sel, minute_sel, am_pm_sel]
    }).DOM;
  };

  DateTime.prototype.drawYearMonthsSelect = function(mom) {
    var data, header_year_month, i, idx, len, m, month_opts, now_year, ref;
    data = {
      month: mom.month(),
      year: mom.year()
    };
    month_opts = [];
    ref = moment.months();
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      m = ref[idx];
      month_opts.push({
        text: m,
        value: idx
      });
    }
    now_year = moment().year();
    header_year_month = new HorizontalLayout({
      maximize_vertical: false,
      maximize_horizontal: true,
      "class": "cui-date-time-footer",
      left: {
        content: new Buttonbar({
          "class": "cui-date-time-header-month",
          buttons: [
            {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "left",
              onClick: (function(_this) {
                return function(ev) {
                  if (mom.clone().subtract(1, "months").year() < _this._min_year) {
                    return;
                  }
                  mom.subtract(1, "months");
                  return _this.drawDate(mom);
                };
              })(this)
            }, new Label({
              text: month_opts[data.month].text
            }), {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "right",
              onClick: (function(_this) {
                return function(ev) {
                  if (mom.clone().add(1, "months").year() > _this._max_year) {
                    return;
                  }
                  mom.add(1, "months");
                  return _this.drawDate(mom);
                };
              })(this)
            }
          ]
        })
      },
      right: {
        content: new Buttonbar({
          "class": "cui-date-time-header-year",
          buttons: [
            {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "left",
              group: CUI.__ng__ ? "year" : null,
              onClick: (function(_this) {
                return function(ev) {
                  if (data.year - 1 < _this._min_year) {
                    return;
                  }
                  mom.subtract(1, "years");
                  return _this.drawDate(mom);
                };
              })(this)
            }, new NumberInput({
              attr: {
                cursor: "year"
              },
              max: this._max_year,
              min: this._min_year,
              placeholder: "" + now_year,
              data: data,
              name: "year",
              group: CUI.__ng__ ? "year" : null,
              onDataChanged: (function(_this) {
                return function(data) {
                  var year;
                  if (isEmpty(data.year)) {
                    year = now_year;
                  } else {
                    year = data.year;
                  }
                  return _this.updateCalendar(mom.year(year));
                };
              })(this)
            }).start(), {
              appearance: CUI.__ng__ ? void 0 : "flat",
              size: CUI.__ng__ ? void 0 : "mini",
              icon: "right",
              group: CUI.__ng__ ? "year" : null,
              onClick: (function(_this) {
                return function(ev) {
                  if (data.year + 1 > _this._max_year) {
                    return;
                  }
                  mom.add(1, "years");
                  return _this.drawDate(mom);
                };
              })(this)
            }
          ]
        })
      }
    });
    return header_year_month.DOM;
  };

  DateTime.prototype.drawMonthTable = function(_mom) {
    var curr_m, curr_y, day_div, day_no, div_type, dow, i, mom, month, month_table, now, ref, ref1, td, td_func, tr, week_no, weekday, weeks, year;
    month = _mom.month();
    year = _mom.year();
    mom = moment([year, month, 1, _mom.hour(), _mom.minute(), _mom.second(), 0]);
    month_table = $table("cui-date-time-date");
    Events.listen({
      node: month_table,
      type: "click",
      call: (function(_this) {
        return function(ev) {
          var $target, data;
          ev.stopPropagation();
          $target = $(ev.getTarget());
          if ($target.closest(".cui-date-time-day").length) {
            data = DOM.data($target.closest("td,.cui-td")[0]);
            _this.__current_moment.date(data.date);
            _this.__current_moment.month(data.month);
            _this.__current_moment.year(data.year);
            _this.updateCalendar(_this.__current_moment);
            if (!CUI.__ng__) {
              if (_this.__input_formats[0].type.match(/time/)) {
                _this.setCursor("hour");
              } else {
                _this.closePopover();
              }
            }
          }
        };
      })(this)
    });
    tr = $tr("cui-date-time-month-header").appendTo(month_table);
    if (CUI.__ng__) {
      td_func = $th;
    } else {
      td_func = $td;
    }
    tr.append(td_func("cui-date-time-week-title").append($div("cui-date-time-dow").text(this.__locale_format.tab_week)));
    for (dow = i = ref = this.start_day, ref1 = this.start_day + 6; ref <= ref1 ? i <= ref1 : i >= ref1; dow = ref <= ref1 ? ++i : --i) {
      weekday = moment.weekdaysMin(dow % 7);
      day_div = $div("cui-date-time-dow").text(weekday);
      day_div.addClass("cui-date-time-day-" + weekday.toLowerCase());
      tr.append(td_func().append(day_div));
    }
    mom.subtract((mom.day() - this.start_day + 7) % 7, "days");
    dow = this.start_day;
    weeks = 0;
    now = moment();
    while (true) {
      curr_y = mom.year();
      curr_m = mom.month();
      day_no = mom.date();
      if ((dow - this.start_day) % 7 === 0) {
        if (weeks === 6) {
          break;
        }
        tr = $tr().appendTo(month_table);
        week_no = mom.week();
        tr.append($td("cui-date-time-week").append($text(week_no)));
        weeks++;
      }
      if (CUI.__ng__) {
        div_type = $td;
      } else {
        div_type = $div;
      }
      day_div = div_type("cui-date-time-day", {
        cursor: "day",
        datestr: [curr_y, curr_m, day_no].join("-")
      }).text(day_no);
      if (curr_m < month) {
        day_div.addClass("cui-date-time-previous-month");
      } else if (curr_m > month) {
        day_div.addClass("cui-date-time-next-month");
      } else {
        day_div.addClass("cui-date-time-same-month");
        if (year === now.year() && month === now.month() && day_no === now.date()) {
          day_div.addClass("cui-date-time-now");
        }
      }
      day_div.addClass("cui-date-time-day-" + mom.format("dd").toLowerCase());
      if (CUI.__ng__) {
        td = day_div.appendTo(tr);
      } else {
        td = $td().append(day_div).appendTo(tr);
      }
      DOM.data(td[0], {
        date: day_no,
        month: curr_m,
        year: curr_y
      });
      mom.add(1, "days");
      dow++;
    }
    return month_table;
  };

  DateTime.prototype.markDay = function() {
    var datestr;
    this.__dateTimeTmpl.DOM.find(".cui-date-time-calendar .cui-date-time-selected").removeClass("cui-date-time-selected");
    if (this.__current_moment.__now) {
      return;
    }
    datestr = [this.__current_moment.year(), this.__current_moment.month(), this.__current_moment.date()].join("-");
    this.__calendar.find("[datestr=\"" + datestr + "\"]").addClass("cui-date-time-selected");
  };

  DateTime.prototype.drawHourMinute = function() {
    var _minute, am_pm, hour, i, j, l, len, minute, o, ref, td, tr;
    if (this.__gridTable) {
      this.markTime();
      return;
    }
    this.__gridTable = $table("cui-date-time-day-grid");
    this.__hour_minute.empty().append(this.__gridTable);
    Events.listen({
      node: this.__hour_minute,
      type: "click",
      call: (function(_this) {
        return function(ev) {
          var $target, am_pm, current_hour, cursor, hour;
          ev.stopPropagation();
          $target = $(ev.getTarget());
          if ($target.closest(".cui-date-time-grid-hour").length) {
            hour = DOM.data($target.closest("td,.cui-td")[0], "hour");
            if (_this.__input_formats[0].clock_am_pm) {
              current_hour = _this.__current_moment.hour();
              if (current_hour < 12) {
                _this.__current_moment.hour(hour % 12);
              } else {
                _this.__current_moment.hour(hour % 12 + 12);
              }
            } else {
              _this.__current_moment.hour(hour);
            }
            _this.__current_moment.second(0);
            if (_this.__current_moment.minute() % 5 !== 0) {
              _this.__current_moment.minute(0);
            }
            if (_this.__input_formats[0].clock_am_pm) {
              cursor = "am_pm";
            } else {
              cursor = "minute";
            }
          }
          if ($target.closest(".cui-date-time-grid-am-pm").length) {
            current_hour = _this.__current_moment.hour();
            am_pm = $target.closest("td,.cui-td").data("am_pm");
            if (am_pm === "AM") {
              if (current_hour >= 12) {
                _this.__current_moment.hour(current_hour - 12);
              }
            } else {
              if (current_hour < 12) {
                _this.__current_moment.hour(current_hour + 12);
              }
            }
            _this.__current_moment.second(0);
            cursor = "minute";
          }
          if ($target.closest(".cui-date-time-grid-minute").length) {
            _this.__current_moment.minute(DOM.data($target.closest("td,.cui-td")[0], "minute"));
            _this.__current_moment.second(0);
            cursor = "blur";
          }
          delete _this.__current_moment.__now;
          _this.markTime();
          _this.setInputFromMoment();
          if (cursor === "blur") {
            _this.closePopover();
          } else {
            _this.setCursor(cursor);
          }
        };
      })(this)
    });
    if (!this.__input_formats[0].clock_am_pm) {
      for (hour = i = 0; i <= 23; hour = ++i) {
        if (hour % 6 === 0) {
          tr = $tr("cui-date-time-grid-hour-row").appendTo(this.__gridTable);
        }
        tr.append(td = $td("cui-date-time-grid-hour").attr("hour", hour).append($text(hour)));
        DOM.data(td[0], "hour", hour);
      }
      tr.addClass("cui-date-time-grid-row-last");
    } else {
      for (hour = j = 1; j <= 12; hour = ++j) {
        if ((hour - 1) % 6 === 0) {
          tr = $tr("cui-date-time-grid-hour-row").appendTo(this.__gridTable);
        }
        tr.append(td = $td("cui-date-time-grid-hour").attr("hour", hour).append($text(hour)));
        DOM.data(td[0], "hour", hour);
      }
      tr.addClass("cui-date-time-grid-row-last");
      tr = $tr("cui-date-time-grid-am-pm-row").appendTo(this.__gridTable);
      ref = ["AM", "PM"];
      for (l = 0, len = ref.length; l < len; l++) {
        am_pm = ref[l];
        tr.append(td = $td("cui-date-time-grid-am-pm").attr("am_pm", am_pm).append($text(am_pm)));
        DOM.data(td[0], "am_pm", am_pm);
      }
      tr.append($td("", {
        colspan: 4
      }));
      tr.addClass("cui-date-time-grid-row-last");
    }
    for (minute = o = 0; o <= 59; minute = o += 5) {
      if (minute % 6 === 0) {
        tr = $tr("cui-date-time-grid-minute-row").appendTo(this.__gridTable);
      }
      if (minute < 10) {
        _minute = ":0" + minute;
      } else {
        _minute = ":" + minute;
      }
      tr.append(td = $td("cui-date-time-grid-minute").attr("minute", minute).append($text(_minute)));
      DOM.data(td[0], "minute", minute);
    }
    tr.addClass("cui-date-time-grid-minute-row-last");
    this.markTime();
  };

  DateTime.prototype.markTime = function() {
    var _c, c, i, j, k, len, len1, ref, ref1, units;
    this.__dateTimeTmpl.DOM.find(".cui-date-time-day-grid .cui-date-time-selected").removeClass("cui-date-time-selected");
    ref = ["hour", "minute"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (this.__current_moment.__now) {
        continue;
      }
      units = this.__current_moment[k]();
      if (k === "hour" && this.__input_formats[0].clock_am_pm) {
        units = (units + 11) % 12 + 1;
      }
      if (k === "minute") {
        units = units - (units % 5);
      }
      this.__gridTable.find("[" + k + "=\"" + units + "\"]").addClass("cui-date-time-selected");
    }
    if (this.__input_formats[0].clock_am_pm) {
      ref1 = this.__gridTable.find("[am_pm]");
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        _c = ref1[j];
        c = $(_c);
        if (this.__current_moment.__now) {
          continue;
        }
        if (this.__current_moment.hour() < 12) {
          if (c.attr("am_pm") === "AM") {
            c.addClass("cui-date-time-selected");
          }
        } else {
          if (c.attr("am_pm") === "PM") {
            c.addClass("cui-date-time-selected");
          }
        }
      }
    }
  };

  DateTime.formatTypes = ["store", "input", "display", "display_short"];

  DateTime.setLocale = function(locale) {
    assert(DateTimeFormats[locale], "DateTime.setLocale", "Locale " + locale + " unknown", {
      DateTimeFormats: DateTimeFormats
    });
    return DateTime.__locale = locale;
  };

  DateTime.format = function(datestr_or_moment, type, output_type) {
    var dt, str;
    dt = new DateTime();
    str = dt.format(datestr_or_moment, type, output_type);
    return str;
  };

  DateTime.display = function(datestr_or_moment, opts) {
    var dt, mom;
    if (opts == null) {
      opts = {};
    }
    if (!opts.hasOwnProperty("input_types")) {
      opts.input_types = null;
    }
    dt = new DateTime(opts);
    mom = dt.parse(datestr_or_moment);
    if (!mom.isValid()) {
      return null;
    }
    return mom.format(dt.getCurrentFormatDisplay());
  };

  DateTime.toMoment = function(datestr) {
    var dt;
    if (isEmpty(datestr)) {
      return null;
    }
    dt = new DateTime({
      input_types: null
    });
    return dt.parse(datestr);
  };

  return DateTime;

})(Input);
// Generated by CoffeeScript 1.9.3
var DateTimeFormats;

DateTimeFormats = {};

DateTimeFormats["de-DE"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wo",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dddd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      parse: ["YYYY-MM-DDTHH:mm:ssZ", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dddd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      clock: true,
      clock_seconds: true,
      parse: ["YYYY-MM-DDTHH:mm:ssZ", "YYYY-MM-DD HH:mm:ss", "D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dddd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["it-IT"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wk",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dddd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dddd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      clock: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dddd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["es-ES"] = {
  timezone: "Europe/Berlin",
  moment_locale: "de-DE",
  tab_date: "Datum",
  tab_time: "Zeit",
  tab_week: "Wk",
  formats: [
    {
      text: "Datum+Zeit",
      invalid: "Datum ungltig",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_seconds: false,
      input: "DD.MM.YYYY HH:mm",
      display: "dddd, DD.MM.YYYY HH:mm",
      display_short: "DD.MM.YYYY HH:mm",
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Datum+Zeit+Sekunden",
      invalid: "Datum ungltig",
      type: "date_time_seconds",
      input: "DD.MM.YYYY HH:mm:ss",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      display: "dddd, DD.MM.YYYY HH:mm:ss",
      display_short: "DD.MM.YYYY HH:mm:ss",
      clock: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Datum",
      input: "DD.MM.YYYY",
      invalid: "Datum ungltig",
      display: "dddd, DD.MM.YYYY",
      display_short: "DD.MM.YYYY",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY"]
    }, {
      text: "Jahr-Monat",
      input: "MM.YYYY",
      invalid: "Datum ungltig",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM.YYYY",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Datum ungltig",
      display: "YYYY",
      display_short: "YYYY",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};

DateTimeFormats["en-US"] = {
  timezone: "Europe/Berlin",
  moment_locale: "en-US",
  tab_date: "Date",
  tab_time: "Time",
  tab_week: "Wk",
  formats: [
    {
      text: "Date+Time",
      invalid: "Invalid Date",
      type: "date_time",
      clock: true,
      store: "YYYY-MM-DDTHH:mm:00Z",
      clock_am_pm: true,
      clock_seconds: false,
      input: "MM/DD/YYYY HH:mm",
      display: "dddd, MM/DD/YYYY HH:mm",
      display_short: "MM/DD/YYYY HH:mm",
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss", "D.M.YYYY HH:mm", "DD.M.YYYY HH:mm", "D.MM.YYYY HH:mm", "D.MM.YY HH:mm", "DD.M.YY HH:mm"]
    }, {
      text: "Date+Time+Seconds",
      invalid: "Invalid Date",
      type: "date_time_seconds",
      store: "YYYY-MM-DDTHH:mm:ssZ",
      input: "MM/DD/YYYY HH:mm:ss",
      display: "dddd, MM/DD/YYYY HH:mm:ss",
      display_short: "MM/DD/YYYY HH:mm:ss",
      clock: true,
      clock_am_pm: true,
      clock_seconds: true,
      parse: ["D.M.YYYY HH:mm:ss", "DD.M.YYYY HH:mm:ss", "D.MM.YYYY HH:mm:ss", "D.MM.YY HH:mm:ss", "DD.M.YY HH:mm:ss"]
    }, {
      text: "Date",
      input: "MM/DD/YYYY",
      invalid: "Invalid date",
      display: "dddd, MM/DD/YYYY",
      display_short: "MM/DD/YYYY",
      store: "YYYY-MM-DD",
      type: "date",
      clock: false,
      parse: ["D.M.YYYY", "D.MM.YYYY", "DD.M.YYYY"]
    }, {
      text: "Jahr-Monat",
      input: "MM/YYYY",
      invalid: "Invalid date",
      store: "YYYY-MM",
      display: "MMMM YYYY",
      display_short: "MM/YYYY",
      type: "year_month",
      clock: false,
      parse: ["MM YYYY"]
    }, {
      text: "Jahr",
      input: "YYYY",
      invalid: "Invalid date",
      display: "YYYY",
      display_short: "YYYY",
      store: "YYYY",
      type: "year",
      clock: false,
      parse: ["YYYY"]
    }
  ]
};
// Generated by CoffeeScript 1.9.3
var DateTimeInputBlock,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DateTimeInputBlock = (function(superClass) {
  extend(DateTimeInputBlock, superClass);

  function DateTimeInputBlock() {
    return DateTimeInputBlock.__super__.constructor.apply(this, arguments);
  }

  DateTimeInputBlock.prototype.initOpts = function() {
    DateTimeInputBlock.__super__.initOpts.call(this);
    return this.addOpts({
      matcher: {
        mandatory: true,
        check: "PlainObject"
      },
      datetime: {
        mandatory: true,
        check: String
      },
      input_format: {
        mandatory: true,
        check: function(v) {
          return !!v.input;
        }
      }
    });
  };

  DateTimeInputBlock.prototype.incrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, 1);
  };

  DateTimeInputBlock.prototype.decrementBlock = function(block, blocks) {
    return this.__changeBlock(block, blocks, -1);
  };

  DateTimeInputBlock.prototype.__changeBlock = function(block, blocks, diff) {
    var bl, i, len, mom;
    CUI.debug("change block", block, blocks, diff, this._datetime, this._input_format.format);
    mom = moment(this._datetime, this._input_format.input);
    if (CUI.isFunction(this._matcher.inc_func)) {
      this._matcher.inc_func(mom, diff);
    } else {
      if (diff < 0) {
        mom.subtract(this._matcher.inc_func_amount || 1, this._matcher.inc_func);
      } else {
        mom.add(this._matcher.inc_func_amount || 1, this._matcher.inc_func);
      }
    }
    for (i = 0, len = blocks.length; i < len; i++) {
      bl = blocks[i];
      bl.setString(mom.format(bl._matcher.match_str));
    }
    return block;
  };

  return DateTimeInputBlock;

})(InputBlock);
// Generated by CoffeeScript 1.9.3
var Password,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Password = (function(superClass) {
  extend(Password, superClass);

  function Password() {
    return Password.__super__.constructor.apply(this, arguments);
  }

  Password.prototype.__createElement = function() {
    return Password.__super__.__createElement.call(this, "password");
  };

  Password.prototype.showPassword = function() {
    return this.__input.prop("type", "text");
  };

  Password.prototype.hidePassword = function() {
    return this.__input.prop("type", "password");
  };

  return Password;

})(Input);
// Generated by CoffeeScript 1.9.3
var MultiInputControl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInputControl = (function(superClass) {
  extend(MultiInputControl, superClass);

  function MultiInputControl(opts) {
    var i, idx, key, key_names, len, ref;
    this.opts = opts != null ? opts : {};
    MultiInputControl.__super__.constructor.call(this, this.opts);
    this.__body = $(document.body);
    this.__keys = [];
    if (!this._keys) {
      return;
    }
    key_names = {};
    ref = this._keys;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      key = ref[idx];
      assert(isString(key.name) && !isEmpty(key.name), "new " + this.__cls, "opts.keys[" + idx + "].name must be non-empty String.", {
        opts: this.opts,
        key: key
      });
      assert(isString(key.tag) && !isEmpty(key.tag), "new " + this.__cls, "opts.keys[" + idx + "].tag must be non-empty String.", {
        opts: this.opts,
        key: key
      });
      assert(isUndef(key.enabled) || isBoolean(key.enabled), "new " + this.__cls, "opts.keys[" + idx + "].enabled must be Boolean.", {
        opts: this.opts,
        key: key
      });
      if (key_names.hasOwnProperty(key.name)) {
        assert(false, "new " + this.__cls, "Duplicate opts.keys[" + idx + "].name \"" + key.name + "\", name already used in #" + idx + ". Skipping.", {
          opts: this.opts,
          key: key
        });
        continue;
      }
      key_names[key.name] = idx;
      this.__keys.push({
        name: key.name,
        tag: key.tag,
        enabled: key.enabled,
        __idx: idx
      });
    }
    this.setPreferredKey(this._preferred_key);
  }

  MultiInputControl.prototype.initOpts = function() {
    MultiInputControl.__super__.initOpts.call(this);
    return this.addOpts({
      preferred_key: {
        check: String
      },
      keys: {
        check: function(v) {
          return CUI.isArray(v) && v.length > 0;
        }
      },
      user_control: {
        "default": true,
        check: Boolean
      }
    });
  };

  MultiInputControl.prototype.setPreferredKey = function(key_name) {
    var i, key, len, ref;
    this.__preferred_key = null;
    if (isNull(key_name)) {
      return this.__preferred_key;
    }
    ref = this.__keys;
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (key.name === key_name) {
        this.__preferred_key = key;
      }
    }
    assert(this.__preferred_key, this.__cls + ".setPreferredKey", "key.name == \"" + key_name + "\" not found in keys.", {
      keys: this.__keys
    });
    return this.__preferred_key;
  };

  MultiInputControl.prototype.getPreferredKey = function() {
    return this.__preferred_key;
  };

  MultiInputControl.prototype.copy = function() {
    return this;
  };

  MultiInputControl.prototype.getKeys = function() {
    return this.__keys;
  };

  MultiInputControl.prototype.isEnabled = function(name) {
    var i, k, len, ref;
    ref = this.getKeys();
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (k.name === name) {
        return k.enabled;
      }
    }
    return void 0;
  };

  MultiInputControl.prototype.getUserControlOptions = function() {
    var fn, i, key, len, options, ref;
    options = [];
    ref = this.__keys;
    fn = function(key) {
      return options.push({
        active: key.enabled,
        onActivate: function() {
          CUI.debug("control activate", key.tag);
          key.enabled = true;
          return Events.trigger({
            type: "multi-input-control-update"
          });
        },
        onDeactivate: function(cb) {
          CUI.debug("control deactivate", key.tag);
          key.enabled = false;
          return Events.trigger({
            type: "multi-input-control-update"
          });
        },
        text: key.tag
      });
    };
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      fn(key);
    }
    return options;
  };

  MultiInputControl.prototype.showUserControl = function() {
    var options;
    options = new Options({
      min_checked: 1,
      options: this.getUserControlOptions()
    }).start();
    return this.popover = new Modal({
      "class": "cui-multi-input-control",
      onHide: (function(_this) {
        return function() {
          return _this.popover = null;
        };
      })(this),
      pane: {
        footer_right: new Button({
          text: "Done",
          onClick: (function(_this) {
            return function() {
              return _this.popover.destroy();
            };
          })(this)
        }),
        header_left: new Label({
          text: "MultiInputControl"
        }),
        content: options
      }
    }).show();
  };

  MultiInputControl.prototype.hasUserControl = function() {
    return this._user_control;
  };

  return MultiInputControl;

})(CUI.Element);

CUI.Events.registerEvent({
  type: "multi-input-control-update",
  sink: true
});
// Generated by CoffeeScript 1.9.3
var MultiInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInput = (function(superClass) {
  extend(MultiInput, superClass);

  function MultiInput(opts) {
    this.opts = opts != null ? opts : {};
    MultiInput.__super__.constructor.call(this, this.opts);
    this.addClass("cui-multi-input");
  }

  MultiInput.prototype.initOpts = function() {
    MultiInput.__super__.initOpts.call(this);
    return this.addOpts({
      textarea: {
        "default": false,
        check: Boolean
      },
      spellcheck: {
        "default": false,
        check: Boolean
      },
      placeholder: {
        check: "PlainObject"
      },
      onFocus: {
        check: Function
      },
      onClick: {
        check: Function
      },
      onKeyup: {
        check: Function
      },
      onBlur: {
        check: Function
      },
      control: {
        mandatory: true,
        check: function(v) {
          return v instanceof MultiInputControl;
        }
      },
      content_size: {
        "default": false,
        check: Boolean
      }
    });
  };

  MultiInput.prototype.disable = function() {
    var i, inp, len, ref, results;
    MultiInput.__super__.disable.call(this);
    if (!this.__inputs) {
      return;
    }
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      results.push(inp.disable());
    }
    return results;
  };

  MultiInput.prototype.enable = function() {
    var i, inp, len, ref, results;
    MultiInput.__super__.enable.call(this);
    if (!this.__inputs) {
      return;
    }
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      results.push(inp.enable());
    }
    return results;
  };

  MultiInput.prototype.initValue = function() {
    var i, key, len, ref, v;
    if (isNull(v = this.__data[this._name])) {
      v = this.__data[this._name] = {};
    }
    ref = this._control.getKeys();
    for (i = 0, len = ref.length; i < len; i++) {
      key = ref[i];
      if (!v.hasOwnProperty(key.name)) {
        v[key.name] = "";
      }
    }
    return this;
  };

  MultiInput.prototype.setData = function(data) {
    MultiInput.__super__.setData.call(this, data);
    return this.setDataOnInputs();
  };

  MultiInput.prototype.setDataOnInputs = function() {
    var i, input, input_data, len, ref, results, v;
    if (!this.__inputs) {
      return;
    }
    input_data = copyObject(this.getValue(), true);
    ref = this.__inputs;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      input = ref[i];
      input.setData(input_data);
      if (this._undo_support) {
        v = this.getInitValue()[input.getName()];
      } else {
        v = this.getValue()[input.getName()];
      }
      results.push(input.setCheckChangedValue(v));
    }
    return results;
  };

  MultiInput.prototype.setInputVisibility = function() {
    var i, inp, key, len, names, ok, ref;
    names = (function() {
      var i, len, ref, results;
      ref = this._control.getKeys();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        results.push(key.name);
      }
      return results;
    }).call(this);
    this.__inputs.sort((function(_this) {
      return function(a, b) {
        return compareIndex(names.indexOf(a.getOpt("name")), names.indexOf(b.getOpt("name")));
      };
    })(this));
    ok = false;
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      this.__multiInputDiv.append(inp.DOM);
      if (this._control.isEnabled(inp.getName())) {
        inp.show();
        ok = true;
      } else {
        inp.hide();
      }
    }
    if (!ok) {
      CUI.warn("MulitInput.setInputVisibility: No input visible.", {
        input: this.__inputs,
        control: this._control
      });
    }
    return Events.trigger({
      type: "content-resize",
      node: inp.DOM
    });
  };

  MultiInput.prototype.getUniqueIdForLabel = function() {
    var i, inp, len, ref;
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      if (this._control.isEnabled(inp.getName())) {
        return inp.getUniqueIdForLabel();
      }
    }
    return null;
  };

  MultiInput.prototype.focus = function() {
    var i, inp, len, ref;
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      inp = ref[i];
      if (this._control.isEnabled(inp.getName())) {
        inp.focus();
        return;
      }
    }
  };

  MultiInput.prototype.displayValue = function() {
    var i, input, len, ref;
    MultiInput.__super__.displayValue.call(this);
    ref = this.__inputs;
    for (i = 0, len = ref.length; i < len; i++) {
      input = ref[i];
      input.displayValue();
    }
    return this;
  };

  MultiInput.prototype.render = function() {
    var fn, i, idx, input, input_opts, key, len, ref, ref1;
    MultiInput.__super__.render.call(this);
    this.__multiInputDiv = $div("cui-multi-input-container");
    Events.listen({
      type: "multi-input-control-update",
      node: this.__multiInputDiv,
      call: (function(_this) {
        return function(ev) {
          return _this.setInputVisibility();
        };
      })(this)
    });
    this.__inputs = [];
    ref = this._control.getKeys();
    fn = (function(_this) {
      return function(input, key) {
        var btn;
        btn = new CUI.defaults["class"].Button({
          text: key.tag,
          tabindex: null,
          disabled: !_this._control.hasUserControl(),
          onClick: function(ev, btn) {
            return _this._control.showUserControl(ev, btn, _this.__multiInputDiv);
          },
          role: "multi-input-tag",
          "class": "cui-multi-input-tag-button"
        });
        input.append(btn, "right");
        return Events.listen({
          type: "data-changed",
          node: input,
          call: function(ev) {
            var values;
            values = copyObject(_this.getValue());
            values[key.name] = input.getValue();
            ev.stopImmediatePropagation();
            return _this.storeValue(values);
          }
        });
      };
    })(this);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      key = ref[idx];
      assert(CUI.isPlainObject(key), "new " + this.__cls, "opts.keys[" + idx + "] needs to be PlainObject.", {
        opts: this.opts
      });
      assert(isString(key.name), "new " + this.__cls, "opts.keys[" + idx + "].name needs to be String.", {
        opts: this.opts
      });
      assert(isString(key.tag), "new " + this.__cls, "opts.keys[" + idx + "].tag needs to be String.", {
        opts: this.opts
      });
      input_opts = {
        "class": "cui-multi-input-input",
        textarea: this._textarea,
        spellcheck: this._spellcheck,
        onBlur: this._onBlur,
        onClick: this._onClick,
        onFocus: this._onFocus,
        onKeyup: this._onKeyup,
        name: key.name,
        undo_support: false,
        content_size: this._content_size,
        placeholder: (ref1 = this._placeholder) != null ? ref1[key.name] : void 0
      };
      input = new MultiInputInput(input_opts);
      input.render();
      fn(input, key);
      this.__inputs.push(input);
    }
    if (this.hasData()) {
      this.setDataOnInputs();
    }
    this.replace(this.__multiInputDiv);
    this.setInputVisibility();
    return this;
  };

  return MultiInput;

})(DataFieldInput);
// Generated by CoffeeScript 1.9.3
var MultiInputInput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiInputInput = (function(superClass) {
  extend(MultiInputInput, superClass);

  function MultiInputInput() {
    return MultiInputInput.__super__.constructor.apply(this, arguments);
  }

  MultiInputInput.prototype.getTemplate = function() {
    return new Template({
      name: "data-field-multi-input",
      map: {
        center: true,
        right: true
      }
    });
  };

  MultiInputInput.prototype.getTemplateKeyForRender = function() {
    return "center";
  };

  return MultiInputInput;

})(Input);
// Generated by CoffeeScript 1.9.3
var Checkbox,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Checkbox = (function(superClass) {
  extend(Checkbox, superClass);

  function Checkbox() {
    return Checkbox.__super__.constructor.apply(this, arguments);
  }

  Checkbox.prototype.initOpts = function() {
    Checkbox.__super__.initOpts.call(this);
    return this.addOpts({
      onClick: {
        check: Function
      },
      value: {
        "default": true
      },
      value_unchecked: {
        "default": false
      },
      text: {
        check: String
      },
      content: {
        check: function(v) {
          return !!(isElement(v) || v instanceof CUI.Element);
        }
      },
      active: {
        "default": false,
        check: Boolean
      },
      onActivate: {
        check: Function
      },
      onDeactivate: {
        check: Function
      },
      radio: {
        check: String
      },
      group: {
        check: String
      },
      radio_allow_null: {
        check: Boolean
      },
      tooltip: {
        check: "PlainObject"
      }
    });
  };

  Checkbox.prototype.enable = function() {
    var ref;
    Checkbox.__super__.enable.call(this);
    return (ref = this.__checkbox) != null ? ref.enable() : void 0;
  };

  Checkbox.prototype.disable = function() {
    var ref;
    Checkbox.__super__.disable.call(this);
    return (ref = this.__checkbox) != null ? ref.disable() : void 0;
  };

  Checkbox.prototype.getOptValue = function() {
    return this._value;
  };

  Checkbox.prototype.getOptValueUnchecked = function() {
    return this._value_unchecked;
  };

  Checkbox.prototype.getCheckboxClass = function() {
    return "cui-button-checkbox";
  };

  Checkbox.prototype.destroy = function() {
    var ref;
    if ((ref = this.__checkbox) != null) {
      ref.destroy();
    }
    return Checkbox.__super__.destroy.call(this);
  };

  Checkbox.prototype.render = function() {
    var btn_opts, i, k, len, ref;
    Checkbox.__super__.render.call(this);
    btn_opts = this.getButtonOpts();
    btn_opts.onActivate = (function(_this) {
      return function(btn, flags, event) {
        var ret;
        if (flags.initial_activate) {
          return;
        }
        _this.storeValue(_this._value, flags);
        ret = typeof _this._onActivate === "function" ? _this._onActivate(_this, flags, event) : void 0;
        if (isPromise(ret)) {
          ret.fail(function() {
            return _this.storeValue(_this._value_unchecked, flags);
          });
        }
        return ret;
      };
    })(this);
    btn_opts.onDeactivate = (function(_this) {
      return function(btn, flags, event) {
        var ret;
        if (flags.initial_activate) {
          return;
        }
        if (_this._radio) {
          flags.force_store = true;
        }
        _this.storeValue(_this._value_unchecked, flags);
        ret = typeof _this._onDeactivate === "function" ? _this._onDeactivate(_this, flags, event) : void 0;
        if (isPromise(ret)) {
          ret.fail(function() {
            return _this.storeValue(_this._value, flags);
          });
        }
        return ret;
      };
    })(this);
    if (this._onClick) {
      btn_opts.onClick = (function(_this) {
        return function(ev) {
          _this._onClick(ev, _this);
        };
      })(this);
    }
    ref = ["text", "radio_allow_null", "active"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (!isUndef(btn_opts[k])) {
        continue;
      }
      btn_opts[k] = this["_" + k];
    }
    if (isEmpty(btn_opts.text)) {
      btn_opts.text = "";
    }
    btn_opts.disabled = this.isDisabled();
    btn_opts.center = this._content;
    btn_opts["class"] = this._class;
    this.__checkbox = new CUI.defaults["class"].Button(btn_opts);
    this.__checkbox.addClass(this.getCheckboxClass());
    if (CUI.__ng__) {
      this.__checkbox.removeClass("cui-button-button");
    }
    this.proxy(this.__checkbox, ["activate", "deactivate", "isActive", "getGroup", "setGroup", "setText", "getText"]);
    this.replace(this.__checkbox);
    return this.append(this.getChangedMarker());
  };

  Checkbox.prototype.checkValue = function(v, flags) {
    if (!isBoolean(v)) {
      throw new Error(this.__cls + ".setValue(value): Value needs to be Boolean.");
    }
  };

  Checkbox.prototype.displayValue = function() {
    Checkbox.__super__.displayValue.call(this);
    if (!this.hasData()) {
      return;
    }
    if (this.getOptValue() === this.getValue()) {
      this.__checkbox.activate({
        initial_activate: true
      });
    } else {
      this.__checkbox.deactivate({
        initial_activate: true
      });
    }
    return this;
  };

  Checkbox.prototype.getButtonOpts = function() {
    if (this._radio) {
      return {
        role: "radio",
        radio: this._radio,
        group: this._group,
        icon_active: "check"
      };
    } else {
      return {
        role: "checkbox",
        "switch": true,
        group: this._group,
        icon_active: "check"
      };
    }
  };

  Checkbox.prototype.getDefaultValue = function() {
    if (this._active) {
      return this._value;
    } else {
      return this._value_unchecked;
    }
  };

  Checkbox.prototype.isChanged = function() {
    if (!this.hasData()) {
      return void 0;
    }
    if (!this._radio) {
      return Checkbox.__super__.isChanged.call(this);
    }
    if (this.getValue() === this.getOptValue()) {
      return Checkbox.__super__.isChanged.call(this);
    }
    return this.__checkChangedValue === JSON.stringify(this.getOptValue());
  };

  return Checkbox;

})(DataFieldInput);
// Generated by CoffeeScript 1.9.3
var Options,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Options = (function(superClass) {
  extend(Options, superClass);

  function Options(opts) {
    this.opts = opts != null ? opts : {};
    Options.__super__.constructor.call(this, this.opts);
    this.DOM.addClass("cui-padding-reset");
    if (this._sortable) {
      this.DOM.addClass("cui-options--sortable");
    }
  }

  Options.prototype.initOpts = function() {
    Options.__super__.initOpts.call(this);
    return this.addOpts({
      hash_store: {
        check: Boolean
      },
      radio: {
        check: function(v) {
          return isString(v) || isBoolean(v);
        }
      },
      radio_unchecked_value: {
        "default": false
      },
      min_checked: {
        check: function(v) {
          if (this._radio) {
            return v === 0 || v === 1;
          } else {
            return isInteger(v) && v >= 0;
          }
        }
      },
      options: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      horizontal: {
        check: function(v) {
          return v === true || (isInteger(v) && v > 0);
        }
      },
      title: {
        check: String
      },
      activatable: {
        check: Boolean
      },
      sortable: {
        check: Boolean
      },
      sortable_hint: {
        check: String
      },
      placeholder: {
        "default": "No options available.",
        check: String
      }
    });
  };

  Options.prototype.readOpts = function() {
    Options.__super__.readOpts.call(this);
    assert(!this._sortable || !this._left, "new Options", "opts.sortable and opts.left cannot be used together.", {
      opts: this.opts
    });
    assert(!this._sortable || !this._radio, "new Options", "opts.sortable and opts.radio cannot be used together.", {
      opts: this.opts
    });
    assert(!this._sortable || !this._horizontal, "new Options", "opts.sortable and opts.horizontal cannot be used together.", {
      opts: this.opts
    });
    if (this._sortable && this._activatable === void 0) {
      this._activatable = true;
    }
    return assert(!(this._sortable && !this._activatable), "new Options", "opts.sortable needs opts.activatable to be set.", {
      opts: this.opts
    });
  };

  Options.prototype.getTemplate = function() {
    if (!CUI.__ng__) {
      return Options.__super__.getTemplate.call(this);
    }
    if (this._activatable) {
      return this.__tmpl = new Template({
        name: "options-activatable",
        map_prefix: "options",
        map: {
          top: true,
          bottom: true,
          active: true,
          inactive: true
        }
      });
    } else {
      return this.__tmpl = new Template({
        name: "options",
        map: {
          top: true,
          bottom: true,
          center: true
        }
      });
    }
  };

  Options.prototype.init = function() {
    switch (this._radio) {
      case false:
        this.__radio = void 0;
        break;
      case true:
        this.__radio = "options--" + this.getUniqueId();
        break;
      default:
        this.__radio = this._radio;
    }
    return this.__options_data = {};
  };

  Options.prototype.setData = function(data) {
    Options.__super__.setData.call(this, data);
    if (this._radio) {
      if (CUI.isArray(this.getValue())) {
        this.__radio_use_array = true;
      } else {
        this.__radio_use_array = false;
      }
    }
    this.__setDataOnOptions();
    return this;
  };

  Options.prototype.__setDataOnOptions = function(init_data) {
    var cb, i, j, l, len, len1, len2, opt, opt_unchecked, ref, ref1, ref2;
    if (init_data == null) {
      init_data = true;
    }
    if (!this.__checkboxes) {
      return;
    }
    if (init_data) {
      ref = this.__checkboxes;
      for (i = 0, len = ref.length; i < len; i++) {
        cb = ref[i];
        cb.callOnOthers("setData", this.__data);
      }
    }
    if (this._radio && !this.__radio_use_array) {
      ref1 = this.__checkboxes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        cb = ref1[j];
        this.__options_data[cb.getName()] = this.getValue();
        if (!init_data) {
          continue;
        }
        if (this._check_changed && JSON.parse(this.getCheckChangedValue()) === cb.getOptValue()) {
          cb.setCheckChangedValue(cb.getOptValue());
        } else {
          cb.setCheckChangedValue(cb.getOptValueUnchecked());
        }
      }
    } else {
      ref2 = this.__checkboxes;
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        cb = ref2[l];
        opt = cb.getOptValue();
        opt_unchecked = cb.getOptValueUnchecked();
        if (this.getValue().indexOf(opt) > -1) {
          this.__options_data[cb.getName()] = opt;
        } else {
          this.__options_data[cb.getName()] = opt_unchecked;
        }
        if (!init_data) {
          continue;
        }
        if (this._check_changed && JSON.parse(this.getCheckChangedValue()).indexOf(opt) > -1) {
          cb.setCheckChangedValue(opt);
        } else {
          cb.setCheckChangedValue(opt_unchecked);
        }
      }
    }
    return this;
  };

  Options.prototype.disableOption = function(value) {
    var cb;
    cb = this.__getCheckboxByValue(value);
    cb.disable();
    return this;
  };

  Options.prototype.enableOption = function(value) {
    var cb;
    cb = this.__getCheckboxByValue(value);
    cb.enable();
    return this;
  };

  Options.prototype.__getCheckboxByValue = function(value) {
    var found, i, idx, len, opt, ref;
    found = null;
    ref = this.__options;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      opt = ref[idx];
      if (opt.value === value) {
        found = idx;
      }
    }
    assert(found !== null, "CUI.Options.__getCheckboxByValue", "Value " + value + " not found in Options.", {
      options: this.__options
    });
    return this.__checkboxes[found];
  };

  Options.prototype.setValue = function(v, flags) {
    if (flags == null) {
      flags = {};
    }
    flags.__set_on_data = true;
    return Options.__super__.setValue.call(this, v, flags);
  };

  Options.prototype.storeValue = function(value, flags) {
    if (flags == null) {
      flags = {};
    }
    Options.__super__.storeValue.call(this, value, flags);
    if (flags.__set_on_data) {
      this.__setDataOnOptions();
    }
    return this;
  };

  Options.prototype.displayValue = function() {
    var cb, i, len, ref;
    Options.__super__.displayValue.call(this);
    ref = this.__checkboxes;
    for (i = 0, len = ref.length; i < len; i++) {
      cb = ref[i];
      cb.displayValue();
    }
    return this;
  };

  Options.prototype.checkValue = function(_value) {
    var check, i, j, len, len1, opt, ref, value;
    if (this.__radio_use_array || !this._radio) {
      if (!CUI.isArray(_value)) {
        throw new CheckValueError("Value must be Array.");
      }
      check = _value;
    } else {
      check = [_value];
    }
    for (i = 0, len = check.length; i < len; i++) {
      value = check[i];
      ref = this.__options;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        opt = ref[j];
        if (opt.value === value) {
          CUI.debug("value is ok.", this.hasData(), this.getData()[this._name]);
          return;
        }
      }
    }
    throw new CheckValueError("Value is not in the options.");
  };

  Options.prototype.disable = function() {
    if (!CUI.__ng__) {
      return;
    }
    return Options.__super__.disable.call(this);
  };

  Options.prototype.enable = function() {
    if (!CUI.__ng__) {
      return;
    }
    return Options.__super__.enable.call(this);
  };

  Options.prototype.render = function() {
    var _opt, bottom, cb, drag_handle, drag_handle_inner, el, find_value_in_options, fn, i, idx, j, len, len1, order_options_by_value_array, order_value_array, ref, ref1, sort_options, sortable_element, sortable_selector, top, unsorted_options;
    Options.__super__.render.call(this);
    unsorted_options = this.getArrayFromOpt("options");
    sort_options = (function(_this) {
      return function() {
        return _this.__options.sort(function(a, b) {
          var a_idx, b_idx;
          a_idx = idxInArray(idxInArray(a, unsorted_options), _this.__options_order);
          b_idx = idxInArray(idxInArray(b, unsorted_options), _this.__options_order);
          return compareIndex(a_idx, b_idx);
        });
      };
    })(this);
    find_value_in_options = function(value, options) {
      var i, idx, len, opt;
      for (idx = i = 0, len = options.length; i < len; idx = ++i) {
        opt = options[idx];
        if (opt.value === value || (!opt.hasOwnProperty("value") && opt.text === value)) {
          return idx;
        }
      }
      return -1;
    };
    order_value_array = (function(_this) {
      return function(arr) {
        var a, i, idx, j, len, len1, results;
        for (idx = i = 0, len = arr.length; i < len; idx = ++i) {
          a = arr[idx];
          a.___idx = idx;
        }
        arr.sort(function(a, b) {
          var a_idx, b_idx;
          a_idx = find_value_in_options(a, _this.__options);
          if (a_idx === -1) {
            a_idx = arr.length + a.__idx;
          }
          b_idx = find_value_in_options(b, _this.__options);
          if (b_idx === -1) {
            b_idx = arr.length + b.__idx;
          }
          return compareIndex(a_idx, b_idx);
        });
        results = [];
        for (idx = j = 0, len1 = arr.length; j < len1; idx = ++j) {
          a = arr[idx];
          results.push(delete a.___idx);
        }
        return results;
      };
    })(this);
    order_options_by_value_array = (function(_this) {
      return function() {
        var arr, i, idx, j, l, len, len1, len2, missing_opts, mopt, opt, results, value;
        if (_this.hasData()) {
          arr = _this.getValue();
        } else {
          arr = [];
        }
        _this.__options_order = [];
        for (i = 0, len = arr.length; i < len; i++) {
          value = arr[i];
          _this.__options_order.push(find_value_in_options(value, unsorted_options));
        }
        missing_opts = [];
        for (idx = j = 0, len1 = unsorted_options.length; j < len1; idx = ++j) {
          opt = unsorted_options[idx];
          if (idxInArray(idx, _this.__options_order) === -1) {
            missing_opts.push({
              opt: opt,
              idx: idx
            });
          }
        }
        missing_opts.sort(function(a, b) {
          var a_txt, b_txt;
          a_txt = a.opt.text.toLocaleUpperCase();
          b_txt = b.opt.text.toLocaleUpperCase();
          if (a_txt < b_txt) {
            return -1;
          } else if (a_txt > b_txt) {
            return 1;
          } else {
            return 0;
          }
        });
        results = [];
        for (l = 0, len2 = missing_opts.length; l < len2; l++) {
          mopt = missing_opts[l];
          results.push(_this.__options_order.push(mopt.idx));
        }
        return results;
      };
    })(this);
    if (this._sortable && !this.__options_order) {
      order_options_by_value_array();
    }
    this.__options = unsorted_options.slice(0);
    if (this.__options_order) {
      sort_options();
    }
    this.__checkboxes = [];
    ref = this.__options;
    fn = (function(_this) {
      return function(_opt) {
        var cb, k, opt, v;
        opt = {};
        for (k in _opt) {
          v = _opt[k];
          opt[k] = v;
        }
        assert(!isEmpty(opt.text) || !isEmpty(opt.content), "new " + _this.__cls, "opts.options[" + idx + "].text|content must be set.", {
          opts: _this.opts
        });
        if (!opt.hasOwnProperty("value")) {
          assert(!isEmpty(opt.text), "new " + _this.__cls, "opts.options[" + idx + "].text must be set.", {
            opts: _this.opts
          });
          opt.value = opt.text;
        }
        if (_this._sortable) {
          if (!opt.form) {
            opt.form = {};
          }
          opt.form.label = $div("cui-options-sortable-drag-handle cui-drag-handle-row");
        }
        opt.radio = _this.__radio;
        if (_this._radio && _this._min_checked === 0) {
          if (_this.__options.length === 1) {
            delete opt.radio;
          } else {
            opt.radio_allow_null = true;
          }
        }
        opt.onActivate = function(_cb, flags) {
          var arr;
          if (_cb.hasData()) {
            if (_this._radio && !_this.__radio_use_array) {
              _this.storeValue(_cb.getValue(), flags);
            } else {
              addToArray(_cb.getOptValue(), arr = _this.getValue().slice(0));
              order_value_array(arr);
              _this.storeValue(arr, flags);
              if (_this._sortable) {
                order_options_by_value_array();
                _this.reload();
              }
            }
          }
          if (typeof _opt.onActivate === "function") {
            _opt.onActivate(_cb, flags);
          }
        };
        opt.onDeactivate = function(_cb, flags) {
          var arr, c, f, j, len1, ref1;
          if (!_this._radio) {
            c = 0;
            ref1 = _this.__checkboxes;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              f = ref1[j];
              if (f.isActive()) {
                c++;
              }
            }
            if (c < _this._min_checked) {
              return _cb.activate();
            }
          }
          if (_cb.hasData()) {
            if (_this._radio && !_this.__radio_use_array) {
              _this.storeValue(_cb.getValue(), flags);
            } else {
              removeFromArray(_cb.getOptValue(), arr = _this.getValue().slice(0));
              _this.storeValue(arr, flags);
              if (_this._sortable) {
                order_options_by_value_array();
                _this.reload();
              }
            }
          }
          if (typeof _opt.onDeactivate === "function") {
            _opt.onDeactivate(_cb, flags);
          }
        };
        opt.undo_support = false;
        opt.mark_changed = _this._mark_changed;
        if (_this.getName()) {
          if (_this.__radio && !_this.__radio_use_array) {
            opt.name = _this.__radio;
            opt.group = _this.__radio;
          } else {
            opt.group = "options-" + _this.getUniqueId();
            opt.name = opt.group + "--" + idx;
          }
          opt.data = _this.__options_data;
          opt.data_not_for_others = true;
        }
        cb = new Checkbox(opt);
        Events.listen({
          type: "data-changed",
          node: cb,
          call: function(ev, info) {
            if (info.element === cb) {
              ev.stopImmediatePropagation();
            }
          }
        });
        return _this.__checkboxes.push(cb);
      };
    })(this);
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      _opt = ref[idx];
      fn(_opt);
    }
    if (this.hasData()) {
      this.__setDataOnOptions();
    }
    if (this.__checkboxes.length) {
      if (this._sortable && !isEmpty(this._sortable_hint)) {
        bottom = new Label({
          multiline: true,
          "class": "cui-options-order-hint",
          text: this._sortable_hint
        });
      } else {
        bottom = void 0;
      }
      if (!isEmpty(this._title)) {
        top = new Label({
          "class": "cui-options-title",
          text: this._title
        });
      } else {
        top = void 0;
      }
      if (CUI.__ng__) {
        this.replace(bottom, "bottom");
        this.replace(top, "top");
        if (this._activatable) {
          this.empty("active");
          this.empty("inactive");
        } else {
          this.empty("center");
        }
        ref1 = this.__checkboxes;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          cb = ref1[j];
          cb.start();
          if (this._sortable && cb.isActive()) {
            el = CUI.DOM.element("DIV", {
              "class": "cui-options-sortable-option"
            });
            drag_handle = CUI.DOM.element("DIV", {
              "class": "cui-options-sortable-drag-handle"
            });
            drag_handle_inner = CUI.DOM.element("DIV", {
              "class": "cui-drag-handle-row"
            });
            drag_handle.appendChild(drag_handle_inner);
            el.appendChild(drag_handle);
            el.appendChild(cb.DOM);
          } else {
            el = cb.DOM;
          }
          if (cb.isActive() && this._activatable) {
            this.append(el, "active");
          } else if (this._activatable) {
            this.append(el, "inactive");
          } else {
            this.append(el, "center");
          }
        }
        sortable_element = this.__tmpl.map.active;
        sortable_selector = ".cui-options-sortable-drag-handle";
      } else {
        this.__optionsForm = new Form({
          "class": "cui-options-form cui-form-options",
          horizontal: this._horizontal,
          top: top,
          bottom: bottom,
          fields: this.__checkboxes
        });
        this.replace(this.__optionsForm);
        this.proxy(this.__optionsForm, ["disable", "enable"]);
        this.__optionsForm.render();
        sortable_element = this.__optionsForm.getTable();
        sortable_selector = void 0;
      }
      if (this._sortable) {
        new Sortable({
          axis: "y",
          element: sortable_element,
          selector: sortable_selector,
          sorted: (function(_this) {
            return function(ev, from_idx, to_idx) {
              var arr;
              console.debug("from:", from_idx, "to:", to_idx);
              moveInArray(from_idx, to_idx, _this.__options_order);
              sort_options();
              if (_this.hasData()) {
                arr = _this.getValue().slice(0);
                order_value_array(arr);
                _this.storeValue(arr);
              }
              order_options_by_value_array();
              return _this.reload();
            };
          })(this)
        });
      }
    } else {
      this.replace(new EmptyLabel({
        text: this._placeholder
      }));
    }
    return this;
  };

  Options.prototype.getDefaultValue = function() {
    if (this._radio && !this.__radio_use_array) {
      return this._radio_unchecked_value;
    } else {
      return [];
    }
  };

  return Options;

})(CUI.DataField);

Options = CUI.Options;
// Generated by CoffeeScript 1.9.3
var ObjectDumper,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ObjectDumper = (function(superClass) {
  extend(ObjectDumper, superClass);

  function ObjectDumper() {
    return ObjectDumper.__super__.constructor.apply(this, arguments);
  }

  ObjectDumper.prototype.initOpts = function() {
    ObjectDumper.__super__.initOpts.call(this);
    return this.addOpts({
      object: {
        mandatory: true,
        check: function(v) {
          var e;
          !CUI.isFunction(v);
          try {
            JSON.stringify(v);
          } catch (_error) {
            e = _error;
            CUI.error(e);
            return false;
          }
          return true;
        }
      }
    });
  };

  ObjectDumper.prototype.render = function() {
    return $div("cui-object-dumper-container").append(this.__dumpToDiv(this._object));
  };

  ObjectDumper.prototype.__dumpToDiv = function(obj, depth) {
    var i, k, label, len, node, tr, v;
    if (depth == null) {
      depth = 0;
    }
    label = (function(_this) {
      return function(txt) {
        return new Label({
          text: txt
        }).DOM;
      };
    })(this);
    if (CUI.isPlainObject(obj)) {
      node = $table();
      for (k in obj) {
        v = obj[k];
        tr = $tr().appendTo(node);
        tr.append($td().append(new Label({
          text: k
        }).DOM));
        tr.append($td().append(this.__dumpToDiv(v, depth + 1)));
      }
    } else if (CUI.isArray(obj)) {
      node = $ul();
      for (i = 0, len = obj.length; i < len; i++) {
        k = obj[i];
        node.append($li().append(this.__dumpToDiv(k, depth + 1)));
      }
    } else if (obj === true) {
      node = label("<true>");
    } else if (obj === false) {
      node = label("<false>");
    } else if (isNumber(obj)) {
      node = label(obj + "");
    } else if (isString(obj)) {
      node = label(obj);
    } else if (obj === null) {
      node = label("<null>");
    } else if (obj === void 0) {
      node = label("<undefined>");
    } else {
      CUI.error("Unable to dumpToDiv", obj);
    }
    return node;
  };

  return ObjectDumper;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var Output,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Output = (function(superClass) {
  extend(Output, superClass);

  function Output() {
    return Output.__super__.constructor.apply(this, arguments);
  }

  Output.prototype.initOpts = function() {
    Output.__super__.initOpts.call(this);
    return this.addOpts({
      placeholder: {
        "default": "",
        check: String
      },
      text: {
        check: String
      },
      markdown: {
        mandatory: true,
        "default": false,
        check: Boolean
      },
      getValue: {
        check: Function
      },
      multiline: {
        check: Boolean
      }
    });
  };

  Output.prototype.readOpts = function() {
    var i, k, len, ref;
    Output.__super__.readOpts.call(this);
    ref = ["undo_support", "check_changed", "mark_changed"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      this.removeOpt(k);
      this["_" + k] = false;
    }
    return this;
  };

  Output.prototype.init = function() {
    this.__textSpan = new Label({
      multiline: this._multiline,
      "class": "cui-data-field-output-label"
    });
    this.setText(this._text);
    return this.__textSpan;
  };

  Output.prototype.setText = function(txt, markdown) {
    if (markdown == null) {
      markdown = null;
    }
    if (isEmpty(txt)) {
      this.__textSpan.addClass("cui-output-empty");
      txt = this._placeholder;
    } else {
      this.__textSpan.removeClass("cui-output-empty");
    }
    if (markdown === null) {
      return this.__textSpan.setText(txt, this._markdown);
    } else {
      return this.__textSpan.setText(txt, markdown);
    }
  };

  Output.prototype.checkValue = function() {};

  Output.prototype.displayValue = function() {
    var ret;
    Output.__super__.displayValue.call(this);
    if (this.getName()) {
      ret = this.getValue();
      if (isContent(ret)) {
        this.replace(ret);
      } else {
        this.setText(ret, false);
      }
    }
    return this;
  };

  Output.prototype.getValue = function() {
    var value;
    value = Output.__super__.getValue.call(this);
    if (this._getValue) {
      return this._getValue.call(this, value, this.getData());
    } else {
      return value;
    }
  };

  Output.prototype.render = function() {
    Output.__super__.render.call(this);
    return this.replace(this.__textSpan);
  };

  return Output;

})(DataFieldInput);
// Generated by CoffeeScript 1.9.3
var OutputContent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

OutputContent = (function(superClass) {
  extend(OutputContent, superClass);

  function OutputContent() {
    return OutputContent.__super__.constructor.apply(this, arguments);
  }

  OutputContent.prototype.initOpts = function() {
    OutputContent.__super__.initOpts.call(this);
    return this.addOpts({
      placeholder: {
        "default": "",
        check: String
      },
      content: {
        check: function(v) {
          return isElement(v) || isElement(v.DOM);
        }
      },
      getValue: {
        check: Function
      }
    });
  };

  OutputContent.prototype.setContent = function(content) {
    if (content == null) {
      content = null;
    }
    CUI.debug("setContent", this.DOM, content);
    if (!content) {
      this.DOM.addClass("cui-output-empty");
      return this.empty();
    } else {
      this.DOM.removeClass("cui-output-empty");
      return this.replace(content);
    }
  };

  OutputContent.prototype.displayValue = function() {
    OutputContent.__super__.displayValue.call(this);
    if (this.getName()) {
      this.setContent(this.getValue());
    }
    return this;
  };

  OutputContent.prototype.getValue = function() {
    var value;
    value = OutputContent.__super__.getValue.call(this);
    if (this._getValue) {
      return this._getValue.call(this, value);
    } else {
      return value;
    }
  };

  OutputContent.prototype.render = function() {
    OutputContent.__super__.render.call(this);
    return this.setContent(this._content);
  };

  return OutputContent;

})(DataFieldInput);
// Generated by CoffeeScript 1.9.3
var MultiOutput,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MultiOutput = (function(superClass) {
  extend(MultiOutput, superClass);

  function MultiOutput() {
    return MultiOutput.__super__.constructor.apply(this, arguments);
  }

  MultiOutput.prototype.initOpts = function() {
    MultiOutput.__super__.initOpts.call(this);
    return this.addOpts({
      control: {
        mandatory: true,
        check: MultiInputControl
      }
    });
  };

  MultiOutput.prototype.displayValue = function() {
    var key;
    MultiOutput.__super__.displayValue.call(this);
    key = this._control.getPreferredKey();
    assert(key, "Output.displayValue", "MultiInputControl: no preferred key set.", {
      control: this._control
    });
    this.setText(this.getValue()[key.name]);
    return this;
  };

  return MultiOutput;

})(Output);
// Generated by CoffeeScript 1.9.3
var FormButton,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FormButton = (function(superClass) {
  extend(FormButton, superClass);

  function FormButton() {
    return FormButton.__super__.constructor.apply(this, arguments);
  }

  FormButton.prototype.getButtonOpts = function() {
    var i, k, len, opts, ref;
    opts = {
      icon: this._icon
    };
    ref = ["appearance"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      opts[k] = this["_" + k];
    }
    return opts;
  };

  FormButton.prototype.getCheckboxClass = function() {
    return "cui-button-form-button";
  };

  FormButton.prototype.initOpts = function() {
    FormButton.__super__.initOpts.call(this);
    return this.addOpts({
      icon: {
        check: function(v) {
          return v instanceof Icon || isString(v);
        }
      },
      appearance: {
        mandatory: true,
        "default": "auto",
        check: ["auto", "link", "flat", "normal", "important"]
      }
    });
  };

  return FormButton;

})(Checkbox);
// Generated by CoffeeScript 1.9.3
var Form,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Form = (function(superClass) {
  extend(Form, superClass);

  function Form() {
    return Form.__super__.constructor.apply(this, arguments);
  }

  Form.prototype.initOpts = function() {
    Form.__super__.initOpts.call(this);
    return this.addOpts({
      fields: {
        mandatory: true,
        check: function(v) {
          return CUI.isFunction(v) || CUI.isArray(v);
        }
      },
      class_table: {
        check: String
      },
      header: {
        check: Array
      },
      horizontal: {
        "default": false,
        check: function(v) {
          return isBoolean(v) || (isInteger(v) && v > 0);
        }
      },
      appearance: {
        "default": "normal",
        mandatory: true,
        check: ["normal", "separators"]
      },
      maximize: {
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean
      },
      maximize_vertical: {
        check: Boolean
      },
      top: {},
      bottom: {}
    });
  };

  Form.prototype.readOpts = function() {
    var cb_opts, i, k, len, ref, ref1, vl_opts;
    Form.__super__.readOpts.call(this);
    if (this._horizontal === 1) {
      this.__horizontal = null;
    } else {
      this.__horizontal = this._horizontal;
    }
    vl_opts = {
      "class": "cui-form cui-padding-reset cui-form-appearance-" + this._appearance
    };
    ref = ["maximize", "maximize_horizontal", "maximize_vertical"];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      if (this.hasSetOpt(k)) {
        vl_opts[k] = this.getSetOpt(k);
      }
    }
    if (this.hasSetOpt("top")) {
      vl_opts.top = {
        content: this._top
      };
    }
    if (this.hasSetOpt("bottom")) {
      vl_opts.bottom = {
        content: this._bottom
      };
    }
    if ((ref1 = this._form) != null ? ref1.checkbox : void 0) {
      assert(CUI.isPlainObject(this._form.checkbox, "new Form", "opts.form.checkbox needs to be PlainObject.", {
        opts: this.opts
      }));
      assert(this._name, "new Form", "opts.form.checkbox requires opts.name to be set.", {
        opts: this.opts
      });
      assert(!this._form.checkbox.data, "new Form", "opts.form.checkbox cannot have 'data' set.", {
        opts: this.opts
      });
      assert(!this._form.checkbox.name, "new Form", "opts.form.checkbox cannot have 'name' set.", {
        opts: this.opts
      });
      cb_opts = copyObject(this._form.checkbox, true);
      cb_opts.data = this.__checkbox_data = {
        checkbox: false
      };
      cb_opts.name = "checkbox";
      this.__checkbox = new Checkbox(cb_opts).start();
      Events.listen({
        type: "data-changed",
        node: this.__checkbox,
        call: (function(_this) {
          return function() {
            if (_this.__checkbox_data.checkbox) {
              return _this.__checkbox_set_data[_this._name] = _this.__checkbox_form_data;
            } else {
              return delete _this.__checkbox_set_data[_this._name];
            }
          };
        })(this)
      });
    } else {
      this.checkbox = null;
    }
    this.__verticalLayout = new VerticalLayout(vl_opts);
    return this.__verticalLayout;
  };

  Form.prototype.getCheckbox = function() {
    return this.__checkbox;
  };

  Form.prototype.initTemplate = function() {
    return this.registerTemplate(this.__verticalLayout.getLayout());
  };

  Form.prototype.getLayout = function() {
    return this.__verticalLayout;
  };

  Form.prototype.__createFields = function() {
    var _field, field, fields, fs, i, idx, len;
    fs = [];
    fields = this.getArrayFromOpt("fields");
    for (idx = i = 0, len = fields.length; i < len; idx = ++i) {
      field = fields[idx];
      if (!field) {
        continue;
      }
      if (CUI.isFunction(field)) {
        _field = DataField["new"](field(this));
      } else {
        _field = DataField["new"](field);
      }
      _field.setForm(this);
      fs.push(_field);
    }
    return fs;
  };

  Form.prototype.getNameOpt = function() {
    return {
      name: {
        check: String
      }
    };
  };

  Form.prototype.init = function() {
    this.__initUndo();
    this.initFields();
    return this.setFormDepth();
  };

  Form.prototype.initFields = function() {
    this.__fields = this.__createFields();
    return this.__fields;
  };

  Form.prototype.displayValue = function() {
    if (this.__checkbox) {
      this.__checkbox.displayValue();
    }
    return Form.__super__.displayValue.call(this);
  };

  Form.prototype.setData = function(data) {
    if (this._name && this.__checkbox) {
      assert(!CUI.isFunction(data), "Form.setData", "opts.data cannot be set by Function when data is managed by opts.form.checkbox.", {
        opts: this.opts
      });
    }
    if (this._name && !CUI.isFunction(data)) {
      if (this.__checkbox) {
        this.__checkbox_set_data = data;
        if (data[this._name]) {
          this.__checkbox_form_data = data[this._name];
          this.__checkbox_data.checkbox = true;
          this.show();
        } else {
          this.__checkbox_form_data = {};
          this.__checkbox_data.checkbox = false;
          this.hide();
        }
        Form.__super__.setData.call(this, this.__checkbox_form_data);
      } else {
        if (isUndef(data[this._name])) {
          data[this._name] = {};
        }
        Form.__super__.setData.call(this, data[this._name]);
      }
    } else {
      Form.__super__.setData.call(this, data);
    }
    if (CUI.isFunction(this._fields) && this.__fields && this.__fields.length === 0) {
      this.initFields();
      this.callOnOthers("setData", this.__data);
    }
    return this;
  };

  Form.prototype.__setRowVisibility = function(tr) {
    var _f, df, i, len, ref;
    df = DOM.data(tr[0], "data-field");
    if (!df) {
      CUI.warn("Form.__setRowVisibility", "data-field not found", df, this);
      return;
    }
    ref = df.getAllDataFields();
    for (i = 0, len = ref.length; i < len; i++) {
      _f = ref[i];
      if (!_f.isHidden()) {
        tr.css("display", "");
        return;
      }
    }
    return tr.css("display", "none");
  };

  Form.prototype.render = function() {
    if (CUI.__ng__) {
      Form.__super__.render.call(this);
      this.renderTable();
    } else {
      this.renderTable();
      Form.__super__.render.call(this);
    }
    return this;
  };

  Form.prototype.getTable = function() {
    return this.table;
  };

  Form.prototype.renderTable = function() {
    var _field, _fields, app, append_content, append_left, cb, cls, col_i, content, fields, fields_per_column, fopts, getAppend, has_left, head, i, idx, j, len, len1, len2, len3, m, n, o, p, ref, ref1, ref2, ref3, right, row_i, source_idx, target_idx, td1, td2, td_class, td_classes, tds, th, tr, tr_fields, tr_head, tr_labels, use_field_as_label;
    this.table = $table("cui-form-table");
    if (this._horizontal) {
      this.table.addClass("cui-form-table-horizontal");
    } else {
      this.table.addClass("cui-form-table-vertical");
    }
    Events.listen({
      node: this.table,
      type: "form-check-row-visibility",
      call: (function(_this) {
        return function(ev) {
          var tr;
          tr = $(ev.getNode()).closest(".cui-form-tr");
          ev.stopPropagation();
          if (!tr.hasClass("cui-form-tr-vertical")) {
            return;
          }
          if (tr.length) {
            return _this.__setRowVisibility(tr);
          }
        };
      })(this)
    });
    if (this._class_table) {
      this.table.addClass(this._class_table);
    }
    ref = (this._class || "").split(/\s+/);
    for (i = 0, len = ref.length; i < len; i++) {
      cls = ref[i];
      if (isEmpty(cls)) {
        continue;
      }
      this.table[0].classList.add(cls + "-table");
    }
    if (this._horizontal && CUI.__ng__) {
      td_classes = ["cui-padding cui-form-left cui-form-th", "cui-padding cui-form-center cui-form-td"];
    } else {
      td_classes = ["cui-padding cui-form-left cui-form-td", "cui-padding cui-form-center cui-form-td"];
    }
    getAppend = (function(_this) {
      return function(v, info) {
        if (info == null) {
          info = _this;
        }
        if (CUI.isPlainObject(v)) {
          return new MultilineLabel(v).DOM;
        } else if (isString(v)) {
          return new MultilineLabel({
            text: v
          }).DOM;
        } else if (v != null ? v.DOM : void 0) {
          return v.DOM;
        } else if (CUI.isFunction(v)) {
          return getAppend(v(info));
        } else if (isEmpty(v)) {
          return null;
        } else {
          return v;
        }
      };
    })(this);
    if (this._header) {
      tr_head = $tr("cui-form-tr-header").appendTo(this.table);
      console.error("adding header..", this._header);
      assert(!this._horizontal, "Form.renderTable", "opts.header cannot be used with opts.horizontal", {
        opts: this.opts
      });
      for (idx = j = 0, len1 = td_classes.length; j < len1; idx = ++j) {
        td_class = td_classes[idx];
        head = this._header[idx];
        th = $th(td_class).appendTo(tr_head);
        th.append(getAppend(head != null ? head.label : void 0));
      }
    }
    has_left = false;
    _fields = this.getFields();
    if (this.__horizontal > 1) {
      fields = [];
      fields_per_column = Math.ceil(_fields.length / this.__horizontal);
      for (col_i = m = 0, ref1 = this.__horizontal; 0 <= ref1 ? m < ref1 : m > ref1; col_i = 0 <= ref1 ? ++m : --m) {
        for (row_i = n = 0, ref2 = fields_per_column; 0 <= ref2 ? n < ref2 : n > ref2; row_i = 0 <= ref2 ? ++n : --n) {
          target_idx = col_i + row_i * this._horizontal;
          source_idx = col_i * fields_per_column + row_i;
          if (source_idx >= _fields.length) {
            continue;
          }
          fields[target_idx] = _fields[source_idx];
        }
      }
    } else {
      fields = _fields;
    }
    for (idx = o = 0, len2 = fields.length; o < len2; idx = ++o) {
      _field = fields[idx];
      if (this.__horizontal && (idx === 0 || (this.__horizontal > 1 && idx % this.__horizontal === 0))) {
        tr_labels = $tr("cui-form-tr cui-form-tr-horizontal cui-form-tr-labels");
        if (!CUI.__ng__) {
          tr_labels.appendTo(this.table);
        }
        tr_fields = $tr("cui-form-tr cui-form-tr-horizontal cui-form-tr-fields").appendTo(this.table);
      }
      fopts = (_field != null ? _field._form : void 0) || {};
      tds = [];
      right = null;
      if (fopts.hasOwnProperty("right")) {
        right = fopts.right;
        console.error("Form.renderTable: form.right is deprecated. Remove this from your code. Form:", this, "Field:", _field, "Field#", idx);
      }
      append_content = [];
      append_left = [];
      use_field_as_label = false;
      ref3 = [fopts, _field, right];
      for (idx = p = 0, len3 = ref3.length; p < len3; idx = ++p) {
        app = ref3[idx];
        if (idx === 0) {
          content = null;
          if (_field instanceof Form && _field.getCheckbox()) {
            cb = _field.getCheckbox();
            content = _field.getCheckbox().DOM;
            (function(_this) {
              return (function(cb, _field) {
                return Events.listen({
                  type: "data-changed",
                  node: cb,
                  call: function() {
                    if (cb.getValue()) {
                      return _field.show();
                    } else {
                      return _field.hide();
                    }
                  }
                });
              });
            })(this)(cb, _field);
          } else {
            if (app.label) {
              if (isString(app.label) && CUI.__ng__) {
                content = CUI.DOM.element("label", {
                  "for": _field.getUniqueIdForLabel()
                });
                content.textContent = app.label;
              } else {
                content = getAppend(app.label, _field);
              }
            }
            if (app.use_field_as_label) {
              assert(!this._horizontal, "Form.renderTable", "field.form.use_field_as_label is not supported with opts.horizontal.", {
                opts: this.opts,
                field: _field
              });
              use_field_as_label = true;
            }
          }
        } else {
          content = getAppend(app, _field);
        }
        if (content !== null) {
          if (use_field_as_label || idx === 0) {
            append_left.push(content);
          } else {
            append_content.push(content);
          }
        }
      }
      if (append_left.length > 0) {
        if (this._horizontal) {
          if (CUI.__ng__) {
            console.error("Form.renderTable", "field.form.label in horizontal tables is obsolete.");
          } else {
            console.error("Form.renderTable", "field.form.label in horizontal tables is deprectated.");
          }
        }
        has_left = true;
      }
      if (use_field_as_label) {
        tds.push($td(td_classes[0], {
          colspan: 2
        }).append(append_left));
      } else {
        td2 = $td(td_classes[1]);
        if (this._horizontal && CUI.__ng__) {
          td1 = $th(td_classes[0]);
          td1.addClass("cui-form-th");
          if (fopts.th_rotate_90) {
            td1.addClass("cui-form-rotate-90");
            td2.addClass("cui-form-rotate-90");
          }
        } else {
          td1 = $td(td_classes[0]);
        }
        tds.push(td1.append(append_left));
        tds.push(td2.append(append_content));
      }
      if (this.__horizontal) {
        tr_labels.append(tds[0]);
        tr_fields.append(tds[1]);
      } else {
        tr = $tr("cui-form-tr cui-form-tr-vertical").appendTo(this.table);
        if (getObjectClass(_field) === "Form" && _field instanceof CUI.Form) {
          if (!_field.getOpt("horizontal") || !has_left) {
            tr.addClass("cui-form-tr-content-is-form-vertical");
          }
        }
        DOM.data(tr[0], "data-field", _field);
        tr.append(tds);
      }
    }
    if (has_left) {
      this.table.addClass("cui-form-table-has-left-column");
    } else {
      this.table.addClass("cui-form-table-has-not-left-column");
    }
    Events.listen({
      type: "data-changed",
      node: this.table,
      call: (function(_this) {
        return function(ev, info) {
          var ref4;
          if (!info.element) {
            return;
          }
          if ((ref4 = info.action) === "goto" || ref4 === "reset") {
            return;
          }
          _this.__undo.log[++_this.__undo.idx] = {
            name: info.element.getName(),
            undo_idx: info.undo_idx,
            action: info.action
          };
          _this.__undo.log.splice(_this.__undo.idx + 1);
        };
      })(this)
    });
    this.getLayout().replace(this.table, "center");
    CUI.DOM.setAttribute(this.table, "cui-form-depth", CUI.DOM.getAttribute(this.DOM, "cui-form-depth"));
    return this.table;
  };

  Form.prototype.__initUndo = function() {
    if (this.__undo) {
      return;
    }
    return this.__undo = {
      log: [],
      idx: -1
    };
  };

  Form.prototype.getLog = function() {
    var i, l, len, log, ref;
    log = [];
    ref = this.__undo.log;
    for (i = 0, len = ref.length; i < len; i++) {
      l = ref[i];
      log.push(l.name + " " + l.action + " " + l.undo_idx);
    }
    return log.join("\n");
  };

  Form.prototype.undo = function() {
    var df, f, i, j, l, len, len1, ref, ref1;
    if (this.__undo.idx === -1) {
      return false;
    }
    if (this.__undo.idx === 0) {
      ref = this.getFields();
      for (i = 0, len = ref.length; i < len; i++) {
        df = ref[i];
        df.goto(this.__undo.idx--);
      }
      return true;
    }
    l = this.__undo.log[--this.__undo.idx];
    ref1 = this.getRootForm().getFieldsByName(l.name);
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      f = ref1[j];
      f.goto(l.undo_idx);
    }
    return true;
  };

  Form.prototype.redo = function() {
    var f, i, l, len, ref;
    if (this.__undo.idx === this.__undo.log.length - 1) {
      return false;
    }
    l = this.__undo.log[++this.__undo.idx];
    ref = this.getRootForm().getFieldsByName(l.name);
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      f.goto(l.undo_idx);
    }
    return true;
  };

  Form.prototype.getFieldByIdx = function(idx) {
    assert(isInteger(idx) && idx >= 0, this.__cls + ".getFieldByIdx", "idx must be Integer.", {
      idx: idx
    });
    return this.getFields("getFieldByIdx")[idx];
  };

  Form.prototype.getFieldsByName = function(name, found_fields) {
    var _field, i, len, ref;
    if (found_fields == null) {
      found_fields = [];
    }
    assert(isString(name), this.__cls + ".getFieldsByName", "name must be String.", {
      name: name
    });
    ref = this.getFields("getFieldsByName");
    for (i = 0, len = ref.length; i < len; i++) {
      _field = ref[i];
      if (_field instanceof Form) {
        _field.getFieldsByName(name, found_fields);
        continue;
      }
      if (_field.getName() === name) {
        found_fields.push(_field);
        continue;
      }
    }
    return found_fields;
  };

  Form.prototype.getFields = function(func) {
    return this.__fields;
  };

  Form.prototype.isDataField = function() {
    if (this._name) {
      return true;
    } else {
      return false;
    }
  };

  Form.prototype.hasData = function() {
    return false;
  };

  Form.prototype.getValue = function() {
    var data, field, i, k, len, ref;
    if (!this._name) {
      data = {};
      ref = this.getDataFields();
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if (k = field.getName()) {
          data[k] = field.getValue();
        }
      }
      return data;
    } else {
      data = copyObject(this.__data, true);
      delete data._undo;
      return data;
    }
  };

  Form.prototype.isChanged = function() {
    var _field, i, len, ref;
    ref = this.getFields();
    for (i = 0, len = ref.length; i < len; i++) {
      _field = ref[i];
      if (_field.isChanged()) {
        return true;
      }
    }
    return false;
  };

  Form.prototype.destroy = function() {
    if (this.table) {
      DOM.remove(this.table);
      this.table = null;
    }
    return Form.__super__.destroy.call(this);
  };

  return Form;

})(CUI.DataField);

CUI.Events.registerEvent({
  type: "form-check-row-visibility",
  bubble: true
});

Form = CUI.Form;
// Generated by CoffeeScript 1.9.3
var FormPopover,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

FormPopover = (function(superClass) {
  extend(FormPopover, superClass);

  function FormPopover(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FormPopover.__super__.constructor.call(this, this.opts);
    this.__old_display = null;
    this.__old_render = null;
    this;
  }

  FormPopover.prototype.initOpts = function() {
    FormPopover.__super__.initOpts.call(this);
    return this.addOpts({
      popover: {
        "default": {},
        check: "PlainObject"
      },
      button: {
        "default": {},
        check: function(v) {
          return CUI.isPlainObject(v) && !v.onClick;
        }
      },
      trigger_data_changed_while_open: {
        "default": false,
        check: Boolean
      },
      renderDisplayButton: {
        check: Function
      },
      renderDisplayContent: {
        check: Function
      }
    });
  };

  FormPopover.prototype.readOpts = function() {
    FormPopover.__super__.readOpts.call(this);
    if (this._class) {
      this.__class = this._class;
      delete this._class;
    }
    this.__fields_is_func = CUI.isFunction(this._fields);
    if (this.__fields_is_func) {
      return assert(this._data_not_for_others !== true, "new FormPopover", "opts.data_not_for_others cannot be set to true if fields are created on open by a Function.", {
        opts: this.opts
      });
    }
  };

  FormPopover.prototype.init = function() {
    if (!this.__fields_is_func) {
      return FormPopover.__super__.init.call(this);
    }
    this.__initUndo();
    return this.setFormDepth();
  };

  FormPopover.prototype.setDataOnOthers = function() {
    if (this.__fields_is_func) {
      return false;
    } else {
      return FormPopover.__super__.setDataOnOthers.call(this);
    }
  };

  FormPopover.prototype.isChanged = function() {
    if (this.__fields) {
      return FormPopover.__super__.isChanged.call(this);
    } else {
      return false;
    }
  };

  FormPopover.prototype.getFields = function(func) {
    if (func == null) {
      func = "";
    }
    if (func === "render" || func === "displayValue") {
      return [];
    }
    if (func === "show" || func === "hide" || func === "enable" || func === "disable" || func === "getFieldsByName" || func === "getFieldByIdx" || func === "setFormDepth" || func === "getDataFields") {
      return this.__fields || [];
    }
    assert(this.__fields, "FormPopover.getFields(" + func + ")", "Fields not rendered yet. This is a programming error in CUI.");
    return FormPopover.__super__.getFields.call(this);
  };

  FormPopover.prototype.initTemplate = function() {
    var vl;
    vl = new VerticalLayout({
      maximize: false,
      bottom: {}
    });
    return this.registerTemplate(vl.getLayout());
  };

  FormPopover.prototype.render = function() {
    var button_opts;
    button_opts = copyObject(this._button, true);
    button_opts.onClick = (function(_this) {
      return function() {
        return _this.__openPopover();
      };
    })(this);
    CUI.mergeMap(button_opts, {
      left: true
    });
    this.__button = new CUI.defaults["class"].Button(button_opts);
    this.addClass("cui-data-field-input");
    if (this._renderDisplayButton) {
      this.addClass("cui-form-popover-has-button-text");
    }
    this.append(this.__button, "center");
    this.append(this.getChangedMarker(), "center");
    DataField.prototype.render.call(this);
    return this;
  };

  FormPopover.prototype.getButton = function() {
    return this.__button;
  };

  FormPopover.prototype.displayValue = function() {
    DataField.prototype.displayValue.call(this);
    return this.__renderDisplay();
  };

  FormPopover.prototype.callOnFields = function() {
    var args, df, func, i, len, ref;
    func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    ref = this.getFields();
    for (i = 0, len = ref.length; i < len; i++) {
      df = ref[i];
      df[func].apply(df, args);
    }
    return this;
  };

  FormPopover.prototype.__renderDisplay = function() {
    var display, render, text;
    if (this._renderDisplayContent) {
      display = this._renderDisplayContent(this, this.__data);
    } else if (this._renderDisplayButton) {
      render = this._renderDisplayButton(this, this.__data);
    } else if (!this.__data) {
      text = "Data not set.";
      display = $textEmpty(text);
    } else {
      display = text = "";
    }
    if (this._renderDisplayButton) {
      if (render === false) {
        this.__button.deactivate();
      } else if (render === true) {
        this.__button.activate();
      } else if (render instanceof Icon) {
        this.__button.setIcon(render);
        this.__button.setText();
      } else {
        this.__button.setIcon();
        this.__button.setText(render);
      }
      if (this.__old_render !== null) {
        Events.trigger({
          type: "content-resize",
          node: this.DOM
        });
      }
      this.__old_render = render;
    } else {
      if (this.__old_display === null || this.__old_display !== display) {
        this.replace(display, "bottom");
        if (this.__old_display !== null) {
          Events.trigger({
            type: "content-resize",
            node: this.DOM
          });
        }
        this.__old_display = display;
      }
    }
    this.checkChanged();
    return this;
  };

  FormPopover.prototype.renderTable = function() {
    FormPopover.__super__.renderTable.call(this);
    this.getLayout().addClass(this.__class);
    return this.table;
  };

  FormPopover.prototype.initPopover = function(opts) {
    return new Popover(opts);
  };

  FormPopover.prototype.getPopoverOpts = function() {
    var pop_opts;
    pop_opts = copyObject(this._popover, true);
    if (!pop_opts.pane) {
      pop_opts.pane = {};
    }
    if (!pop_opts.hasOwnProperty("auto_size")) {
      pop_opts.auto_size = true;
    }
    assert(CUI.isPlainObject(pop_opts.pane), "new FormPopover", "opts.pane must be PlainObject", {
      opts: pop_opts
    });
    if (isEmpty(pop_opts["class"])) {
      pop_opts["class"] = "";
    }
    pop_opts["class"] += " cui-form-popover-popover";
    return pop_opts;
  };

  FormPopover.prototype.getPopover = function() {
    return this.__popover;
  };

  FormPopover.prototype.__openPopover = function() {
    var onHide, onShow, pop_opts;
    pop_opts = this.getPopoverOpts();
    if (this.__fields_is_func) {
      if (this.table) {
        this.callOnFields("remove");
        this.table = null;
      }
      this.initFields();
      this.callOnFields("setData", this.__data);
    }
    if (!this.table) {
      this.renderTable();
      this.callOnFields("start");
    }
    if (!pop_opts.hasOwnProperty("element")) {
      pop_opts.element = this.__button;
    }
    onHide = pop_opts.onHide;
    pop_opts.onHide = (function(_this) {
      return function(pop, ev) {
        _this.__closePopover();
        return typeof onHide === "function" ? onHide(pop, ev) : void 0;
      };
    })(this);
    onShow = pop_opts.onShow;
    if (onShow) {
      pop_opts.onShow = (function(_this) {
        return function(pop) {
          return typeof onShow === "function" ? onShow(pop, _this) : void 0;
        };
      })(this);
    }
    pop_opts.pane.content = this.getLayout();
    this.__popover = this.initPopover(pop_opts);
    Events.listen({
      type: "data-changed",
      node: this.__popover,
      call: (function(_this) {
        return function(ev, info) {
          if (info == null) {
            info = {};
          }
          _this.__renderDisplay();
          _this.__dataChanged = info;
          if (_this._trigger_data_changed_while_open) {
            _this.__triggerDataChanged();
          }
        };
      })(this)
    });
    this.__popover.show();
    return this.addClass("focus");
  };

  FormPopover.prototype.__closePopover = function() {
    this.getLayout().DOM.detach();
    this.__popover.destroy();
    this.removeClass("focus");
    this.__popover = null;
    this.__triggerDataChanged();
    return this;
  };

  FormPopover.prototype.closePopover = function() {
    var ref;
    return (ref = this.__popover) != null ? ref.hide() : void 0;
  };

  FormPopover.prototype.hide = function(trigger_event) {
    if (trigger_event == null) {
      trigger_event = false;
    }
    this.closePopover();
    return FormPopover.__super__.hide.call(this, trigger_event);
  };

  FormPopover.prototype.__triggerDataChanged = function() {
    if (this.__dataChanged) {
      Events.trigger({
        type: "data-changed",
        node: this.__button,
        info: this.__dataChanged
      });
    }
    return this.__dataChanged = null;
  };

  FormPopover.prototype.disable = function() {
    var ref;
    FormPopover.__super__.disable.call(this);
    return (ref = this.__button) != null ? ref.disable() : void 0;
  };

  FormPopover.prototype.enable = function() {
    var ref;
    FormPopover.__super__.enable.call(this);
    return (ref = this.__button) != null ? ref.enable() : void 0;
  };

  FormPopover.prototype.destroy = function() {
    var ref;
    FormPopover.__super__.destroy.call(this);
    if ((ref = this.__popover) != null) {
      ref.destroy();
    }
    return this.__dataChanged = null;
  };

  return FormPopover;

})(Form);
// Generated by CoffeeScript 1.9.3
var FormModal,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FormModal = (function(superClass) {
  extend(FormModal, superClass);

  function FormModal(opts1) {
    this.opts = opts1 != null ? opts1 : {};
    FormModal.__super__.constructor.call(this, this.opts);
    this.__old_text = null;
    this.__old_display = null;
  }

  FormModal.prototype.initOpts = function() {
    FormModal.__super__.initOpts.call(this);
    this.removeOpt("popover");
    return this.addOpts({
      modal: {
        "default": {},
        check: "PlainObject",
        apply_button: {
          mandatory: true,
          "default": {
            text: "Ok"
          },
          check: (function(_this) {
            return function(v) {
              return CUI.isPlainObject(v);
            };
          })(this)
        }
      }
    });
  };

  FormModal.prototype.initPopover = function(opts) {
    var btn, btn_opts, mod, onClick;
    btn_opts = copyObject(this._modal.apply_button, true);
    onClick = btn_opts.onClick;
    btn_opts.onClick = (function(_this) {
      return function(ev, btn) {
        return CUI.decide(typeof onClick === "function" ? onClick(ev, btn, _this) : void 0).done(function() {
          return _this.__popover.hide();
        });
      };
    })(this);
    btn = new CUI.defaults["class"].Button(btn_opts);
    btn.disable();
    opts.pane.footer_right = btn;
    mod = new Modal(opts);
    if (this.__orig_set_data) {
      Events.listen({
        type: "data-changed",
        node: mod,
        call: (function(_this) {
          return function() {
            if (_this.hasChanges()) {
              return btn.enable();
            } else {
              return btn.disable();
            }
          };
        })(this)
      });
    }
    return mod;
  };

  FormModal.prototype.revertData = function() {
    assert(this.__orig_set_data, "Form.revertData", "Only supported with opts.name set and opts.data PlainObject.", {
      opts: this.opts
    });
    delete this.__data;
    if (this.__orig_data) {
      this.__orig_set_data[this._name] = this.__orig_data;
    } else {
      delete this.__orig_set_data[this._name];
    }
    this.setData(this.__orig_set_data);
    this.callOnFields("remove");
    this.table = null;
    Events.trigger({
      type: "data-changed",
      node: this.getPopover()
    });
    return this;
  };

  FormModal.prototype.setData = function(data) {
    if (this._name && !CUI.isFunction(data)) {
      if (data[this._name]) {
        this.__orig_data = copyObject(data[this._name], true);
      } else {
        this.__orig_data = void 0;
      }
      this.__orig_set_data = data;
    }
    return FormModal.__super__.setData.call(this, data);
  };

  FormModal.prototype.__closePopover = function() {
    if (this.__orig_set_data) {
      this.__orig_data = copyObject(this.__orig_set_data[this._name], true);
    }
    return FormModal.__super__.__closePopover.call(this);
  };

  FormModal.prototype.hasChanges = function() {
    if (this.__orig_set_data) {
      return JSON.stringify(this.__orig_data) !== JSON.stringify(this.__orig_set_data[this._name]);
    } else {
      return null;
    }
  };

  FormModal.prototype.getPopoverOpts = function() {
    var onCancel, pop_opts;
    pop_opts = copyObject(this._modal, true);
    if (pop_opts.cancel && this.__orig_set_data) {
      onCancel = pop_opts.onCancel;
      pop_opts.onCancel = (function(_this) {
        return function(ev, modal) {
          var dfr;
          dfr = new CUI.Deferred();
          CUI.decide(typeof onCancel === "function" ? onCancel(ev, modal, _this.hasChanges()) : void 0).done(dfr.resolve).fail(dfr.reject);
          dfr.done(function() {
            return _this.revertData();
          });
          return dfr.promise();
        };
      })(this);
    }
    delete pop_opts.apply_button;
    if (isEmpty(pop_opts["class"])) {
      pop_opts["class"] = "";
    }
    pop_opts.element = null;
    if (!pop_opts.pane) {
      pop_opts.pane = {};
    }
    assert(CUI.isPlainObject(pop_opts.pane), "new FormModal", "opts.pane must be PlainObject", {
      opts: pop_opts
    });
    pop_opts["class"] += " cui-form-modal-modal";
    return pop_opts;
  };

  FormModal.prototype.disable = function() {
    var ref;
    FormModal.__super__.disable.call(this);
    return (ref = this.__button) != null ? ref.disable() : void 0;
  };

  FormModal.prototype.enable = function() {
    var ref;
    FormModal.__super__.enable.call(this);
    return (ref = this.__button) != null ? ref.enable() : void 0;
  };

  FormModal.prototype.destroy = function() {
    var ref;
    FormModal.__super__.destroy.call(this);
    return (ref = this.__popover) != null ? ref.destroy() : void 0;
  };

  return FormModal;

})(FormPopover);
// Generated by CoffeeScript 1.9.3
var DataTable,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DataTable = (function(superClass) {
  extend(DataTable, superClass);

  function DataTable(opts) {
    this.opts = opts;
    DataTable.__super__.constructor.call(this, this.opts);
    this.addClass("cui-padding-reset");
  }

  DataTable.prototype.initOpts = function() {
    DataTable.__super__.initOpts.call(this);
    return this.addOpts({
      fields: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      new_rows: {
        "default": "edit",
        check: ["edit", "append", "remove_only", "none"]
      },
      no_header: {
        check: Boolean
      },
      rowMove: {
        "default": false,
        check: Boolean
      },
      onRowRemove: {
        check: Function
      },
      onNodeAdd: {
        check: Function
      },
      maximize: {
        check: Boolean
      },
      maximize_horizontal: {
        check: Boolean,
        "default": false
      },
      maximize_vertical: {
        check: Boolean,
        "default": false
      },
      footer_right: {
        check: function(v) {
          return isContent(v);
        }
      }
    });
  };

  DataTable.prototype.getFieldList = function() {
    return this.__fieldList;
  };

  DataTable.prototype.getFieldsByName = function(name, found_fields) {
    var field, i, len, ref;
    if (found_fields == null) {
      found_fields = [];
    }
    ref = this.getFieldList();
    for (i = 0, len = ref.length; i < len; i++) {
      field = ref[i];
      if (field.getName() === name) {
        found_fields.push(field);
      }
      if (typeof field.getFieldsByName === "function") {
        field.getFieldsByName(name, found_fields);
      }
    }
    return found_fields;
  };

  DataTable.prototype.debug = function() {
    var ref;
    DataTable.__super__.debug.call(this);
    return (ref = this.listView) != null ? ref.debug() : void 0;
  };

  DataTable.prototype.init = function() {
    var _field, field, i, len, ref, results;
    this.__fieldList = [];
    ref = this.getArrayFromOpt("fields");
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      field = ref[i];
      _field = DataField["new"](field);
      results.push(this.__fieldList.push(_field));
    }
    return results;
  };

  DataTable.prototype.disable = function() {
    var ref;
    DataTable.__super__.disable.call(this);
    if ((ref = this.listView) != null) {
      ref.setInactive(true, null);
    }
    return this;
  };

  DataTable.prototype.enable = function() {
    var ref;
    DataTable.__super__.enable.call(this);
    if ((ref = this.listView) != null) {
      ref.setInactive(false, null);
    }
    return this;
  };

  DataTable.prototype.getDefaultValue = function() {
    return [];
  };

  DataTable.prototype.render = function() {
    var buttons, cls, colClasses, cols, f, footer, i, label, len, name, ref, ref1, ref2, ref3, ref4, updateMinusButton;
    DataTable.__super__.render.call(this);
    cols = [];
    colClasses = [];
    this.headerRow = new ListViewHeaderRow();
    ref = this.__fieldList;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if ((ref1 = f._form) != null ? ref1.column : void 0) {
        cols.push(f._form.column);
      } else if (f.isResizable()) {
        cols.push("auto");
      } else {
        cols.push("fixed");
      }
      name = f.getName();
      label = (ref2 = f._form) != null ? ref2.label : void 0;
      if (isNull(label)) {
        label = name;
      }
      cls = [];
      if (name) {
        cls.push("cui-data-table-column-field-name-" + name);
      }
      cls.push("cui-data-table-column-field-type-" + toDash(f.getElementClass()));
      if ((ref3 = f._form) != null ? ref3.rotate_90 : void 0) {
        cls.push("cui-lv-td-rotate-90");
      }
      colClasses.push(cls);
      this.headerRow.addColumn(new ListViewHeaderColumn({
        rotate_90: (ref4 = f._form) != null ? ref4.rotate_90 : void 0,
        label: {
          text: label,
          multiline: true
        }
      }));
    }
    buttons = [];
    if (this._new_rows !== "none") {
      if (this._new_rows !== "remove_only") {
        buttons.push({
          icon: "plus",
          group: "plus-minus",
          onClick: (function(_this) {
            return function() {
              var d, new_node;
              _this.rows.push(d = {});
              new_node = new DataTableNode({
                dataTable: _this,
                data: d,
                rows: _this.rows
              });
              if (typeof _this._onNodeAdd === "function") {
                _this._onNodeAdd(node);
              }
              _this.listView.appendRow(new_node);
              return _this.storeValue(copyObject(_this.rows, true));
            };
          })(this)
        });
      }
      buttons.push(this.minusButton = new CUI.defaults["class"].Button({
        icon: "minus",
        group: "plus-minus",
        disabled: true,
        onClick: (function(_this) {
          return function() {
            var j, len1, ref5, row;
            ref5 = _this.listView.getSelectedRows();
            for (j = 0, len1 = ref5.length; j < len1; j++) {
              row = ref5[j];
              row.remove();
            }
            _this.storeValue(copyObject(_this.rows, true));
          };
        })(this)
      }));
    }
    if (buttons.length) {
      footer = new Buttonbar({
        buttons: buttons
      });
    }
    updateMinusButton = (function(_this) {
      return function() {
        if (_this.listView.getSelectedRows().length === 0) {
          return _this.minusButton.disable();
        } else {
          return _this.minusButton.enable();
        }
      };
    })(this);
    this.listView = new ListView({
      selectableRows: this._new_rows !== "none",
      onSelect: updateMinusButton,
      onDeselect: updateMinusButton,
      onRowMove: (function(_this) {
        return function(display_from_i, display_to_i, after) {
          var fr;
          fr = _this.listView.fixedRowsCount;
          moveInArray(display_from_i - fr, display_to_i - fr, _this.rows, after);
          return Events.trigger({
            type: "data-changed",
            node: _this.listView
          });
        };
      })(this),
      cols: cols,
      fixedRows: this._no_header ? 0 : 1,
      footer_left: footer,
      footer_right: this._footer_right,
      fixedCols: 1,
      colResize: this._no_header ? false : true,
      colClasses: colClasses,
      rowMove: this._rowMove,
      rowMovePlaceholder: !this._rowMove,
      maximize: this._maximize,
      maximize_horizontal: this._maximize_horizontal,
      maximize_vertical: this._maximize_vertical
    });
    if (this.isDisabled()) {
      this.listView.setInactive(true, null);
    }
    this.replace(this.listView.render());
    Events.listen({
      type: "data-changed",
      node: this.listView,
      call: (function(_this) {
        return function(ev, info) {
          ev.stopPropagation();
          _this.storeValue(copyObject(_this.rows, true));
        };
      })(this)
    });
    return this;
  };

  DataTable.prototype.displayValue = function() {
    var i, idx, len, node, ref, ref1, row;
    this.listView.removeAllRows();
    if (!this._no_header) {
      this.listView.appendRow(this.headerRow);
    }
    this.rows = copyObject(this.getValue(), true);
    assert(CUI.isArray(this.rows), "DataTable.displayValue", "\"value\" needs to be Array.", {
      data: this.getData(),
      value: this.getValue()
    });
    if (this.rows) {
      ref = this.rows;
      for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
        row = ref[idx];
        node = new DataTableNode({
          dataTable: this,
          data: row,
          rows: this.rows,
          check_changed_data: (ref1 = this.getInitValue()) != null ? ref1[idx] : void 0
        });
        if (typeof this._onNodeAdd === "function") {
          this._onNodeAdd(node);
        }
        this.listView.appendRow(node, true);
      }
      this.listView.appendDeferredRows();
    }
    return this;
  };

  return DataTable;

})(DataFieldInput);
// Generated by CoffeeScript 1.9.3
var DataTableNode,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DataTableNode = (function(superClass) {
  extend(DataTableNode, superClass);

  function DataTableNode() {
    return DataTableNode.__super__.constructor.apply(this, arguments);
  }

  DataTableNode.prototype.initOpts = function() {
    DataTableNode.__super__.initOpts.call(this);
    return this.addOpts({
      dataTable: {
        mandatory: true,
        check: DataTable
      },
      data: {
        mandatory: true,
        check: "PlainObject"
      },
      check_changed_data: {
        check: "PlainObject"
      },
      rows: {
        mandatory: true,
        check: "Array"
      }
    });
  };

  DataTableNode.prototype.readOpts = function() {
    var _f, f, fopts, i, len, ref;
    DataTableNode.__super__.readOpts.call(this);
    this.__dataTable = this._dataTable;
    this.__data = this._data;
    this.__check_changed_data = this._check_changed_data;
    this.__rows = this._rows;
    assert(this.__rows.indexOf(this.__data) > -1, "new " + (getObjectClass(this)), "opts.data needs to be item in opts.rows Array", {
      opts: this.opts
    });
    this.__fields = [];
    ref = this.__dataTable.getFieldList();
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      fopts = f.getOpts();
      fopts.undo_support = false;
      _f = new window[f.__cls](fopts);
      _f.setForm(this);
      _f.setData(this.__data);
      if (f.hasData()) {
        if (this.__check_changed_data) {
          _f.setCheckChangedValue(this.__check_changed_data[f.getName()]);
        } else {
          _f.setCheckChangedValue(f.getDefaultValue());
        }
      }
      this.__fields.push(_f);
      this.addColumn(new ListViewColumn({
        element: _f.DOM
      }));
    }
    return this;
  };

  DataTableNode.prototype.remove = function() {
    var ref;
    DataTableNode.__super__.remove.call(this);
    if ((ref = this._dataTable._onRowRemove) != null) {
      ref.call(this, this.__data);
    }
    return removeFromArray(this.__data, this.__rows);
  };

  DataTableNode.prototype.getDataTable = function() {
    return this._dataTable;
  };

  DataTableNode.prototype.getFieldByIdx = function(idx) {
    return this.__fields[idx];
  };

  DataTableNode.prototype.getFieldsByName = function(name) {
    var f, fields, i, len, ref;
    fields = [];
    ref = this.__fields;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      if (f.getName() === name) {
        fields.push(f);
      }
    }
    return fields;
  };

  DataTableNode.prototype.getFields = function() {
    return this.__fields;
  };

  DataTableNode.prototype.getData = function() {
    return this.__data;
  };

  DataTableNode.prototype.addedToListView = function() {
    var df, i, len, ref;
    ref = this.__fields;
    for (i = 0, len = ref.length; i < len; i++) {
      df = ref[i];
      df.start();
    }
    return this;
  };

  return DataTableNode;

})(ListViewRow);
// Generated by CoffeeScript 1.9.3
var Select,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Select = (function(superClass) {
  extend(Select, superClass);

  function Select() {
    return Select.__super__.constructor.apply(this, arguments);
  }

  Select.prototype.initOpts = function() {
    Select.__super__.initOpts.call(this);
    return this.addOpts({
      empty_text: {
        check: String
      },
      not_found_text: {
        "default": "- not found -",
        check: String
      },
      options: {
        mandatory: true,
        check: function(v) {
          return CUI.isArray(v) || CUI.isFunction(v);
        }
      },
      group: {
        check: String
      },
      onShow: {
        check: Function
      },
      onHide: {
        check: Function
      }
    });
  };

  Select.prototype.init = function() {
    this.__value = null;
    if (!CUI.isFunction(this._options)) {
      return this.__loadOptions();
    }
  };

  Select.prototype.disable = function(__wasAutomaticDisabled) {
    this.__wasAutomaticDisabled = __wasAutomaticDisabled != null ? __wasAutomaticDisabled : false;
    return Select.__super__.disable.call(this);
  };

  Select.prototype.isDisabled = function() {
    if (this.__wasAutomaticDisabled) {
      return false;
    } else {
      return Select.__super__.isDisabled.call(this);
    }
  };

  Select.prototype.enableOption = function(value) {
    var opt;
    opt = this.__getOptionByValue(value);
    if (!opt) {
      return;
    }
    opt.disabled = false;
    return this.displayValue();
  };

  Select.prototype.disableOption = function(value) {
    var opt;
    opt = this.__getOptionByValue(value);
    if (!opt) {
      return;
    }
    opt.disabled = true;
    return this.displayValue();
  };

  Select.prototype.__getOptionByValue = function(value) {
    var i, len, opt, ref;
    ref = this.getOptions();
    for (i = 0, len = ref.length; i < len; i++) {
      opt = ref[i];
      if (opt.value === value) {
        return opt;
      }
    }
    return null;
  };

  Select.prototype.enable = function(automatic) {
    if (automatic == null) {
      automatic = false;
    }
    if (automatic) {
      if (this.__wasAutomaticDisabled) {
        return Select.__super__.enable.call(this);
      } else {

      }
    } else {
      return Select.__super__.enable.call(this);
    }
  };

  Select.prototype.__loadOptions = function(event) {
    this.__optionsPromise = this.getPromiseFromOpt("options", event);
    if (!this.isDisabled()) {
      this.disable(true);
      this.__optionsPromise.always((function(_this) {
        return function() {
          return _this.enable(true);
        };
      })(this));
    }
    this.__optionsPromise.done((function(_this) {
      return function(__options) {
        var first_value_opt, i, idx, len, opt, ref;
        _this.__options = __options;
        first_value_opt = void 0;
        ref = _this.__options;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          opt = ref[idx];
          opt._idx = idx;
          if (isUndef(opt.text) && !isUndef(opt.value) && !opt.icon) {
            opt.text = "" + opt.value;
          }
          if (isUndef(opt.value) && !isUndef(opt.text)) {
            opt.value = opt.text;
          }
          if (!isUndef(opt.value) && first_value_opt === void 0) {
            first_value_opt = opt;
          }
        }
        _this._default_opt = void 0;
        if (first_value_opt) {
          _this.default_opt = first_value_opt;
          return _this.__value = _this.default_opt.value;
        } else {
          return CUI.warn("Select " + (_this.getName()) + ": did not find a value opt and no empty text is defined.", {
            opts: _this.opts
          });
        }
      };
    })(this));
    return this.__optionsPromise;
  };

  Select.prototype.setData = function(data) {
    Select.__super__.setData.call(this, data, false);
    if (CUI.isFunction(this._options)) {
      this.__loadOptions().done((function(_this) {
        return function() {
          return _this.initData();
        };
      })(this));
    } else {
      this.initData();
    }
    return this;
  };

  Select.prototype.getCheckboxClass = function() {
    return "cui-button-select";
  };

  Select.prototype.getButtonOpts = function() {
    var ref;
    return {
      group: this._group,
      role: "select",
      left: true,
      menu: {
        active_item_idx: ((ref = this.default_opt) != null ? ref._idx : void 0) || null,
        allow_null: !isEmpty(this._empty_text),
        "class": "ez-menu-select",
        onDeactivate: (function(_this) {
          return function(btn, item, idx, flags) {
            _this.storeValue(null, flags);
            if (_this.isDestroyed()) {
              return;
            }
            _this.displayValue();
            return _this;
          };
        })(this),
        onClick: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onClick) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onShow: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onShow) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onHide: (function(_this) {
          return function() {
            var ref1;
            return (ref1 = _this._onHide) != null ? ref1.apply(_this, arguments) : void 0;
          };
        })(this),
        onActivate: (function(_this) {
          return function(btn, item, idx, flags) {
            _this.storeValue(_this.__options[idx].value, flags);
            if (_this.isDestroyed()) {
              return;
            }
            _this.displayValue();
            return _this;
          };
        })(this),
        items: (function(_this) {
          return function(event) {
            return _this.__loadOptions(event).done(function() {
              return _this.displayValue();
            });
          };
        })(this),
        has_items: true
      }
    };
  };

  Select.prototype.getDefaultValue = function() {
    if (this.default_opt) {
      return this.default_opt.value;
    } else {
      return void 0;
    }
  };

  Select.prototype.getValue = function() {
    if (this.hasData()) {
      return Select.__super__.getValue.call(this);
    } else {
      return this.__value;
    }
  };

  Select.prototype.checkValue = function(v, flags) {
    return true;
  };

  Select.prototype.reload = function() {
    if (CUI.isFunction(this._options)) {
      this.__loadOptions();
    }
    return Select.__super__.reload.call(this);
  };

  Select.prototype.storeValue = function(value, flags) {
    if (this.hasData()) {
      Select.__super__.storeValue.call(this, value, flags);
    } else {
      this.__value = value;
    }
    return this;
  };

  Select.prototype.displayValue = function() {
    DataFieldInput.prototype.displayValue.call(this);
    if (!this.__optionsPromise && CUI.isFunction(this._options)) {
      this.__loadOptions();
    }
    this.__optionsPromise.done((function(_this) {
      return function() {
        var found_opt, i, idx, len, max_chars, opt, ref, ref1, ref2;
        found_opt = null;
        max_chars = null;
        ref = _this.__options;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          opt = ref[idx];
          if (found_opt === null && opt.value === _this.getValue()) {
            found_opt = opt;
          }
          if (((ref1 = opt.text) != null ? ref1.length : void 0) > max_chars) {
            max_chars = (ref2 = opt.text) != null ? ref2.length : void 0;
          }
        }
        if (found_opt) {
          if (found_opt.icon) {
            _this.__checkbox.setIcon(found_opt.icon);
          } else {
            _this.__checkbox.setIcon(null);
          }
          _this.__checkbox.setText(found_opt.text_selected || found_opt.text);
          _this.__checkbox.menuSetActiveIdx(found_opt._idx);
        } else {
          if (_this.getValue() === null && !isEmpty(_this._empty_text)) {
            _this.__checkbox.setText(_this._empty_text);
          } else {
            _this.__checkbox.setText(_this._not_found_text + ":" + _this.getValue());
          }
          _this.__checkbox.menuSetActiveIdx(null);
        }
        return _this.__checkbox.setTextMaxChars(max_chars);
      };
    })(this));
    return this;
  };

  Select.prototype.getOptions = function() {
    return this.__options;
  };

  Select.newSelectOrOutput = function(opts) {
    var out_opts;
    if (opts.options.length === 1) {
      out_opts = {
        form: opts.form,
        text: opts.options[0].text
      };
      return new Output(out_opts);
    } else {
      return new Select(opts);
    }
  };

  return Select;

})(Checkbox);
// Generated by CoffeeScript 1.9.3
var StickyHeader,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StickyHeader = (function(superClass) {
  extend(StickyHeader, superClass);

  function StickyHeader(opts) {
    this.opts = opts != null ? opts : {};
    StickyHeader.__super__.constructor.call(this, this.opts);
    this.header = new Template({
      name: "sticky-header",
      map: {
        center: true
      }
    });
    this.registerTemplate(this.header);
    this.addClass("cui-sticky-header-level-" + this._level);
    if (!isEmpty(this._text)) {
      this.replace($text(this._text), "center");
    } else {
      this.replace(this._content, "center");
    }
    this._control.addStickyHeader(this);
  }

  StickyHeader.prototype.initOpts = function() {
    StickyHeader.__super__.initOpts.call(this);
    return this.addOpts({
      control: {
        mandatory: true,
        check: StickyHeaderControl
      },
      text: {
        check: String
      },
      content: {},
      level: {
        "default": 0,
        check: function(v) {
          return v === 0 || v === 1 || v === 2;
        }
      }
    });
  };

  StickyHeader.prototype.getLevel = function() {
    return this._level;
  };

  return StickyHeader;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var StickyHeaderControl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StickyHeaderControl = (function(superClass) {
  extend(StickyHeaderControl, superClass);

  function StickyHeaderControl(opts) {
    var ref, ref1;
    this.opts = opts != null ? opts : {};
    StickyHeaderControl.__super__.constructor.call(this, this.opts);
    if ((ref = DOM.data(this._element[0], "stickyHeaderControl")) != null) {
      ref.destroy();
    }
    DOM.data(this._element[0], "stickyHeaderControl", this);
    if ((ref1 = this._element.css("position")) !== "absolute" && ref1 !== "fixed" && ref1 !== "relative") {
      this._element.css("position", "relative");
    }
    this.__control = $div("cui-sticky-header-control");
    this._element.append(this.__control);
    this.headers = [];
    this.newStickyHeaders = [];
    this.__hiddenHeaders = [];
    this.__positioned = false;
    Events.listen({
      node: this._element,
      type: "scroll",
      instance: this,
      call: (function(_this) {
        return function(ev) {
          _this.position();
        };
      })(this)
    });
  }

  StickyHeaderControl.prototype.initOpts = function() {
    StickyHeaderControl.__super__.initOpts.call(this);
    return this.addOpts({
      element: {
        mandatory: true,
        check: function(v) {
          return isElement(v);
        }
      }
    });
  };

  StickyHeaderControl.prototype.isInDOM = function() {
    return this.__control && DOM.isInDOM(this.__control[0]);
  };

  StickyHeaderControl.prototype.addStickyHeader = function(stickyHeader) {
    assert(!this.__positioned || DOM.isInDOM(this.__control[0]), this.__cls + ".addStickyHeader", "StickyHeaderControl is not in DOM tree anymore. Cannot add a new StickyHeader.");
    assert(stickyHeader instanceof StickyHeader, this.__cls + ".addStickyHeader", "Needs to be instance of StickyHeader but is " + (getObjectClass(stickyHeader)), {
      stickyHeader: stickyHeader
    });
    return this.newStickyHeaders.push(stickyHeader);
  };

  StickyHeaderControl.prototype.initNewStickyHeaders = function() {
    var dom, header, j, k, len, len1, measure_headers, nsh, ref;
    measure_headers = [];
    ref = this.newStickyHeaders;
    for (j = 0, len = ref.length; j < len; j++) {
      nsh = ref[j];
      dom = nsh.DOM;
      header = {
        stickyHeader: nsh,
        level: nsh.getLevel(),
        node: dom[0].cloneNode(true)
      };
      this.headers.push(header);
      measure_headers.push(header);
      header.node.style.visiblity = "hidden";
      this.__control.prepend(header.node);
    }
    this.newStickyHeaders.splice(0);
    for (k = 0, len1 = measure_headers.length; k < len1; k++) {
      header = measure_headers[k];
      header.dimInControl = DOM.getDimensions(header.node);
      this.__control[0].removeChild(header.node);
      header.node.style.visiblity = "";
    }
    return this;
  };

  StickyHeaderControl.prototype.destroy = function() {
    DOM.removeData(this._element[0], "stickyHeaderControl");
    Events.ignore({
      instance: this
    });
    this.__control.remove();
    this.__headers = null;
    return this.newStickyHeaders = null;
  };

  StickyHeaderControl.prototype.position = function() {
    var cut, extraTop, header, hiddenHeader, hideHeader, i, idx, j, k, l, len, len1, len2, len3, m, n, next_header, o, ref, ref1, ref2, ref3, ref4, scrollTop, slot, slots, top, top_space;
    if (!this.isInDOM()) {
      return;
    }
    this.__positioned = true;
    this.initNewStickyHeaders();
    this._element.append(this.__control);
    scrollTop = this._element[0].scrollTop;
    slots = [];
    extraTop = 0;
    ref = this.headers;
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      header = ref[idx];
      extraTop = 0;
      for (i = k = 0, ref1 = header.level; k < ref1; i = k += 1) {
        slot = slots[i];
        if (slot === null) {
          break;
        }
        extraTop += slots[i].dimInControl.marginBoxHeight;
      }
      if (header.stickyHeader.DOM[0].offsetTop < scrollTop + extraTop + header.dimInControl.marginTop) {
        slots[header.level] = header;
        for (i = l = ref2 = header.level + 1, ref3 = slots.length; l < ref3; i = l += 1) {
          slots[i] = null;
        }
      } else {
        next_header = header;
        top_space = 0;
        for (m = 0, len1 = slots.length; m < len1; m++) {
          slot = slots[m];
          if (slot === null) {
            break;
          }
          top_space += slot.dimInControl.marginBoxHeight;
        }
        break;
      }
    }
    if (next_header) {
      cut = next_header.stickyHeader.DOM[0].offsetTop - scrollTop - top_space;
      cut = cut - next_header.dimInControl.marginTop;
    } else {
      cut = 0;
    }
    ref4 = this.__hiddenHeaders;
    for (n = 0, len2 = ref4.length; n < len2; n++) {
      hiddenHeader = ref4[n];
      hiddenHeader.style.visibility = "";
    }
    this.__hiddenHeaders.splice(0);
    this.__control.empty();
    top = 0;
    for (idx = o = 0, len3 = slots.length; o < len3; idx = ++o) {
      slot = slots[idx];
      if (slot === null) {
        break;
      }
      this.__control.prepend(slot.node);
      if (cut < 0 && slot.level === next_header.level) {
        top += cut;
      }
      hideHeader = slot.stickyHeader.DOM[0];
      hideHeader.style.visibility = "hidden";
      this.__hiddenHeaders.push(hideHeader);
      slot.node.style.top = top + "px";
      top += slot.dimInControl.marginBoxHeight;
    }
    this.__control.css({
      top: scrollTop,
      height: top
    });
    return this;
  };

  return StickyHeaderControl;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
var DigiDisplay,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DigiDisplay = (function(superClass) {
  extend(DigiDisplay, superClass);

  function DigiDisplay(opts) {
    this.opts = opts != null ? opts : {};
    DigiDisplay.__super__.constructor.call(this, this.opts);
    this.__digitsMap = [];
    this.createMarkup();
    this.registerDOMElement(this.__displayDiv);
  }

  DigiDisplay.prototype.initOpts = function() {
    DigiDisplay.__super__.initOpts.call(this);
    return this.addOpts({
      digits: {
        mandatory: true,
        check: Array
      }
    });
  };

  DigiDisplay.prototype.display = function(str) {
    var _idx, c, fc, idx, info, j, len, ref;
    ref = str.split("");
    for (idx = j = 0, len = ref.length; j < len; idx = ++j) {
      c = ref[idx];
      if (idx === this._digits.length) {
        break;
      }
      info = this.__digitsMap[idx];
      if (!info) {
        continue;
      }
      if (info.map.hasOwnProperty(c)) {
        _idx = info.map[c];
      } else {
        _idx = 0;
      }
      fc = info.first_div;
      if (!info.height) {
        info.height = fc.outerHeight();
      }
      fc.css("marginTop", "-" + (_idx * info.height) + "px");
      fc.attr("c", c);
      fc.attr("idx", _idx);
    }
    return this;
  };

  DigiDisplay.prototype.createMarkup = function() {
    var c, container, digit, digit_idx, fc, i, idx, j, k, len, map, matched, ref;
    this.__displayDiv = $div("cui-digi-display");
    ref = this._digits;
    for (digit_idx = j = 0, len = ref.length; j < len; digit_idx = ++j) {
      digit = ref[digit_idx];
      if (digit["static"]) {
        this.__displayDiv.append(container = $div("cui-digi-display-static cui-digi-display-" + digit_idx));
        container.append($text(digit["static"])).addClass(digit["class"]);
        if (digit.attr) {
          container.attr(digit.attr);
        }
        continue;
      }
      digit.__regexp = new RegExp(digit.mask);
      this.__displayDiv.append(container = $div("cui-digi-display-container cui-digi-display-" + digit_idx));
      container.addClass(digit["class"]);
      if (digit.attr) {
        container.attr(digit.attr);
      }
      this.__digitsMap[digit_idx] = {
        map: (map = {})
      };
      container.append(fc = $div("cui-digi-display-digit").html("&nbsp;"));
      this.__digitsMap[digit_idx].first_div = fc;
      idx = 1;
      matched = false;
      for (i = k = 32; k <= 128; i = ++k) {
        if (digit.__regexp.exec(c = String.fromCharCode(i))) {
          if (i === 32) {
            container.append($div("cui-digi-display-digit").html("&nbsp;"));
          } else {
            container.append($div("cui-digi-display-digit").text(c));
          }
          map[c] = idx;
          idx++;
          matched = true;
        }
      }
      assert(matched, "DigiDisplay.createMarkup", "Digit " + digit_idx + " not matched against the regexp. ASCII range 32-128 is allowed.", {
        digit: digit
      });
    }
    return this.__displayDiv;
  };

  return DigiDisplay;

})(CUI.DOM);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowserNode = (function(superClass) {
  extend(DocumentBrowserNode, superClass);

  function DocumentBrowserNode() {
    return DocumentBrowserNode.__super__.constructor.apply(this, arguments);
  }

  DocumentBrowserNode.prototype.readOpts = function() {
    DocumentBrowserNode.__super__.readOpts.call(this);
    this.__url = this._url;
    if (this.__url.endsWith("/")) {
      return this.__url = this.__url.substr(0, this.__url.length - 1);
    }
  };

  DocumentBrowserNode.prototype.initOpts = function() {
    DocumentBrowserNode.__super__.initOpts.call(this);
    return this.addOpts({
      url: {
        check: function(v) {
          return !!CUI.parseLocation(v);
        }
      },
      path: {
        "default": [],
        check: Array
      },
      text: {
        check: String
      }
    });
  };

  DocumentBrowserNode.prototype.getChildren = function() {
    if (this.opts.leaf) {
      return [];
    }
    return this.__loadChildren();
  };

  DocumentBrowserNode.prototype.__loadChildren = function(dive) {
    var dfr;
    if (dive == null) {
      dive = true;
    }
    dfr = new CUI.Deferred();
    new CUI.XHR({
      url: this.__url + this.getNodePath("menu.cms"),
      responseType: "text"
    }).start().done((function(_this) {
      return function(data, xhr) {
        var child, children, children_done, i, idx, info, item, items, j, len, len1, m, path, ref, row, text;
        children = [];
        items = [];
        ref = data.split("\n");
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          m = row.match(/^\s*(\S+?)(|=(\S+))\s*$/);
          if (!m) {
            continue;
          }
          info = m[1].split(":");
          if (m[3]) {
            text = m[3];
          } else {
            text = info[0];
          }
          path = _this._path.slice(0);
          path.push(info[0]);
          items.push({
            text: text,
            path: path
          });
        }
        if (items.length === 0) {
          _this.opts.leaf = true;
          dfr.resolve([]);
          return;
        }
        children_done = 0;
        for (idx = j = 0, len1 = items.length; j < len1; idx = ++j) {
          item = items[idx];
          child = new CUI.DocumentBrowserNode({
            url: _this.__url,
            text: item.text,
            path: item.path
          });
          children.push(child);
          if (dive) {
            child.__loadChildren(false).always(function() {
              children_done = children_done + 1;
              if (children_done === items.length) {
                return dfr.resolve(children);
              }
            });
          }
        }
        if (!dive) {
          dfr.resolve(children);
        }
      };
    })(this)).fail((function(_this) {
      return function() {
        _this.opts.leaf = true;
        return dfr.resolve([]);
      };
    })(this));
    return dfr.promise();
  };

  DocumentBrowserNode.prototype.loadContent = function() {
    var filename;
    filename = this.getLastPathElement() + ".md";
    return new CUI.XHR({
      url: this.__url + this.getNodePath(filename),
      responseType: "text"
    }).start();
  };

  DocumentBrowserNode.prototype.selectLocation = function(nodePath, dfr) {
    var select_child;
    if (dfr == null) {
      dfr = new CUI.Deferred();
    }
    if (nodePath === this.getNodePath()) {
      dfr.resolve(this);
      return;
    }
    select_child = (function(_this) {
      return function() {
        var c, i, len, ref;
        if (_this.opts.leaf) {
          dfr.fail(_this);
        }
        ref = _this.children;
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          if (nodePath.startsWith(c.getNodePath() + "/") || nodePath === c.getNodePath()) {
            c.selectLocation(nodePath, dfr);
            return;
          }
        }
        console.error("Unable to find:", nodePath, "in", _this.getNodePath());
        return dfr.fail();
      };
    })(this);
    if (this.children) {
      select_child();
    } else {
      this.open().always((function(_this) {
        return function() {
          return select_child();
        };
      })(this));
    }
    return dfr;
  };

  DocumentBrowserNode.prototype.getLastPathElement = function() {
    return this._path[this._path.length - 1];
  };

  DocumentBrowserNode.prototype.getNodePath = function(filename) {
    var nodePath;
    nodePath = "/" + this._path.join("/");
    if (!filename) {
      return nodePath;
    } else if (nodePath === "/") {
      return nodePath + filename;
    } else {
      return nodePath + "/" + filename;
    }
  };

  DocumentBrowserNode.prototype.absoluteUrl = function(base, relative) {
    var i, len, part, parts, stack;
    stack = base.split("/");
    parts = relative.split("/");
    for (i = 0, len = parts.length; i < len; i++) {
      part = parts[i];
      if (part === ".") {
        continue;
      }
      if (part === "..") {
        stack.pop();
      } else {
        stack.push(part);
      }
    }
    return stack.join("/");
  };

  DocumentBrowserNode.prototype.rendererImage = function(href, title, text) {
    var _href, url;
    if (href.startsWith("http:") || href.startsWith("//")) {
      url = null;
    } else if (href.startsWith("/")) {
      url = this.__url;
    } else {
      url = this.__url + this.getNodePath();
    }
    if (url !== null) {
      _href = this.absoluteUrl(url, href);
    } else {
      _href = href;
    }
    return "<img src='" + _href + "' alt='" + escapeAttribute(text) + "' title='" + escapeAttribute(title) + "'></img>";
  };

  DocumentBrowserNode.prototype.renderContent = function() {
    return new Label({
      text: this._text,
      multiline: true
    });
  };

  return DocumentBrowserNode;

})(CUI.ListViewTreeNode);

CUI.DocumentBrowserRootNode = (function(superClass) {
  extend(DocumentBrowserRootNode, superClass);

  function DocumentBrowserRootNode() {
    return DocumentBrowserRootNode.__super__.constructor.apply(this, arguments);
  }

  return DocumentBrowserRootNode;

})(CUI.DocumentBrowserNode);
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.DocumentBrowser = (function(superClass) {
  extend(DocumentBrowser, superClass);

  function DocumentBrowser() {
    return DocumentBrowser.__super__.constructor.apply(this, arguments);
  }

  DocumentBrowser.prototype.initOpts = function() {
    DocumentBrowser.__super__.initOpts.call(this);
    return this.addOpts({
      gotoLocation: {
        check: Function,
        "default": (function(_this) {
          return function(nodePath) {
            return _this.loadLocation(nodePath);
          };
        })(this)
      },
      url: {
        check: function(v) {
          return !!CUI.parseLocation(v);
        }
      }
    });
  };

  DocumentBrowser.prototype.readOpts = function() {
    DocumentBrowser.__super__.readOpts.call(this, this.opts);
    this.__markedRenderer = new marked.Renderer();
    this.__markedRenderer.image = (function(_this) {
      return function(href, title, text) {
        return _this.__renderNode.rendererImage(href, title, text);
      };
    })(this);
    return this.__marked_opts = {
      renderer: this.__markedRenderer
    };
  };

  DocumentBrowser.prototype.loadLocation = function(nodePath) {
    if (!nodePath) {
      if (!this.__tree.root.children.length) {
        return;
      }
      return this.loadLocation(this.__tree.root.children[0].getNodePath());
    }
    return this.__tree.root.selectLocation(nodePath).done((function(_this) {
      return function(node) {
        node.select();
        return _this.loadContent(node);
      };
    })(this)).fail((function(_this) {
      return function() {
        return _this.loadEmpty();
      };
    })(this));
  };

  DocumentBrowser.prototype.loadEmpty = function() {
    return this.__layout.replace(new EmptyLabel({
      text: "No article available."
    }), "center");
  };

  DocumentBrowser.prototype.loadContent = function(node) {
    return node.loadContent().done((function(_this) {
      return function(content) {
        _this.__renderNode = node;
        return _this.__layout.replace(CUI.DOM.htmlToNodes(marked(content, _this.__marked_opts)), "center");
      };
    })(this)).fail((function(_this) {
      return function() {
        return _this.loadEmpty();
      };
    })(this));
  };

  DocumentBrowser.prototype.getRootNode = function() {
    return this.__tree.root;
  };

  DocumentBrowser.prototype.render = function() {
    this.__tree = new ListViewTree({
      cols: ["maximize"],
      selectable: true,
      onSelect: (function(_this) {
        return function(ev, info) {
          return _this._gotoLocation(info.node.getNodePath());
        };
      })(this),
      onDeselect: (function(_this) {
        return function(ev, info) {};
      })(this),
      root: new CUI.DocumentBrowserRootNode({
        url: this._url
      })
    });
    this.__layout = new HorizontalLayout({
      maximize: true,
      left: {
        content: this.__tree.render(false),
        flexHandle: {
          hidden: false
        }
      },
      center: {
        content: $text(this._url)
      }
    });
    return this.__layout;
  };

  DocumentBrowser.prototype.load = function() {
    return this.__tree.root.open();
  };

  return DocumentBrowser;

})(CUI.Element);
// Generated by CoffeeScript 1.9.3
CUI.Test = (function() {
  function Test() {}

  Test.prototype.run = function() {
    return this.idx = 0;
  };

  Test.prototype.eq = function(a, b) {
    if (JSON.stringify(a) === JSON.stringify(b)) {
      CUI.info("Test passed: eq: ", a, b);
      return true;
    }
    return CUI.error("Test failed: eq: ", a, b, this.test_func.toString());
  };

  Test.prototype.test = function(test_func) {
    this.test_func = test_func;
    this.test_func();
    return this.idx++;
  };

  Test.tests = [];

  Test.register = function(test) {
    assert(test instanceof Test, "Test.register", "Test needs to be instance of Test", {
      test: test
    });
    test.idx = this.tests.length;
    return this.tests.push(test);
  };

  Test.run = function() {
    var i, len, ref, test;
    ref = this.tests;
    for (i = 0, len = ref.length; i < len; i++) {
      test = ref[i];
      CUI.info("Running Test", getObjectClass(test));
      test.run();
    }
  };

  return Test;

})();
// Generated by CoffeeScript 1.9.3
var Test_MoveInArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Test_MoveInArray = (function(superClass) {
  extend(Test_MoveInArray, superClass);

  function Test_MoveInArray() {
    return Test_MoveInArray.__super__.constructor.apply(this, arguments);
  }

  Test_MoveInArray.prototype.run = function() {
    Test_MoveInArray.__super__.run.call(this);
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 1, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 2, a);
        return _this.eq(a, [1, 0, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 3, a);
        return _this.eq(a, [1, 2, 0, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(1, 0, a);
        return _this.eq(a, [1, 0, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 5, a, true);
        return _this.eq(a, [1, 2, 3, 4, 5, 0]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 5, a);
        return _this.eq(a, [1, 2, 3, 4, 0, 5]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(0, 6, a);
        return _this.eq(a, [1, 2, 3, 4, 5, 0]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(2, 3, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 3, a);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 3, a, true);
        return _this.eq(a, [0, 1, 2, 3, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 1, a);
        return _this.eq(a, [0, 3, 1, 2, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4, 5];
        moveInArray(3, 4, a, true);
        return _this.eq(a, [0, 1, 2, 4, 3, 5]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(3, 1, a, true);
        return _this.eq(a, [0, 1, 3, 2, 4]);
      };
    })(this));
    this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 3, a, true);
        return _this.eq(a, [1, 2, 3, 0, 4]);
      };
    })(this));
    return this.test((function(_this) {
      return function() {
        var a;
        a = [0, 1, 2, 3, 4];
        moveInArray(0, 4, a, true);
        return _this.eq(a, [1, 2, 3, 4, 0]);
      };
    })(this));
  };

  return Test_MoveInArray;

})(CUI.Test);

CUI.Test.register(new Test_MoveInArray());
// Generated by CoffeeScript 1.9.3
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CUI.Test_Promise = (function(superClass) {
  extend(Test_Promise, superClass);

  function Test_Promise() {
    return Test_Promise.__super__.constructor.apply(this, arguments);
  }

  Test_Promise.prototype.run = function() {
    var dfr, p;
    p = new Promise(function(resolve, reject) {
      return CUI.setTimeout({
        call: (function(_this) {
          return function() {
            p.then(function(v1) {
              console.debug("hello2", v1);
              p.then(function(v1) {
                return console.debug("hello3", v1);
              });
              return console.debug("hello4", v1);
            });
            console.debug("resolve yo2");
            return resolve("yo2");
          };
        })(this)
      });
    });
    p.then((function(_this) {
      return function(v1) {
        return console.debug("hello1", v1);
      };
    })(this));
    dfr = new CUI.Deferred();
    dfr.done((function(_this) {
      return function(v1) {
        return console.debug("dfr1", v1);
      };
    })(this));
    dfr.done((function(_this) {
      return function(v1) {
        console.debug("dfr2", v1);
        dfr.done(function(v1) {
          return console.debug("dfr3", v1);
        });
        return console.debug("dfr4", v1);
      };
    })(this));
    dfr.resolve("yo3");
  };

  return Test_Promise;

})(CUI.Test);

CUI.Test.register(new CUI.Test_Promise());
